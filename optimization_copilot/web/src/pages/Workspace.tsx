import { useState, useEffect, useCallback, Fragment } from "react";
import { useParams, Link } from "react-router-dom";
import {
  LayoutDashboard,
  Search,
  Beaker,
  Clock,
  Download,
  ChevronLeft,
  ChevronRight,
  Lightbulb,
  Sparkles,
  FlaskConical,
  Info,
  FileDown,
  Zap,
  AlertTriangle,
  CheckCircle,
  ArrowRight,
  Copy,
  Check,
  ArrowUpDown,
  ArrowUp,
  ArrowDown,
  Pause,
  Play,
  Square,
  FileSpreadsheet,
  FileJson,
  FileText,
  Image,
  BarChart3,
  Table,
  ClipboardList,
  Filter,
  TrendingDown,
  Hash,
  Home,
  RefreshCw,
  Flag,
  Trophy,
  Rocket,
  Target,
  Star,
  Undo2,
  Activity,
  GitCompare,
  Sliders,
  Crosshair,
  CheckSquare,
  Package,
  BookOpen,
  Tag,
  Hexagon,
  RotateCcw,
  X,
  Layers,
  Timer,
  Brain,
  BarChart2,
  Clipboard,
  TrendingUp,
  Grid,
  Eye,
  Shuffle,
  PieChart,
  Radar,
  GitBranch,
  BoxSelect,
  Compass,
  Volume2,
  Ruler,
  Circle,
  Minimize2,
  Gauge,
  MapPin,
  Scan,
  Waves,
  Grid3x3,
  Diamond,
  FlaskRound,
  Aperture,
  Orbit,
  Thermometer,
  ScatterChart,
  AlignVerticalJustifyStart,
  LayoutGrid,
  Wind,
  Magnet,
  Focus,
  Droplets,
  BarChartHorizontal,
  Flame,
  CircleDot,
  Share2,
  ScanLine,
  Map,
  HeartPulse,
  Microscope,
  CandlestickChart,
  Hourglass,
  Coins,
  GitMerge,
  ListOrdered,
  SplitSquareVertical,
  EyeOff,
  ShieldAlert,
  Fingerprint,
  BrainCircuit,
  Locate,
  Mountain,
  LineChart,
  Workflow,
  Split,
  Users,
  Award,
  Milestone,
  Shield,
  Banknote,
  Network,
  ArrowRightLeft,
  Cpu,
  Anchor,
  AlertOctagon,
  Calculator,
  Waypoints,                     // Batch 25
  Diff,
  Rabbit,
  Snail,
  Link2,                          // Batch 26
  Siren,
  Repeat2,
  MoveUpRight,                     // Batch 27
  Radio,                           // Batch 31
} from "lucide-react";
import { useCampaign } from "../hooks/useCampaign";
import { useToast } from "../components/Toast";
import { ChatPanel } from "../components/ChatPanel";
import PhaseTimeline from "../components/PhaseTimeline";
import RealConvergencePlot from "../components/ConvergencePlot";
import RealDiagnosticCards from "../components/DiagnosticCards";
import RealParameterImportance from "../components/ParameterImportance";
import RealScatterMatrix from "../components/ScatterMatrix";
import RealSuggestionCard from "../components/SuggestionCard";
import ParetoPlot from "../components/ParetoPlot";
import InsightsPanel from "../components/InsightsPanel";
import ErrorBoundary from "../components/ErrorBoundary";
import {
  fetchDiagnostics,
  fetchImportance,
  fetchSuggestions,
  fetchExport,
  pauseCampaign,
  resumeCampaign,
  stopCampaign,
  type DiagnosticsData,
  type ParameterImportanceData,
  type SuggestionData,
} from "../api";

const DIAGNOSTIC_TOOLTIPS: Record<string, string> = {
  convergence_trend: "Rate of improvement per iteration. Positive = still improving.",
  exploration_coverage: "Fraction of parameter space explored. 30-80% is ideal.",
  failure_rate: "Proportion of failed experiments. Below 20% is normal.",
  noise_estimate: "Measurement noise level. Lower means more reliable data.",
  plateau_length: "Consecutive iterations without improvement. >30 may mean converged.",
  signal_to_noise: "Signal vs noise ratio. >3 means reliable trends.",
  best_kpi_value: "Best objective value achieved so far.",
  improvement_velocity: "Recent rate of improvement. Near 0 = diminishing returns.",
};

function MiniRangeBar({ value, lower, upper }: { value: number; lower: number; upper: number }) {
  const range = upper - lower;
  if (range <= 0) return null;
  const pct = Math.max(0, Math.min(100, ((value - lower) / range) * 100));
  return (
    <div className="mini-range-bar" title={`${lower} – ${upper}`}>
      <div className="mini-range-track">
        <div className="mini-range-fill" style={{ width: `${pct}%` }} />
      </div>
    </div>
  );
}

function MiniSparkline({ values, highlightIdx }: { values: number[]; highlightIdx: number }) {
  if (values.length < 2) return null;
  const w = 48, h = 16, pad = 1;
  const min = Math.min(...values);
  const max = Math.max(...values);
  const range = max - min || 1;
  const points = values.map((v, i) => {
    const x = pad + (i / (values.length - 1)) * (w - 2 * pad);
    const y = pad + (1 - (v - min) / range) * (h - 2 * pad);
    return { x, y };
  });
  const pathD = points.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
  const hl = points[highlightIdx];
  return (
    <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} style={{ verticalAlign: "middle", marginLeft: "6px", flexShrink: 0 }}>
      <path d={pathD} fill="none" stroke="var(--color-primary)" strokeWidth="1.2" strokeLinecap="round" strokeLinejoin="round" opacity="0.5" />
      {hl && <circle cx={hl.x} cy={hl.y} r="2" fill="var(--color-primary)" />}
    </svg>
  );
}

export default function Workspace() {
  const { id } = useParams<{ id: string }>();
  const { campaign, loading, error, refresh, lastUpdated } = useCampaign(id);
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState<
    "overview" | "explore" | "suggestions" | "insights" | "history" | "export"
  >("overview");
  const [chatOpen, setChatOpen] = useState(true);

  // API data states
  const [diagnostics, setDiagnostics] = useState<DiagnosticsData | null>(null);
  const [importance, setImportance] = useState<ParameterImportanceData | null>(null);
  const [suggestions, setSuggestions] = useState<SuggestionData | null>(null);
  const [loadingSuggestions, setLoadingSuggestions] = useState(false);
  const [loadingDiag, setLoadingDiag] = useState(false);
  const [loadingImportance, setLoadingImportance] = useState(false);
  const [batchSize, setBatchSize] = useState(5);
  const [copied, setCopied] = useState(false);
  const [historySortCol, setHistorySortCol] = useState<string | null>(null);
  const [historySortDir, setHistorySortDir] = useState<"asc" | "desc">("asc");
  const [historyPage, setHistoryPage] = useState(0);
  const [historyFilter, setHistoryFilter] = useState("");
  const [expandedTrialId, setExpandedTrialId] = useState<string | null>(null);
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [dismissedWarnings, setDismissedWarnings] = useState<Set<string>>(new Set());
  const [bookmarks, setBookmarks] = useState<Set<string>>(() => {
    if (!id) return new Set<string>();
    try { const s = localStorage.getItem(`opt-bm-${id}`); return s ? new Set(JSON.parse(s) as string[]) : new Set<string>(); }
    catch { return new Set<string>(); }
  });
  const [trialNotes, setTrialNotes] = useState<Record<string, string>>(() => {
    if (!id) return {};
    try { const s = localStorage.getItem(`opt-notes-${id}`); return s ? JSON.parse(s) : {}; }
    catch { return {}; }
  });
  const [showBookmarkedOnly, setShowBookmarkedOnly] = useState(false);

  // Rejected suggestion stack (max 5)
  const [rejectedSuggestions, setRejectedSuggestions] = useState<Array<{ suggestion: Record<string, number>; index: number; timestamp: number }>>([]);
  const [showRejectedStack, setShowRejectedStack] = useState(false);

  // Convergence checkpoints
  const [checkpoints, setCheckpoints] = useState<Array<{ id: string; title: string; iteration: number; bestKpi: number; phase: string; timestamp: number }>>(() => {
    if (!id) return [];
    try { const s = localStorage.getItem(`opt-cp-${id}`); return s ? JSON.parse(s) : []; }
    catch { return []; }
  });
  const [showCheckpointModal, setShowCheckpointModal] = useState(false);
  const [checkpointTitle, setCheckpointTitle] = useState("");

  // Parameter sentinel toggle
  const [sentinelOpen, setSentinelOpen] = useState(true);

  // Trial comparison panel (History tab)
  const [compareSet, setCompareSet] = useState<Set<string>>(new Set());
  const [showCompareModal, setShowCompareModal] = useState(false);

  // What-if analysis (Explore tab)
  const [whatIfParam, setWhatIfParam] = useState<string | null>(null);
  const [whatIfValue, setWhatIfValue] = useState(0.5);

  // Goal tracker (Overview tab)
  const [goals, setGoals] = useState<Array<{ id: string; name: string; target: number; direction: "minimize" | "maximize"; created: number }>>(() => {
    if (!id) return [];
    try { const s = localStorage.getItem(`opt-goals-${id}`); return s ? JSON.parse(s) : []; }
    catch { return []; }
  });
  const [showGoalModal, setShowGoalModal] = useState(false);
  const [goalName, setGoalName] = useState("");
  const [goalTarget, setGoalTarget] = useState("");
  const [goalDirection, setGoalDirection] = useState<"minimize" | "maximize">("minimize");

  // Batch selection (Suggestions tab)
  const [selectedSuggestions, setSelectedSuggestions] = useState<Set<number>>(new Set());

  // Trial annotations / tags
  const [trialTags, setTrialTags] = useState<Record<string, string[]>>(() => {
    if (!id) return {};
    try { const s = localStorage.getItem(`opt-tags-${id}`); return s ? JSON.parse(s) : {}; }
    catch { return {}; }
  });
  const TRIAL_TAG_OPTIONS = ["promising", "anomaly", "investigate", "baseline", "outlier", "equipment-issue"] as const;

  // Decision journal (Overview tab)
  const [journalEntries, setJournalEntries] = useState<Array<{ id: string; text: string; iteration: number; timestamp: number }>>(() => {
    if (!id) return [];
    try { const s = localStorage.getItem(`opt-journal-${id}`); return s ? JSON.parse(s) : []; }
    catch { return []; }
  });
  const [journalInput, setJournalInput] = useState("");
  const [showJournal, setShowJournal] = useState(true);

  // Replay animation (Overview convergence)
  const [replayIdx, setReplayIdx] = useState<number | null>(null);
  const [replayPlaying, setReplayPlaying] = useState(false);

  // Statistical quick-compare (History tab)
  const [showStatCompare, setShowStatCompare] = useState(false);

  const HISTORY_PAGE_SIZE = 25;

  // Persist bookmarks & notes to localStorage
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-bm-${id}`, JSON.stringify([...bookmarks]));
  }, [id, bookmarks]);
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-notes-${id}`, JSON.stringify(trialNotes));
  }, [id, trialNotes]);
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-cp-${id}`, JSON.stringify(checkpoints));
  }, [id, checkpoints]);
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-goals-${id}`, JSON.stringify(goals));
  }, [id, goals]);
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-tags-${id}`, JSON.stringify(trialTags));
  }, [id, trialTags]);
  useEffect(() => {
    if (!id) return;
    localStorage.setItem(`opt-journal-${id}`, JSON.stringify(journalEntries));
  }, [id, journalEntries]);

  const toggleBookmark = useCallback((trialId: string) => {
    setBookmarks(prev => {
      const next = new Set(prev);
      if (next.has(trialId)) next.delete(trialId);
      else next.add(trialId);
      return next;
    });
  }, []);

  const setTrialNote = useCallback((trialId: string, note: string) => {
    setTrialNotes(prev => {
      if (!note.trim()) {
        const { [trialId]: _, ...rest } = prev;
        return rest;
      }
      return { ...prev, [trialId]: note };
    });
  }, []);

  const handleRejectSuggestion = useCallback((sug: Record<string, number>, index: number) => {
    setRejectedSuggestions(prev => {
      const next = [{ suggestion: sug, index, timestamp: Date.now() }, ...prev];
      return next.slice(0, 5);
    });
    toast(`Suggestion #${index} rejected`);
  }, [toast]);

  const handleReconsider = useCallback((idx: number) => {
    setRejectedSuggestions(prev => prev.filter((_, i) => i !== idx));
    toast("Suggestion reconsidered");
  }, [toast]);

  const handleCopyBest = useCallback((params: Record<string, number>) => {
    navigator.clipboard.writeText(JSON.stringify(params, null, 2)).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      toast("Parameters copied to clipboard");
    });
  }, [toast]);

  const handleHistorySort = useCallback((col: string) => {
    if (historySortCol === col) {
      setHistorySortDir((d) => (d === "asc" ? "desc" : "asc"));
    } else {
      setHistorySortCol(col);
      setHistorySortDir("asc");
    }
  }, [historySortCol]);

  // Keyboard shortcuts for tab navigation + power user actions
  useEffect(() => {
    const tabKeys: Record<string, typeof activeTab> = {
      "1": "overview", "2": "explore", "3": "suggestions",
      "4": "insights", "5": "history", "6": "export",
    };
    const handler = (e: KeyboardEvent) => {
      // Don't intercept when typing in inputs
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) return;
      if (e.metaKey || e.ctrlKey || e.altKey) return;
      if (e.key === "?" || (e.shiftKey && e.key === "/")) {
        setShowShortcuts((s) => !s);
        e.preventDefault();
        return;
      }
      if (e.key === "Escape") {
        setShowShortcuts(false);
        setExpandedTrialId(null);
        return;
      }
      const tab = tabKeys[e.key];
      if (tab) { setActiveTab(tab); e.preventDefault(); return; }

      // Power user shortcuts
      if (e.key === "b") {
        // Jump to best trial on history tab
        setActiveTab("history");
        setTimeout(() => {
          const btn = document.querySelector('.btn-accent') as HTMLButtonElement;
          if (btn) btn.click();
        }, 50);
        e.preventDefault();
        return;
      }
      if (e.key === "f" || e.key === "/") {
        // Focus filter input
        const el = document.querySelector('.history-search-input') as HTMLInputElement;
        if (el) { el.focus(); e.preventDefault(); }
        return;
      }
      if (e.key === "g") {
        // Generate suggestions
        setActiveTab("suggestions");
        setTimeout(() => {
          const btn = document.querySelector('.suggestions-generate-btn') as HTMLButtonElement;
          if (btn && !btn.disabled) btn.click();
        }, 50);
        e.preventDefault();
        return;
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, []);

  // Fetch diagnostics when overview tab is active
  useEffect(() => {
    if (!id || activeTab !== "overview") return;
    setLoadingDiag(true);
    fetchDiagnostics(id)
      .then(setDiagnostics)
      .catch(() => setDiagnostics(null))
      .finally(() => setLoadingDiag(false));
  }, [id, activeTab]);

  // Fetch importance when explore tab is active
  useEffect(() => {
    if (!id || activeTab !== "explore") return;
    setLoadingImportance(true);
    fetchImportance(id)
      .then(setImportance)
      .catch(() => setImportance(null))
      .finally(() => setLoadingImportance(false));
  }, [id, activeTab]);

  // Trial comparison toggle
  const toggleCompare = useCallback((trialId: string) => {
    setCompareSet(prev => {
      const next = new Set(prev);
      if (next.has(trialId)) { next.delete(trialId); }
      else if (next.size < 3) { next.add(trialId); }
      else { toast("Select up to 3 trials to compare"); }
      return next;
    });
  }, [toast]);

  // Goal management
  const addGoal = () => {
    const target = parseFloat(goalTarget);
    if (!goalName.trim() || isNaN(target)) return;
    setGoals(prev => [...prev, { id: `goal-${Date.now()}`, name: goalName.trim(), target, direction: goalDirection, created: Date.now() }]);
    setGoalName("");
    setGoalTarget("");
    setShowGoalModal(false);
    toast(`Goal "${goalName.trim()}" created`);
  };

  const removeGoal = (goalId: string) => {
    setGoals(prev => prev.filter(g => g.id !== goalId));
  };

  // Batch selection toggle
  const toggleSuggestionSelect = useCallback((idx: number) => {
    setSelectedSuggestions(prev => {
      const next = new Set(prev);
      if (next.has(idx)) next.delete(idx);
      else next.add(idx);
      return next;
    });
  }, []);

  const handleExportSelectedCSV = useCallback(() => {
    if (!suggestions || selectedSuggestions.size === 0) return;
    const selected = suggestions.suggestions.filter((_, i) => selectedSuggestions.has(i));
    const headers = Object.keys(selected[0]);
    const csvContent = [
      headers.join(","),
      ...selected.map((row) => headers.map((h) => row[h] ?? "").join(",")),
    ].join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `batch-${id?.slice(0, 8)}-${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast(`Exported ${selected.length} suggestions as CSV`);
  }, [suggestions, selectedSuggestions, id, toast]);

  // Trial tag management
  const toggleTrialTag = useCallback((trialId: string, tag: string) => {
    setTrialTags(prev => {
      const existing = prev[trialId] || [];
      const has = existing.includes(tag);
      return { ...prev, [trialId]: has ? existing.filter(t => t !== tag) : [...existing, tag] };
    });
  }, []);

  // Decision journal
  const addJournalEntry = useCallback(() => {
    if (!journalInput.trim()) return;
    setJournalEntries(prev => [{
      id: `j-${Date.now()}`,
      text: journalInput.trim(),
      iteration: campaign?.iteration ?? 0,
      timestamp: Date.now(),
    }, ...prev]);
    setJournalInput("");
    toast("Journal entry added");
  }, [journalInput, campaign?.iteration, toast]);

  const removeJournalEntry = useCallback((entryId: string) => {
    setJournalEntries(prev => prev.filter(e => e.id !== entryId));
  }, []);

  // Campaign summary clipboard export
  const copyCampaignSummary = useCallback(() => {
    if (!campaign) return;
    const obs = campaign.observations ?? [];
    const paramNames = obs.length > 0 ? Object.keys(obs[0].parameters) : [];
    const objNames = campaign.objective_names ?? ["objective"];
    const bestKpi = campaign.best_kpi;
    const bestObs = obs.find(o => {
      const kv = Object.values(o.kpi_values);
      return kv.length > 0 && Number(kv[0]) === bestKpi;
    });
    const lines = [
      `# ${campaign.name}`,
      "",
      `**Campaign ID:** ${id?.slice(0, 8) ?? "—"}`,
      `**Status:** ${campaign.status}  |  **Phase:** ${campaign.phases[campaign.phases.length - 1]?.name ?? "—"}`,
      `**Iterations:** ${campaign.iteration}  |  **Total Trials:** ${campaign.total_trials}`,
      "",
      "## Parameters",
      paramNames.map(p => `- \`${p}\``).join("\n"),
      "",
      "## Objectives",
      objNames.map(o => `- ${o} (${campaign.objective_directions?.[o] ?? "minimize"})`).join("\n"),
      "",
      "## Best Result",
      bestKpi != null ? `- **Value:** ${bestKpi.toFixed(4)}` : "- No results yet",
      bestObs ? `- **Iteration:** ${bestObs.iteration}` : "",
      bestObs ? `- **Parameters:** ${paramNames.map(p => `${p}=${Number(bestObs.parameters[p]).toFixed(3)}`).join(", ")}` : "",
      "",
      `*Generated by Optimization Copilot on ${new Date().toISOString().slice(0, 10)}*`,
    ];
    navigator.clipboard.writeText(lines.join("\n")).then(() => toast("Summary copied to clipboard"));
  }, [campaign, id, toast]);

  // Replay animation timer
  const replayMaxIdx = campaign?.kpi_history?.iterations?.length ?? 0;
  useEffect(() => {
    if (!replayPlaying || replayIdx === null || replayMaxIdx === 0) return;
    if (replayIdx >= replayMaxIdx - 1) { setReplayPlaying(false); return; }
    const timer = setTimeout(() => setReplayIdx(prev => (prev ?? 0) + 1), 120);
    return () => clearTimeout(timer);
  }, [replayPlaying, replayIdx, replayMaxIdx]);

  if (loading) {
    return (
      <div className="workspace-skeleton">
        <div className="skel-breadcrumb"><div className="skel-line" style={{ width: "180px" }} /></div>
        <div className="skel-header">
          <div className="skel-line" style={{ width: "280px", height: "24px" }} />
          <div className="skel-line" style={{ width: "220px", height: "14px", marginTop: "8px" }} />
        </div>
        <div className="skel-tabs">
          {[1,2,3,4,5,6].map((i) => <div key={i} className="skel-tab" />)}
        </div>
        <div className="skel-content">
          <div className="skel-stats">
            {[1,2,3,4].map((i) => <div key={i} className="skel-stat-card" />)}
          </div>
          <div className="skel-chart" />
          <div className="skel-chart" style={{ height: "120px" }} />
        </div>
        <style>{`
          .workspace-skeleton { padding: 0; background: var(--color-bg); min-height: calc(100vh - 56px); animation: fadeIn 0.2s ease; }
          .skel-breadcrumb { padding: 8px 24px; background: var(--color-surface); border-bottom: 1px solid var(--color-border-subtle); }
          .skel-header { padding: 24px 24px 16px; background: var(--color-surface); border-bottom: 1px solid var(--color-border); }
          .skel-tabs { display: flex; gap: 4px; padding: 12px 24px; background: var(--color-surface); border-bottom: 2px solid var(--color-border); }
          .skel-tab { width: 100px; height: 20px; background: var(--color-bg); border-radius: 6px; animation: pulse 1.5s ease-in-out infinite; }
          .skel-content { padding: 24px; }
          .skel-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px; }
          .skel-stat-card { height: 80px; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px; animation: pulse 1.5s ease-in-out infinite; }
          .skel-chart { height: 240px; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px; margin-bottom: 16px; animation: pulse 1.5s ease-in-out infinite; }
          .skel-line { height: 14px; background: var(--color-bg); border-radius: 6px; animation: pulse 1.5s ease-in-out infinite; }
        `}</style>
      </div>
    );
  }

  if (error || !campaign || !id) {
    return (
      <div className="page">
        <div className="error-banner">{error || "Campaign not found"}</div>
      </div>
    );
  }

  // Transform kpi_history → ConvergencePlot data format
  const convergenceData = campaign.kpi_history.iterations.map((iter, i) => {
    const values = campaign.kpi_history.values;
    const bestSoFar = Math.min(...values.slice(0, i + 1));
    return { iteration: iter, value: values[i], best: bestSoFar };
  });

  // Transform phases → ConvergencePlot phase format
  const phaseColors: Record<string, string> = {
    COLD_START: "#94a3b8",
    LEARNING: "#3b82f6",
    EXPLOITATION: "#22c55e",
    STAGNATION: "#eab308",
  };

  const convergencePhases = campaign.phases.map((p) => ({
    name: p.name,
    start: p.start,
    end: p.end,
    color: phaseColors[p.name] || "#94a3b8",
  }));

  const handleGenerateSuggestions = async () => {
    setLoadingSuggestions(true);
    try {
      const data = await fetchSuggestions(id, batchSize);
      setSuggestions(data);
      toast(`Generated ${data.suggestions.length} suggestions`);
    } catch (err) {
      console.error("Failed to generate suggestions:", err);
      toast("Failed to generate suggestions", "error");
    } finally {
      setLoadingSuggestions(false);
    }
  };

  const handleExportSuggestionsCSV = () => {
    if (!suggestions || suggestions.suggestions.length === 0) return;
    const rows = suggestions.suggestions;
    const headers = Object.keys(rows[0]);
    const csvContent = [
      headers.join(","),
      ...rows.map((row) => headers.map((h) => row[h] ?? "").join(",")),
    ].join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `suggestions-${id.slice(0, 8)}-${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast("Suggestions exported as CSV");
  };

  /** Smart advisor: analyze diagnostics and suggest next steps */
  const getAdvisorInsights = () => {
    if (!diagnostics) return [];
    const insights: Array<{
      type: "success" | "warning" | "action";
      title: string;
      description: string;
    }> = [];

    // Check plateau
    if (diagnostics.plateau_length > 30) {
      insights.push({
        type: "warning",
        title: "Optimization has plateaued",
        description: `No improvement for ${diagnostics.plateau_length} iterations. Consider expanding your search space, adding new parameters, or switching to a different optimization strategy.`,
      });
    } else if (diagnostics.plateau_length > 15) {
      insights.push({
        type: "action",
        title: "Approaching a plateau",
        description: `No improvement for ${diagnostics.plateau_length} iterations. The optimizer may be converging — consider generating a diverse batch to explore alternative regions.`,
      });
    }

    // Check exploration coverage
    if (diagnostics.exploration_coverage < 0.3) {
      insights.push({
        type: "action",
        title: "Low exploration coverage",
        description: `Only ${(diagnostics.exploration_coverage * 100).toFixed(0)}% of the parameter space has been explored. Consider running more exploration trials before exploiting.`,
      });
    } else if (diagnostics.exploration_coverage > 0.8) {
      insights.push({
        type: "success",
        title: "Good exploration coverage",
        description: `${(diagnostics.exploration_coverage * 100).toFixed(0)}% of the space explored. The optimizer has a solid understanding of the landscape.`,
      });
    }

    // Check noise
    if (diagnostics.noise_estimate > 0.2) {
      insights.push({
        type: "warning",
        title: "High measurement noise",
        description: "Consider running replicate experiments to improve model accuracy, or check for systematic errors in your measurement process.",
      });
    }

    // Check convergence trend
    if (diagnostics.convergence_trend > 0.01) {
      insights.push({
        type: "success",
        title: "Still improving",
        description: `Convergence trend is ${diagnostics.convergence_trend.toFixed(3)} — the optimization is still finding better solutions. Keep going!`,
      });
    }

    // Check signal to noise
    if (diagnostics.signal_to_noise_ratio < 3) {
      insights.push({
        type: "warning",
        title: "Low signal-to-noise ratio",
        description: "The optimization signal is weak relative to noise. Consider increasing sample sizes or reducing experimental variability.",
      });
    }

    // If all good, add encouragement
    if (insights.length === 0) {
      insights.push({
        type: "success",
        title: "Campaign looks healthy",
        description: "All diagnostics are within normal ranges. Continue generating suggestions and running experiments.",
      });
    }

    return insights;
  };

  const handleExport = async (format: "csv" | "json" | "xlsx") => {
    try {
      const blob = await fetchExport(id, format);
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `campaign-${id.slice(0, 8)}.${format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      toast(`Exported as ${format.toUpperCase()}`);
    } catch (err) {
      console.error("Export failed:", err);
      toast("Export failed", "error");
    }
  };

  const sugCount = suggestions?.suggestions?.length ?? 0;
  const trialCount = campaign.observations?.length ?? 0;

  const tabs = [
    { id: "overview", label: "Overview", icon: LayoutDashboard, badge: null as number | null },
    { id: "explore", label: "Explore", icon: Search, badge: null },
    { id: "suggestions", label: "Suggestions", icon: Beaker, badge: sugCount > 0 ? sugCount : null },
    { id: "insights", label: "Insights", icon: Lightbulb, badge: null },
    { id: "history", label: "History", icon: Clock, badge: trialCount > 0 ? trialCount : null },
    { id: "export", label: "Export", icon: Download, badge: null },
  ] as const;

  // Compute data quality warnings from diagnostics
  const dataWarnings: Array<{ id: string; level: "warning" | "error" | "info"; message: string }> = [];
  if (diagnostics) {
    if (diagnostics.failure_rate > 0.3) {
      dataWarnings.push({ id: "high-failure", level: "error", message: `High failure rate detected (${(diagnostics.failure_rate * 100).toFixed(0)}%). Check parameter bounds or experimental setup.` });
    } else if (diagnostics.failure_rate > 0.15) {
      dataWarnings.push({ id: "mod-failure", level: "warning", message: `Elevated failure rate (${(diagnostics.failure_rate * 100).toFixed(0)}%). Some experiments are failing — review constraints.` });
    }
    if (diagnostics.noise_estimate > 0.5) {
      dataWarnings.push({ id: "high-noise", level: "warning", message: `High measurement noise (${diagnostics.noise_estimate.toFixed(2)}). Consider adding replicates or smoothing.` });
    }
    if (diagnostics.signal_to_noise_ratio != null && diagnostics.signal_to_noise_ratio < 1.5) {
      dataWarnings.push({ id: "low-snr", level: "warning", message: `Low signal-to-noise ratio (${diagnostics.signal_to_noise_ratio.toFixed(2)}). Optimization trends may be unreliable.` });
    }
    if (diagnostics.plateau_length > 20) {
      dataWarnings.push({ id: "plateau", level: "info", message: `No improvement for ${diagnostics.plateau_length} iterations. The optimizer may have converged or needs a strategy change.` });
    }
  }
  if (campaign.observations && campaign.observations.length < 5) {
    dataWarnings.push({ id: "few-obs", level: "info", message: `Only ${campaign.observations.length} observation${campaign.observations.length === 1 ? "" : "s"} so far. Insights become more reliable after ~10 trials.` });
  }
  const visibleWarnings = dataWarnings.filter((w) => !dismissedWarnings.has(w.id));

  // Build trial data from real observations
  const trials = (campaign.observations ?? []).map((obs) => ({
    id: `trial-${obs.iteration}`,
    iteration: obs.iteration,
    parameters: obs.parameters,
    kpis: obs.kpi_values,
    status: "completed" as const,
  }));

  // Find best result
  const bestResult = trials.length > 0
    ? trials.reduce((best, trial) => {
        const bestVal = Object.values(best.kpis)[0] ?? 0;
        const trialVal = Object.values(trial.kpis)[0] ?? 0;
        return trialVal < bestVal ? trial : best; // minimize by default
      })
    : null;

  const addCheckpoint = () => {
    if (!campaign || !checkpointTitle.trim()) return;
    const cp = {
      id: `cp-${Date.now()}`,
      title: checkpointTitle.trim(),
      iteration: campaign.iteration,
      bestKpi: campaign.best_kpi ?? 0,
      phase: campaign.phases[campaign.phases.length - 1]?.name ?? "unknown",
      timestamp: Date.now(),
    };
    setCheckpoints(prev => [...prev, cp]);
    setCheckpointTitle("");
    setShowCheckpointModal(false);
    toast(`Checkpoint "${cp.title}" saved`);
  };

  const removeCheckpoint = (cpId: string) => {
    setCheckpoints(prev => prev.filter(cp => cp.id !== cpId));
  };

  // Compute diversity score for a suggestion (avg normalized distance to last 3 trials)
  const computeDiversityScore = (sug: Record<string, number>): number | null => {
    if (trials.length < 3 || !campaign.spec?.parameters) return null;
    const specs = campaign.spec.parameters.filter(s => s.type === "continuous" && s.lower != null && s.upper != null);
    if (specs.length === 0) return null;
    const recent = [...trials].sort((a, b) => b.iteration - a.iteration).slice(0, 3);
    let totalDist = 0;
    for (const trial of recent) {
      let sumSq = 0;
      for (const spec of specs) {
        const range = (spec.upper! - spec.lower!);
        if (range <= 0) continue;
        const normSug = ((sug[spec.name] ?? 0) - spec.lower!) / range;
        const normTrial = (Number(trial.parameters[spec.name]) - spec.lower!) / range;
        sumSq += (normSug - normTrial) ** 2;
      }
      totalDist += Math.sqrt(sumSq / specs.length);
    }
    return totalDist / recent.length;
  };

  const handleExportHistoryCSV = () => {
    if (trials.length === 0) return;
    const paramKeys = Object.keys(trials[0].parameters);
    const kpiKeys = Object.keys(trials[0].kpis);
    const headers = ["iteration", ...paramKeys, ...kpiKeys];
    const csvContent = [
      headers.join(","),
      ...trials.map((t) => [
        t.iteration,
        ...paramKeys.map((p) => t.parameters[p] ?? ""),
        ...kpiKeys.map((k) => t.kpis[k] ?? ""),
      ].join(",")),
    ].join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `history-${id.slice(0, 8)}-${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast(`History exported (${trials.length} trials)`);
  };

  const handleExportHistoryJSON = () => {
    if (trials.length === 0) return;
    const data = trials.map((t) => ({
      iteration: t.iteration,
      parameters: t.parameters,
      kpis: t.kpis,
      bookmarked: bookmarks.has(t.id),
      note: trialNotes[t.id] || undefined,
    }));
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `history-${id.slice(0, 8)}-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast(`History exported as JSON (${trials.length} trials)`);
  };

  return (
    <ErrorBoundary>
    <div className="workspace-container">
      <div className={`workspace-main ${chatOpen ? "chat-open" : ""}`}>
        {/* Breadcrumb */}
        <div className="workspace-breadcrumb">
          <Link to="/" className="breadcrumb-link"><Home size={13} /> Dashboard</Link>
          <ChevronRight size={12} className="breadcrumb-sep" />
          <span className="breadcrumb-current">{campaign.name}</span>
        </div>

        {/* Header */}
        <div className="workspace-header">
          <div>
            <h1>{campaign.name}</h1>
            <div className="workspace-meta">
              <span className="mono">ID: {id.slice(0, 8)}</span>
              <span className={`badge badge-${campaign.status}`}>
                {campaign.status}
              </span>
              <span>Iteration: {campaign.iteration}</span>
              <span>Trials: {campaign.total_trials}</span>
              {lastUpdated && (
                <span className="workspace-refresh-indicator" title="Auto-refreshes every 5s">
                  <RefreshCw size={11} className="refresh-spin" />
                  <span>Live</span>
                </span>
              )}
            </div>
          </div>
          <div className="workspace-actions">
            {campaign.status === "running" && (
              <>
                <button
                  className="btn btn-sm btn-secondary workspace-action-btn"
                  onClick={async () => { await pauseCampaign(id); refresh(); toast("Campaign paused"); }}
                  title="Pause campaign"
                >
                  <Pause size={14} /> Pause
                </button>
                <button
                  className="btn btn-sm btn-danger-outline workspace-action-btn"
                  onClick={async () => { await stopCampaign(id); refresh(); toast("Campaign stopped", "warning"); }}
                  title="Stop campaign"
                >
                  <Square size={14} /> Stop
                </button>
              </>
            )}
            {campaign.status === "paused" && (
              <button
                className="btn btn-sm btn-primary workspace-action-btn"
                onClick={async () => { await resumeCampaign(id); refresh(); toast("Campaign resumed"); }}
                title="Resume campaign"
              >
                <Play size={14} /> Resume
              </button>
            )}
          </div>
        </div>

        {/* Tabs */}
        <div className="workspace-tabs">
          {tabs.map((tab, idx) => (
            <button
              key={tab.id}
              className={`workspace-tab ${activeTab === tab.id ? "active" : ""}`}
              onClick={() => setActiveTab(tab.id)}
              title={`${tab.label} (${idx + 1})`}
            >
              <tab.icon size={16} />
              <span>{tab.label}</span>
              {tab.badge !== null && (
                <span className="tab-badge">{tab.badge > 99 ? "99+" : tab.badge}</span>
              )}
              <kbd className="tab-kbd">{idx + 1}</kbd>
            </button>
          ))}
        </div>

        {/* Data Quality Warnings */}
        {visibleWarnings.length > 0 && (
          <div className="quality-warnings">
            {visibleWarnings.map((w) => (
              <div key={w.id} className={`quality-warning quality-warning-${w.level}`}>
                <span className="quality-warning-icon">
                  {w.level === "error" ? <AlertTriangle size={14} /> : w.level === "warning" ? <AlertTriangle size={14} /> : <Info size={14} />}
                </span>
                <span className="quality-warning-msg">{w.message}</span>
                <button
                  className="quality-warning-dismiss"
                  onClick={() => setDismissedWarnings((prev) => new Set(prev).add(w.id))}
                  title="Dismiss"
                >
                  ×
                </button>
              </div>
            ))}
          </div>
        )}

        {/* Tab Content */}
        <div className="workspace-content">
          {activeTab === "overview" && (
            <div className="tab-panel">
              <div className="overview-actions-row">
                <button className="btn btn-sm btn-secondary" onClick={copyCampaignSummary} title="Copy campaign summary as Markdown">
                  <Clipboard size={13} /> Copy Summary
                </button>
              </div>
              <div className="stats-row">
                <div className="stat-card">
                  <div className="stat-label">Iteration</div>
                  <div className="stat-value">{campaign.iteration}</div>
                </div>
                <div className="stat-card">
                  <div className="stat-label">Total Trials</div>
                  <div className="stat-value">{campaign.total_trials}</div>
                </div>
                <div className="stat-card">
                  <div className="stat-label">Best KPI</div>
                  <div className="stat-value mono">
                    {campaign.best_kpi?.toFixed(4) ?? "—"}
                  </div>
                </div>
                <div className="stat-card">
                  <div className="stat-label">Phase</div>
                  <div className="stat-value">
                    {campaign.phases[campaign.phases.length - 1]?.name || "—"}
                  </div>
                </div>
                {/* Iterations since last improvement */}
                {convergenceData.length > 2 && (() => {
                  const bestVal = Math.min(...convergenceData.map((d) => d.best));
                  const lastImprovementIdx = convergenceData.reduce((acc, d, i) => d.best === bestVal ? i : acc, 0);
                  const itersSinceImprovement = convergenceData.length - 1 - lastImprovementIdx;
                  const isStale = itersSinceImprovement > 30;
                  return (
                    <div className={`stat-card ${isStale ? "stat-card-warning" : ""}`}>
                      <div className="stat-label">
                        <TrendingDown size={12} style={{ marginRight: 4, verticalAlign: "middle" }} />
                        Since Improvement
                      </div>
                      <div className="stat-value">
                        {itersSinceImprovement} <span style={{ fontSize: "0.7rem", fontWeight: 400, color: "var(--color-text-muted)" }}>iter</span>
                      </div>
                    </div>
                  );
                })()}
                <div className="stat-card">
                  <div className="stat-label">
                    <Hash size={12} style={{ marginRight: 4, verticalAlign: "middle" }} />
                    Unique Configs
                  </div>
                  <div className="stat-value">
                    {(() => {
                      const seen = new Set(trials.map((t) => JSON.stringify(t.parameters)));
                      return seen.size;
                    })()}
                  </div>
                </div>
              </div>

              {/* Best Result Highlight */}
              {bestResult && (
                <div className="best-result-card">
                  <div className="best-result-header">
                    <div className="best-result-badge">
                      <CheckCircle size={16} /> Best Result Found
                    </div>
                    <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
                      <span className="best-result-iter">Iteration {bestResult.iteration}</span>
                      <button
                        className="btn btn-sm btn-secondary best-result-copy"
                        onClick={() => handleCopyBest(bestResult.parameters)}
                        title="Copy parameters to clipboard"
                      >
                        {copied ? <Check size={13} /> : <Copy size={13} />}
                        {copied ? "Copied" : "Copy"}
                      </button>
                    </div>
                  </div>
                  <div className="best-result-kpi">
                    {Object.entries(bestResult.kpis).map(([name, value]) => (
                      <div key={name} className="best-result-kpi-item">
                        <span className="best-result-kpi-label">{name}</span>
                        <span className="best-result-kpi-value mono">{typeof value === 'number' ? value.toFixed(4) : String(value)}</span>
                      </div>
                    ))}
                  </div>
                  <div className="best-result-params">
                    {Object.entries(bestResult.parameters).map(([name, value]) => (
                      <div key={name} className="best-result-param">
                        <span className="best-result-param-name">{name}</span>
                        <span className="best-result-param-value mono">{typeof value === 'number' ? value.toFixed(3) : String(value)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Milestone Timeline */}
              {trials.length > 0 && (() => {
                const milestones: Array<{ icon: React.ReactNode; label: string; detail: string; iteration: number; color: string }> = [];
                milestones.push({ icon: <Rocket size={14} />, label: "Campaign Started", detail: `${campaign.phases[0]?.name ?? "init"} phase`, iteration: 0, color: "var(--color-gray)" });
                if (trials.length >= 1) {
                  const firstTrial = trials.reduce((min, t) => t.iteration < min.iteration ? t : min, trials[0]);
                  milestones.push({ icon: <FlaskConical size={14} />, label: "First Trial", detail: `Iteration ${firstTrial.iteration}`, iteration: firstTrial.iteration, color: "var(--color-blue)" });
                }
                if (bestResult) {
                  milestones.push({ icon: <Trophy size={14} />, label: "Best Result", detail: `Iter ${bestResult.iteration} — ${Object.values(bestResult.kpis)[0]?.toFixed(4) ?? ""}`, iteration: bestResult.iteration, color: "var(--color-green)" });
                }
                if (diagnostics && diagnostics.plateau_length > 15) {
                  const plateauStart = campaign.iteration - diagnostics.plateau_length;
                  milestones.push({ icon: <Flag size={14} />, label: "Plateau Detected", detail: `Since iteration ${plateauStart}`, iteration: plateauStart, color: "var(--color-yellow)" });
                }
                if (campaign.status === "completed") {
                  milestones.push({ icon: <Target size={14} />, label: "Completed", detail: `${campaign.iteration} iterations`, iteration: campaign.iteration, color: "var(--color-green)" });
                } else {
                  milestones.push({ icon: <Target size={14} />, label: "Current", detail: `Iteration ${campaign.iteration}`, iteration: campaign.iteration, color: "var(--color-primary)" });
                }
                milestones.sort((a, b) => a.iteration - b.iteration);
                return (
                  <div className="milestone-timeline">
                    <div className="milestone-line" />
                    {milestones.map((m, i) => (
                      <div key={i} className="milestone-item">
                        <div className="milestone-dot" style={{ background: m.color, borderColor: m.color }}>{m.icon}</div>
                        <div className="milestone-content">
                          <div className="milestone-label">{m.label}</div>
                          <div className="milestone-detail">{m.detail}</div>
                        </div>
                      </div>
                    ))}
                  </div>
                );
              })()}

              {/* Checkpoint Controls */}
              <div className="checkpoint-controls">
                <button className="btn btn-sm btn-secondary" onClick={() => setShowCheckpointModal(true)}>
                  <Flag size={13} /> Create Checkpoint
                </button>
                {checkpoints.length > 0 && (
                  <span className="checkpoint-count">{checkpoints.length} checkpoint{checkpoints.length !== 1 ? "s" : ""}</span>
                )}
              </div>

              {/* Checkpoint Modal */}
              {showCheckpointModal && (
                <div className="shortcut-overlay" onClick={() => setShowCheckpointModal(false)}>
                  <div className="shortcut-modal checkpoint-modal" onClick={(e) => e.stopPropagation()}>
                    <div className="shortcut-modal-header">
                      <h3>Create Checkpoint</h3>
                      <button className="shortcut-close" onClick={() => setShowCheckpointModal(false)}>
                        <span>&times;</span>
                      </button>
                    </div>
                    <p className="checkpoint-modal-desc">
                      Capture the current campaign state as a checkpoint for future reference.
                    </p>
                    <div className="checkpoint-modal-snapshot">
                      <div className="checkpoint-snapshot-row">
                        <span>Iteration</span><span className="mono">{campaign.iteration}</span>
                      </div>
                      <div className="checkpoint-snapshot-row">
                        <span>Best KPI</span><span className="mono">{campaign.best_kpi?.toFixed(4) ?? "—"}</span>
                      </div>
                      <div className="checkpoint-snapshot-row">
                        <span>Phase</span><span>{campaign.phases[campaign.phases.length - 1]?.name ?? "—"}</span>
                      </div>
                    </div>
                    <input
                      type="text"
                      className="history-note-input checkpoint-title-input"
                      placeholder="Checkpoint name (e.g., 'Tightened bounds on X')"
                      value={checkpointTitle}
                      onChange={(e) => setCheckpointTitle(e.target.value)}
                      onKeyDown={(e) => { if (e.key === "Enter" && checkpointTitle.trim()) addCheckpoint(); }}
                      autoFocus
                    />
                    <div className="checkpoint-modal-actions">
                      <button className="btn btn-sm btn-secondary" onClick={() => setShowCheckpointModal(false)}>Cancel</button>
                      <button className="btn btn-sm btn-primary" onClick={addCheckpoint} disabled={!checkpointTitle.trim()}>
                        <Flag size={13} /> Save Checkpoint
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Saved Checkpoints List */}
              {checkpoints.length > 0 && (
                <div className="checkpoint-list">
                  {checkpoints.map((cp) => (
                    <div key={cp.id} className="checkpoint-item">
                      <div className="checkpoint-dot" />
                      <div className="checkpoint-info">
                        <span className="checkpoint-title">{cp.title}</span>
                        <span className="checkpoint-meta">
                          Iter {cp.iteration} &middot; Best {cp.bestKpi.toFixed(4)} &middot; {cp.phase} &middot; {new Date(cp.timestamp).toLocaleDateString()}
                        </span>
                      </div>
                      <button className="checkpoint-remove" onClick={() => removeCheckpoint(cp.id)} title="Remove checkpoint">&times;</button>
                    </div>
                  ))}
                </div>
              )}

              {/* Goal Tracker */}
              <div className="card goal-tracker-card">
                <div className="goal-tracker-header">
                  <div className="goal-tracker-header-left">
                    <Crosshair size={16} />
                    <h2 style={{ margin: 0 }}>Optimization Goals</h2>
                  </div>
                  <button className="btn btn-sm btn-secondary" onClick={() => setShowGoalModal(true)}>
                    + Add Goal
                  </button>
                </div>
                {goals.length === 0 ? (
                  <p className="goal-empty">Define target KPI values to track progress toward your research objectives.</p>
                ) : (
                  <div className="goal-list">
                    {goals.map(goal => {
                      const currentBest = campaign.best_kpi ?? 0;
                      const isMinimize = goal.direction === "minimize";
                      const progress = isMinimize
                        ? currentBest <= goal.target ? 100 : Math.max(0, Math.min(100, (1 - (currentBest - goal.target) / Math.abs(goal.target || 1)) * 100))
                        : currentBest >= goal.target ? 100 : Math.max(0, Math.min(100, (currentBest / Math.abs(goal.target || 1)) * 100));
                      const reached = (isMinimize && currentBest <= goal.target) || (!isMinimize && currentBest >= goal.target);
                      const velocity = diagnostics?.improvement_velocity ?? 0;
                      const status = reached ? "reached" : velocity < -0.01 ? "on-track" : velocity < 0 ? "at-risk" : "behind";
                      const remaining = !reached && velocity < -0.001
                        ? Math.ceil(Math.abs(currentBest - goal.target) / Math.abs(velocity))
                        : null;
                      return (
                        <div key={goal.id} className={`goal-item goal-item-${status}`}>
                          <div className="goal-item-top">
                            <span className="goal-item-name">{goal.name}</span>
                            <span className={`goal-status-badge goal-status-${status}`}>
                              {status === "reached" ? "Reached" : status === "on-track" ? "On Track" : status === "at-risk" ? "At Risk" : "Behind"}
                            </span>
                            <button className="goal-remove" onClick={() => removeGoal(goal.id)} title="Remove goal">&times;</button>
                          </div>
                          <div className="goal-progress-row">
                            <span className="mono goal-current">{currentBest.toFixed(4)}</span>
                            <div className="goal-progress-bar">
                              <div className="goal-progress-fill" style={{ width: `${Math.min(progress, 100)}%` }} />
                            </div>
                            <span className="mono goal-target-val">{goal.target.toFixed(4)}</span>
                          </div>
                          <div className="goal-meta-row">
                            <span>{isMinimize ? "minimize" : "maximize"} to {goal.target.toFixed(4)}</span>
                            {remaining && <span className="goal-eta">~{remaining} iter remaining</span>}
                            {reached && <span className="goal-eta" style={{ color: "var(--color-green)" }}>Target achieved!</span>}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>

              {/* Goal Modal */}
              {showGoalModal && (
                <div className="shortcut-overlay" onClick={() => setShowGoalModal(false)}>
                  <div className="shortcut-modal checkpoint-modal" onClick={(e) => e.stopPropagation()}>
                    <div className="shortcut-modal-header">
                      <h3>Add Optimization Goal</h3>
                      <button className="shortcut-close" onClick={() => setShowGoalModal(false)}><span>&times;</span></button>
                    </div>
                    <p className="checkpoint-modal-desc">
                      Set a target KPI value. Progress will be tracked relative to your current best result.
                    </p>
                    <div className="goal-modal-fields">
                      <label className="goal-modal-label">
                        Goal name
                        <input
                          type="text"
                          className="history-note-input"
                          placeholder="e.g., Reach ≤ -0.6 objective"
                          value={goalName}
                          onChange={(e) => setGoalName(e.target.value)}
                          autoFocus
                        />
                      </label>
                      <div className="goal-modal-row">
                        <label className="goal-modal-label" style={{ flex: 1 }}>
                          Target value
                          <input
                            type="number"
                            className="history-note-input"
                            placeholder="-0.6"
                            step="any"
                            value={goalTarget}
                            onChange={(e) => setGoalTarget(e.target.value)}
                          />
                        </label>
                        <label className="goal-modal-label">
                          Direction
                          <select
                            className="suggestions-batch-select"
                            value={goalDirection}
                            onChange={(e) => setGoalDirection(e.target.value as "minimize" | "maximize")}
                          >
                            <option value="minimize">Minimize</option>
                            <option value="maximize">Maximize</option>
                          </select>
                        </label>
                      </div>
                    </div>
                    <div className="checkpoint-modal-actions">
                      <button className="btn btn-sm btn-secondary" onClick={() => setShowGoalModal(false)}>Cancel</button>
                      <button className="btn btn-sm btn-primary" onClick={addGoal} disabled={!goalName.trim() || !goalTarget}>
                        <Crosshair size={13} /> Create Goal
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Parameter Variance Sentinel */}
              {trials.length >= 5 && campaign.spec?.parameters && (() => {
                const specs = campaign.spec.parameters.filter(s => s.type === "continuous" && s.lower != null && s.upper != null);
                if (specs.length === 0) return null;
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const recentN = Math.min(15, chrono.length);
                const recent = chrono.slice(-recentN);

                const paramStats = specs.map(s => {
                  const vals = recent.map(t => Number(t.parameters[s.name]) || 0);
                  const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                  const variance = vals.reduce((a, v) => a + (v - mean) ** 2, 0) / vals.length;
                  const range = (s.upper! - s.lower!);
                  const normalizedStd = range > 0 ? Math.sqrt(variance) / range : 0;
                  const isCollapsed = normalizedStd < 0.05;
                  return { name: s.name, normalizedStd, isCollapsed, vals: chrono.slice(-15).map(t => Number(t.parameters[s.name]) || 0), lower: s.lower!, upper: s.upper! };
                });

                const collapsedCount = paramStats.filter(p => p.isCollapsed).length;

                return (
                  <div className={`card sentinel-card ${collapsedCount > 0 ? "sentinel-alert" : ""}`}>
                    <div className="sentinel-header" onClick={() => setSentinelOpen(s => !s)} style={{ cursor: "pointer" }}>
                      <div className="sentinel-header-left">
                        <Activity size={16} />
                        <h2 style={{ margin: 0 }}>Parameter Variance Sentinel</h2>
                        {collapsedCount > 0 && (
                          <span className="sentinel-alert-badge">{collapsedCount} collapsed</span>
                        )}
                      </div>
                      {sentinelOpen ? <ArrowUp size={14} /> : <ArrowDown size={14} />}
                    </div>
                    {sentinelOpen && (
                      <div className="sentinel-body">
                        <p className="sentinel-desc">
                          Monitoring recent {recentN}-trial variance for each parameter. Low variance may indicate parameter collapse.
                        </p>
                        {paramStats.map(p => {
                          const sparkW = 56, sparkH = 18, pad = 1;
                          const min = Math.min(...p.vals);
                          const max = Math.max(...p.vals);
                          const range = max - min || 1;
                          const points = p.vals.map((v, i) => ({
                            x: pad + (i / Math.max(1, p.vals.length - 1)) * (sparkW - 2 * pad),
                            y: pad + (1 - (v - min) / range) * (sparkH - 2 * pad),
                          }));
                          const d = points.map((pt, i) => `${i === 0 ? "M" : "L"}${pt.x.toFixed(1)},${pt.y.toFixed(1)}`).join(" ");
                          const sparkColor = p.isCollapsed ? "#ef4444" : p.normalizedStd < 0.15 ? "#eab308" : "#22c55e";
                          return (
                            <div key={p.name} className={`sentinel-row ${p.isCollapsed ? "sentinel-row-alert" : ""}`}>
                              <span className="sentinel-param-name mono">{p.name}</span>
                              <svg width={sparkW} height={sparkH} viewBox={`0 0 ${sparkW} ${sparkH}`} style={{ flexShrink: 0 }}>
                                <path d={d} fill="none" stroke={sparkColor} strokeWidth="1.3" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                              <div className="sentinel-variance-bar">
                                <div className="sentinel-variance-fill" style={{ width: `${Math.min(p.normalizedStd * 100 / 0.5, 100)}%`, background: sparkColor }} />
                              </div>
                              <span className="sentinel-std mono" style={{ color: sparkColor }}>
                                {(p.normalizedStd * 100).toFixed(1)}%
                              </span>
                              {p.isCollapsed && <span className="sentinel-warn-tag">Collapsed</span>}
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                );
              })()}

              <div className="card">
                <div className="convergence-header">
                  <h2>Convergence</h2>
                  {convergenceData.length > 5 && (
                    <div className="replay-controls">
                      {replayIdx !== null && (
                        <span className="replay-counter">
                          {replayIdx + 1} / {convergenceData.length}
                        </span>
                      )}
                      <button
                        className="btn btn-sm btn-secondary"
                        onClick={() => {
                          if (replayPlaying) {
                            setReplayPlaying(false);
                          } else {
                            setReplayIdx(0);
                            setReplayPlaying(true);
                          }
                        }}
                        title={replayPlaying ? "Pause replay" : "Replay optimization journey"}
                      >
                        {replayPlaying ? <><Pause size={12} /> Pause</> : <><RotateCcw size={12} /> Replay</>}
                      </button>
                      {replayIdx !== null && !replayPlaying && (
                        <button className="btn btn-sm btn-secondary" onClick={() => { setReplayIdx(null); setReplayPlaying(false); }} title="Reset">
                          <X size={12} />
                        </button>
                      )}
                    </div>
                  )}
                </div>
                {convergenceData.length > 0 ? (
                  <>
                    <RealConvergencePlot
                      data={replayIdx !== null ? convergenceData.slice(0, replayIdx + 1) : convergenceData}
                      objectiveName="Objective"
                      direction="minimize"
                      phases={convergencePhases}
                    />
                    {replayIdx !== null && replayIdx < convergenceData.length && (
                      <div className="replay-info">
                        <span className="replay-dot" />
                        Iteration {convergenceData[replayIdx]?.iteration ?? replayIdx}
                        {convergenceData[replayIdx]?.best !== undefined && (
                          <span className="replay-best"> — Best: {convergenceData[replayIdx].best.toFixed(4)}</span>
                        )}
                      </div>
                    )}
                  </>
                ) : (
                  <p className="empty-state">No convergence data yet.</p>
                )}
              </div>

              <div className="card">
                <h2>Diagnostics</h2>
                {loadingDiag ? (
                  <div className="loading">Loading diagnostics...</div>
                ) : diagnostics ? (
                  (() => {
                    const trendData: Record<string, number[]> = {};
                    if (trials.length >= 5) {
                      const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                      const windowSize = Math.max(5, Math.floor(chrono.length / 10));
                      const nPoints = Math.min(12, Math.ceil(chrono.length / windowSize));
                      // Rolling best KPI
                      const bestKpiTrend: number[] = [];
                      let runningBest = Infinity;
                      for (let i = 0; i < nPoints; i++) {
                        const end = Math.min(chrono.length, (i + 1) * windowSize);
                        for (let j = i * windowSize; j < end; j++) {
                          const val = Number(Object.values(chrono[j].kpis)[0]) || 0;
                          if (val < runningBest) runningBest = val;
                        }
                        bestKpiTrend.push(runningBest);
                      }
                      trendData.best_kpi_value = bestKpiTrend;
                      // Rolling failure rate (proportion of "bad" trials per window — use high KPI as proxy)
                      const kpiVals = chrono.map((t) => Number(Object.values(t.kpis)[0]) || 0);
                      const median = [...kpiVals].sort((a, b) => a - b)[Math.floor(kpiVals.length / 2)];
                      const failTrend: number[] = [];
                      for (let i = 0; i < nPoints; i++) {
                        const start = i * windowSize;
                        const end = Math.min(chrono.length, (i + 1) * windowSize);
                        const slice = kpiVals.slice(start, end);
                        const failRate = slice.filter((v) => v > median * 1.5).length / slice.length;
                        failTrend.push(failRate);
                      }
                      trendData.failure_rate = failTrend;
                      // Rolling improvement velocity
                      const velTrend: number[] = [];
                      for (let i = 0; i < nPoints; i++) {
                        const start = i * windowSize;
                        const end = Math.min(chrono.length, (i + 1) * windowSize);
                        const slice = kpiVals.slice(start, end);
                        if (slice.length >= 2) {
                          velTrend.push((slice[slice.length - 1] - slice[0]) / slice.length);
                        } else {
                          velTrend.push(0);
                        }
                      }
                      trendData.improvement_velocity = velTrend;
                    }
                    return (
                      <RealDiagnosticCards
                        diagnostics={{
                          convergence_trend: diagnostics.convergence_trend,
                          exploration_coverage: diagnostics.exploration_coverage,
                          failure_rate: diagnostics.failure_rate,
                          noise_estimate: diagnostics.noise_estimate,
                          plateau_length: diagnostics.plateau_length,
                          signal_to_noise: diagnostics.signal_to_noise_ratio,
                          best_kpi_value: diagnostics.best_kpi_value,
                          improvement_velocity: diagnostics.improvement_velocity,
                        }}
                        tooltips={DIAGNOSTIC_TOOLTIPS}
                        trendData={trendData}
                      />
                    );
                  })()
                ) : (
                  <p className="empty-state">
                    Diagnostics unavailable. Start a campaign to see health metrics.
                  </p>
                )}
              </div>

              <div className="card">
                <h2>Phase Timeline</h2>
                <PhaseTimeline phases={campaign.phases} />
              </div>

              {/* Experiment Cost / Time Tracker */}
              {convergenceData.length >= 3 && (() => {
                const totalIter = campaign.iteration ?? convergenceData.length;
                const startTime = campaign.created_at ? new Date(campaign.created_at).getTime() : 0;
                const elapsed = startTime ? Date.now() - startTime : 0;
                const elapsedHrs = elapsed / (1000 * 60 * 60);
                const avgPerIter = totalIter > 0 ? elapsed / totalIter : 0;
                const avgPerIterMin = avgPerIter / (1000 * 60);
                // Estimate remaining: compute improvement velocity
                const recent = convergenceData.slice(-10);
                const bestSoFar = Math.min(...convergenceData.map(d => d.best));
                const recentBest = Math.min(...recent.map(d => d.best));
                const firstBest = convergenceData[0]?.best ?? 0;
                const totalImprovement = firstBest - bestSoFar;
                const recentImprovement = recent.length > 1 ? (recent[0]?.best ?? 0) - recentBest : 0;
                const velocitySlowing = recentImprovement < totalImprovement * 0.02;
                const budgetPct = Math.min((totalIter / Math.max(totalIter + 20, 100)) * 100, 100);
                const efficiencyScore = totalImprovement !== 0 && totalIter > 0 ? Math.abs(totalImprovement) / totalIter : 0;

                return (
                  <div className="card cost-tracker-card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "12px" }}>
                      <Timer size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Experiment Tracker</h2>
                    </div>
                    <div className="cost-tracker-grid">
                      <div className="cost-tracker-item">
                        <span className="cost-tracker-label">Total Iterations</span>
                        <span className="cost-tracker-value">{totalIter}</span>
                      </div>
                      <div className="cost-tracker-item">
                        <span className="cost-tracker-label">Elapsed Time</span>
                        <span className="cost-tracker-value">{elapsedHrs < 1 ? `${(elapsedHrs * 60).toFixed(0)}m` : `${elapsedHrs.toFixed(1)}h`}</span>
                      </div>
                      <div className="cost-tracker-item">
                        <span className="cost-tracker-label">Avg per Iteration</span>
                        <span className="cost-tracker-value">{avgPerIterMin < 1 ? `${(avgPerIterMin * 60).toFixed(0)}s` : `${avgPerIterMin.toFixed(1)}m`}</span>
                      </div>
                      <div className="cost-tracker-item">
                        <span className="cost-tracker-label">Efficiency</span>
                        <span className="cost-tracker-value">{efficiencyScore.toFixed(4)}/iter</span>
                      </div>
                    </div>
                    <div className="cost-tracker-bar-section">
                      <div className="cost-tracker-bar-header">
                        <span>Optimization Progress</span>
                        <span className="mono" style={{ fontSize: "0.78rem" }}>{budgetPct.toFixed(0)}%</span>
                      </div>
                      <div className="cost-tracker-bar">
                        <div className="cost-tracker-bar-fill" style={{ width: `${budgetPct}%`, background: velocitySlowing ? "var(--color-yellow, #eab308)" : "var(--color-primary)" }} />
                      </div>
                      {velocitySlowing && (
                        <div className="cost-tracker-warn">
                          <AlertTriangle size={12} /> Improvement velocity is slowing — consider changing strategy
                        </div>
                      )}
                    </div>
                  </div>
                );
              })()}

              {/* Convergence Confidence Band */}
              {convergenceData.length >= 10 && (() => {
                const W = 460, H = 140, padL = 50, padR = 12, padT = 10, padB = 28;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const bestVals = convergenceData.map(d => d.best);
                const trialVals = convergenceData.map(d => d.value);
                const minY = Math.min(...bestVals);
                const maxY = Math.max(...trialVals, ...bestVals);
                const yRange = maxY - minY || 1;
                const scaleX = (i: number) => padL + (i / (convergenceData.length - 1)) * plotW;
                const scaleY = (v: number) => padT + (1 - (v - minY) / yRange) * plotH;

                // Rolling window confidence band (std dev around best-so-far)
                const windowSize = Math.max(5, Math.floor(convergenceData.length / 15));
                const upper: string[] = [];
                const lower: string[] = [];
                for (let i = 0; i < convergenceData.length; i++) {
                  const start = Math.max(0, i - windowSize);
                  const end = Math.min(convergenceData.length, i + windowSize + 1);
                  const windowVals = trialVals.slice(start, end);
                  const mean = windowVals.reduce((a, b) => a + b, 0) / windowVals.length;
                  const variance = windowVals.reduce((a, b) => a + (b - mean) ** 2, 0) / windowVals.length;
                  const std = Math.sqrt(variance);
                  const best = bestVals[i];
                  upper.push(`${scaleX(i).toFixed(1)},${scaleY(best + std).toFixed(1)}`);
                  lower.push(`${scaleX(i).toFixed(1)},${scaleY(best - std).toFixed(1)}`);
                }
                const bandPath = `M${upper.join(" L")} L${lower.reverse().join(" L")} Z`;
                const bestPath = bestVals.map((v, i) => `${i === 0 ? "M" : "L"}${scaleX(i).toFixed(1)},${scaleY(v).toFixed(1)}`).join(" ");

                // Confidence narrowing metric
                const earlyStd = (() => {
                  const earlyW = trialVals.slice(0, Math.min(windowSize * 3, Math.floor(convergenceData.length / 3)));
                  const m = earlyW.reduce((a, b) => a + b, 0) / earlyW.length;
                  return Math.sqrt(earlyW.reduce((a, b) => a + (b - m) ** 2, 0) / earlyW.length);
                })();
                const lateStd = (() => {
                  const lateW = trialVals.slice(Math.max(0, convergenceData.length - windowSize * 3));
                  const m = lateW.reduce((a, b) => a + b, 0) / lateW.length;
                  return Math.sqrt(lateW.reduce((a, b) => a + (b - m) ** 2, 0) / lateW.length);
                })();
                const narrowing = earlyStd > 0 ? ((earlyStd - lateStd) / earlyStd * 100).toFixed(0) : "0";
                const isConverging = lateStd < earlyStd;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Eye size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Convergence Confidence</h2>
                      <span className={`findings-badge findings-badge-${isConverging ? "success" : "warning"}`} style={{ marginLeft: "auto" }}>
                        {isConverging ? `${narrowing}% narrower` : "Widening"}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Shaded band shows rolling uncertainty (±1 std dev). Narrowing bands indicate the model is converging.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Grid lines */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <line key={f} x1={padL} y1={padT + f * plotH} x2={padL + plotW} y2={padT + f * plotH}
                          stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                      ))}
                      {/* Confidence band */}
                      <path d={bandPath} fill="var(--color-primary)" opacity="0.12" />
                      {/* Best-so-far line */}
                      <path d={bestPath} fill="none" stroke="var(--color-primary)" strokeWidth="2" strokeLinecap="round" />
                      {/* Trial scatter */}
                      {convergenceData.map((d, i) => (
                        <circle key={i} cx={scaleX(i)} cy={scaleY(d.value)} r="1.5" fill="var(--color-text-muted)" opacity="0.3" />
                      ))}
                      {/* Y axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(minY + f * yRange).toFixed(3)}
                        </text>
                      ))}
                      {/* X axis */}
                      <text x={padL} y={H - 4} textAnchor="start" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">0</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{convergenceData.length}</text>
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">Iteration</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: "var(--color-primary)", borderRadius: 2, marginRight: 4, verticalAlign: "middle" }} />Best So Far</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "var(--color-primary)", opacity: 0.15, borderRadius: 2, marginRight: 4, verticalAlign: "middle" }} />±1σ Band</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 5, height: 5, borderRadius: "50%", background: "var(--color-text-muted)", opacity: 0.4, marginRight: 4, verticalAlign: "middle" }} />Trials</span>
                    </div>
                  </div>
                );
              })()}

              {/* Objective Distribution by Window */}
              {trials.length >= 15 && (() => {
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const objKey = Object.keys(chrono[0].kpis)[0];
                const vals = chrono.map(t => Number(t.kpis[objKey]) || 0);
                const n = vals.length;

                // Split into 3 equal windows
                const windowSize = Math.ceil(n / 3);
                const windows = [
                  { label: "Early", sublabel: `1–${Math.min(windowSize, n)}`, vals: vals.slice(0, windowSize), color: "rgba(239,68,68,0.5)" },
                  { label: "Mid", sublabel: `${windowSize + 1}–${Math.min(windowSize * 2, n)}`, vals: vals.slice(windowSize, windowSize * 2), color: "rgba(234,179,8,0.5)" },
                  { label: "Late", sublabel: `${windowSize * 2 + 1}–${n}`, vals: vals.slice(windowSize * 2), color: "rgba(34,197,94,0.5)" },
                ].filter(w => w.vals.length > 0);

                // Compute stats per window
                const windowStats = windows.map(w => {
                  const sorted = [...w.vals].sort((a, b) => a - b);
                  return {
                    ...w,
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    q1: sorted[Math.floor(sorted.length * 0.25)],
                    median: sorted[Math.floor(sorted.length * 0.5)],
                    q3: sorted[Math.floor(sorted.length * 0.75)],
                    mean: w.vals.reduce((a, b) => a + b, 0) / w.vals.length,
                  };
                });

                const allMin = Math.min(...windowStats.map(w => w.min));
                const allMax = Math.max(...windowStats.map(w => w.max));
                const valRange = allMax - allMin || 1;

                // Detect trend: compare early vs late median
                const earlyMed = windowStats[0]?.median ?? 0;
                const lateMed = windowStats[windowStats.length - 1]?.median ?? 0;
                const improving = lateMed < earlyMed;
                const improvePct = earlyMed !== 0 ? (((earlyMed - lateMed) / Math.abs(earlyMed)) * 100).toFixed(1) : "0";

                const W = 460, H = 140, padL = 50, padR = 12, padT = 10, padB = 28;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const boxWidth = Math.min(60, plotW / (windows.length * 2));
                const scaleY = (v: number) => padT + (1 - (v - allMin) / valRange) * plotH;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <BoxSelect size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Distribution by Window</h2>
                      <span className={`findings-badge findings-badge-${improving ? "success" : "warning"}`} style={{ marginLeft: "auto" }}>
                        {improving ? `${improvePct}% shift` : "Not improving"}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Box plots of {objKey} for early, mid, and late trial windows. A leftward/downward shift indicates improving outcomes.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Horizontal grid lines */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <line key={f} x1={padL} y1={padT + f * plotH} x2={padL + plotW} y2={padT + f * plotH}
                          stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                      ))}
                      {/* Y-axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(allMin + f * valRange).toFixed(3)}
                        </text>
                      ))}
                      {/* Box plots */}
                      {windowStats.map((ws, wi) => {
                        const cx = padL + ((wi + 0.5) / windows.length) * plotW;
                        const x1 = cx - boxWidth / 2;
                        return (
                          <g key={wi}>
                            {/* Whisker: min to max */}
                            <line x1={cx} y1={scaleY(ws.min)} x2={cx} y2={scaleY(ws.max)} stroke={ws.color.replace("0.5", "0.8")} strokeWidth="1" />
                            {/* Min and max caps */}
                            <line x1={cx - 8} y1={scaleY(ws.min)} x2={cx + 8} y2={scaleY(ws.min)} stroke={ws.color.replace("0.5", "0.8")} strokeWidth="1" />
                            <line x1={cx - 8} y1={scaleY(ws.max)} x2={cx + 8} y2={scaleY(ws.max)} stroke={ws.color.replace("0.5", "0.8")} strokeWidth="1" />
                            {/* Box: Q1 to Q3 */}
                            <rect x={x1} y={scaleY(ws.q3)} width={boxWidth} height={Math.max(1, scaleY(ws.q1) - scaleY(ws.q3))}
                              fill={ws.color} stroke={ws.color.replace("0.5", "0.9")} strokeWidth="1" rx="2" />
                            {/* Median line */}
                            <line x1={x1} y1={scaleY(ws.median)} x2={x1 + boxWidth} y2={scaleY(ws.median)}
                              stroke={ws.color.replace("0.5", "1")} strokeWidth="2" />
                            {/* Label */}
                            <text x={cx} y={H - 8} textAnchor="middle" fontSize="10" fontWeight="500" fill="var(--color-text-secondary)">
                              {ws.label}
                            </text>
                            <text x={cx} y={H - 0} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {ws.sublabel}
                            </text>
                          </g>
                        );
                      })}
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      {windowStats.map((ws, i) => (
                        <span key={i} className="efficiency-legend-item" style={{ fontFamily: "var(--font-mono)", fontSize: "0.72rem" }}>
                          <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: ws.color, marginRight: 4, verticalAlign: "middle" }} />
                          {ws.label}: med={ws.median.toFixed(4)}
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Auto-generated Findings Summary */}
              {trials.length >= 5 && (() => {
                const findings: Array<{ icon: string; text: string; type: "success" | "info" | "warning" }> = [];
                const objKey = Object.keys(trials[0].kpis)[0];
                const objVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const bestVal = Math.min(...objVals);
                const worstVal = Math.max(...objVals);
                const meanVal = objVals.reduce((a, b) => a + b, 0) / objVals.length;
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const bestTrial = chrono.find(t => Number(t.kpis[objKey]) === bestVal);

                // Finding 1: Best result
                if (bestTrial) {
                  findings.push({ icon: "trophy", text: `Best result of ${bestVal.toFixed(4)} found at iteration ${bestTrial.iteration} out of ${trials.length} trials.`, type: "success" });
                }

                // Finding 2: Parameter importance
                if (importance && importance.importances.length > 0) {
                  const sorted = [...importance.importances].sort((a, b) => b.importance - a.importance);
                  const top = sorted[0];
                  const topPct = (top.importance * 100).toFixed(1);
                  findings.push({ icon: "target", text: `${top.name} is the most influential parameter (${topPct}% importance).`, type: "info" });
                  if (sorted.length > 1) {
                    const bottom = sorted[sorted.length - 1];
                    if (bottom.importance < 0.05) {
                      findings.push({ icon: "info", text: `${bottom.name} has minimal impact (${(bottom.importance * 100).toFixed(1)}%) — consider fixing it to reduce dimensionality.`, type: "warning" });
                    }
                  }
                }

                // Finding 3: Plateau detection
                const recent20 = chrono.slice(-20);
                if (recent20.length >= 10) {
                  const recentBests = recent20.map(t => Number(t.kpis[objKey]) || 0);
                  const recentBest = Math.min(...recentBests);
                  const recentWorst = Math.max(...recentBests);
                  const recentRange = Math.abs(recentWorst - recentBest);
                  const totalRange = Math.abs(worstVal - bestVal);
                  if (totalRange > 0 && recentRange / totalRange < 0.05) {
                    findings.push({ icon: "pause", text: `Optimization has plateaued — the last ${recent20.length} trials show <5% variation. Consider exploring new regions.`, type: "warning" });
                  }
                }

                // Finding 4: Improvement rate
                if (chrono.length >= 10) {
                  const firstHalf = chrono.slice(0, Math.floor(chrono.length / 2));
                  const secondHalf = chrono.slice(Math.floor(chrono.length / 2));
                  const firstBest = Math.min(...firstHalf.map(t => Number(t.kpis[objKey]) || 0));
                  const secondBest = Math.min(...secondHalf.map(t => Number(t.kpis[objKey]) || 0));
                  if (secondBest < firstBest) {
                    const improvPct = ((firstBest - secondBest) / Math.abs(firstBest) * 100).toFixed(1);
                    findings.push({ icon: "trending", text: `Second half of trials improved ${improvPct}% over the first half — optimization is progressing well.`, type: "success" });
                  }
                }

                // Finding 5: Spread
                const cv = meanVal !== 0 ? (Math.sqrt(objVals.reduce((a, v) => a + (v - meanVal) ** 2, 0) / objVals.length) / Math.abs(meanVal)) : 0;
                if (cv > 0.5) {
                  findings.push({ icon: "scatter", text: `High variability (CV=${(cv * 100).toFixed(0)}%) in objective values suggests the search space has diverse outcomes.`, type: "info" });
                }

                if (findings.length === 0) return null;

                const iconMap: Record<string, React.ReactNode> = {
                  trophy: <Trophy size={14} />,
                  target: <Target size={14} />,
                  info: <Info size={14} />,
                  pause: <Pause size={14} />,
                  trending: <TrendingDown size={14} />,
                  scatter: <Activity size={14} />,
                };

                return (
                  <div className="card findings-card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "12px" }}>
                      <Brain size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Key Findings</h2>
                      <span className="findings-badge">{findings.length}</span>
                    </div>
                    <div className="findings-list">
                      {findings.map((f, i) => (
                        <div key={i} className={`findings-item findings-${f.type}`}>
                          <span className="findings-icon">{iconMap[f.icon] || <Info size={14} />}</span>
                          <span className="findings-text">{f.text}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Diminishing Returns Detector */}
              {trials.length >= 15 && (() => {
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const objKey = Object.keys(chrono[0].kpis)[0];
                const vals = chrono.map(t => Number(t.kpis[objKey]) || 0);

                // Compute cumulative best at each point
                const cumBest: number[] = [];
                let runBest = Infinity;
                for (const v of vals) {
                  if (v < runBest) runBest = v;
                  cumBest.push(runBest);
                }

                // Marginal improvement in windows of different sizes
                const windows = [10, 25, 50].filter(w => w <= chrono.length);
                const marginalData: Array<{ window: number; improvements: Array<{ x: number; y: number }> }> = [];
                for (const w of windows) {
                  const improvements: Array<{ x: number; y: number }> = [];
                  for (let i = w; i < cumBest.length; i += Math.max(1, Math.floor(w / 3))) {
                    const improvementInWindow = cumBest[i - w] - cumBest[i]; // positive = improved
                    improvements.push({ x: i, y: improvementInWindow });
                  }
                  marginalData.push({ window: w, improvements });
                }

                const allY = marginalData.flatMap(d => d.improvements.map(p => p.y));
                const maxImprovement = Math.max(...allY, 0.001);
                const totalImprovement = cumBest[0] - cumBest[cumBest.length - 1];
                const recentImprovement = cumBest.length > 20 ? cumBest[cumBest.length - 20] - cumBest[cumBest.length - 1] : 0;
                const recentPct = totalImprovement > 0 ? (recentImprovement / totalImprovement * 100).toFixed(0) : "0";
                const diminishing = totalImprovement > 0 && recentImprovement < totalImprovement * 0.05;

                const W = 460, H = 130, padL = 50, padR = 12, padT = 10, padB = 28;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const scaleX = (x: number) => padL + (x / (chrono.length - 1)) * plotW;
                const scaleY = (y: number) => padT + (1 - y / maxImprovement) * plotH;

                const colors = ["var(--color-primary)", "var(--color-blue, #3b82f6)", "var(--color-text-muted)"];
                const dashes = ["", "4,3", "2,2"];

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <PieChart size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Diminishing Returns</h2>
                      <span className={`findings-badge findings-badge-${diminishing ? "warning" : "success"}`} style={{ marginLeft: "auto" }}>
                        {diminishing ? "Low marginal gain" : `${recentPct}% recent`}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Marginal improvement per window of trials. Declining curves suggest diminishing returns from additional experiments.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Grid lines */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <line key={f} x1={padL} y1={padT + f * plotH} x2={padL + plotW} y2={padT + f * plotH}
                          stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                      ))}
                      {/* Lines for each window */}
                      {marginalData.map((d, di) => {
                        if (d.improvements.length < 2) return null;
                        const path = d.improvements.map((p, i) => `${i === 0 ? "M" : "L"}${scaleX(p.x).toFixed(1)},${scaleY(p.y).toFixed(1)}`).join(" ");
                        return (
                          <path key={di} d={path} fill="none" stroke={colors[di]} strokeWidth="1.8" strokeLinecap="round"
                            strokeDasharray={dashes[di]} opacity="0.8" />
                        );
                      })}
                      {/* Zero line */}
                      <line x1={padL} y1={scaleY(0)} x2={padL + plotW} y2={scaleY(0)} stroke="var(--color-text-muted)" strokeWidth="0.5" opacity="0.3" />
                      {/* Y axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(f * maxImprovement).toFixed(3)}
                        </text>
                      ))}
                      {/* X axis */}
                      <text x={padL} y={H - 4} textAnchor="start" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">0</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{chrono.length}</text>
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">Iteration</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      {marginalData.map((d, di) => (
                        <span key={di} className="efficiency-legend-item">
                          <span style={{ display: "inline-block", width: 14, height: 2, background: colors[di], borderRadius: 1, marginRight: 4, verticalAlign: "middle" }} />
                          Last {d.window} trials
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Cost-Adjusted Stopping Signal */}
              {trials.length >= 15 && (() => {
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const objKey = Object.keys(chrono[0].kpis)[0];
                const vals = chrono.map(t => Number(t.kpis[objKey]) || 0);

                // Cumulative best
                const cumBest: number[] = [];
                let rb = Infinity;
                for (const v of vals) { if (v < rb) rb = v; cumBest.push(rb); }

                // Cost-adjusted regret: improvement per unit cost (iteration)
                const totalImprovement = cumBest[0] - cumBest[cumBest.length - 1];
                const regretSeries: Array<{ iter: number; regret: number; marginal: number }> = [];
                for (let i = 1; i < cumBest.length; i++) {
                  const improvement = cumBest[0] - cumBest[i];
                  const regret = totalImprovement > 0 ? improvement / totalImprovement : 0; // normalized 0-1
                  const marginalWindow = Math.min(10, i);
                  const marginal = i >= marginalWindow ? (cumBest[i - marginalWindow] - cumBest[i]) / marginalWindow : 0;
                  regretSeries.push({ iter: i, regret, marginal });
                }

                // Stopping signal: compute efficiency ratio
                const recentMarginal = regretSeries.slice(-10).reduce((a, r) => a + r.marginal, 0) / 10;
                const avgMarginal = totalImprovement / chrono.length;
                const efficiencyRatio = avgMarginal > 0 ? recentMarginal / avgMarginal : 0;

                // Zone classification
                let zone: "green" | "yellow" | "red";
                let zoneLabel: string;
                if (efficiencyRatio > 0.3) { zone = "green"; zoneLabel = "Continue"; }
                else if (efficiencyRatio > 0.05) { zone = "yellow"; zoneLabel = "Caution"; }
                else { zone = "red"; zoneLabel = "Consider stopping"; }

                // Project future: exponential decay of marginal improvement
                const projectedIters = 30;
                const projections: Array<{ iter: number; regret: number }> = [];
                const lastRegret = regretSeries[regretSeries.length - 1]?.regret ?? 0;
                const decayRate = efficiencyRatio > 0 ? Math.min(0.95, 1 - efficiencyRatio * 0.1) : 0.98;
                let projMarginal = recentMarginal;
                let projRegret = lastRegret;
                for (let i = 1; i <= projectedIters; i++) {
                  projMarginal *= decayRate;
                  const projImprovement = projMarginal * (totalImprovement > 0 ? chrono.length / totalImprovement : 0);
                  projRegret = Math.min(1, projRegret + projImprovement * 0.01);
                  projections.push({ iter: chrono.length + i, regret: projRegret });
                }

                const W = 460, H = 140, padL = 50, padR = 12, padT = 10, padB = 28;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const totalIters = chrono.length + projectedIters;
                const scaleX = (x: number) => padL + (x / totalIters) * plotW;
                const scaleY = (y: number) => padT + (1 - y) * plotH;

                const zoneColors = { green: "#22c55e", yellow: "#eab308", red: "#ef4444" };
                const regretPath = regretSeries.map((r, i) => `${i === 0 ? "M" : "L"}${scaleX(r.iter).toFixed(1)},${scaleY(r.regret).toFixed(1)}`).join(" ");
                const projPath = projections.length > 0
                  ? `M${scaleX(chrono.length).toFixed(1)},${scaleY(lastRegret).toFixed(1)} ${projections.map(p => `L${scaleX(p.iter).toFixed(1)},${scaleY(p.regret).toFixed(1)}`).join(" ")}`
                  : "";

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Flag size={16} style={{ color: zoneColors[zone] }} />
                      <h2 style={{ margin: 0 }}>Stopping Signal</h2>
                      <span className={`findings-badge findings-badge-${zone === "green" ? "success" : zone === "yellow" ? "warning" : "warning"}`} style={{ marginLeft: "auto", background: zone === "red" ? "rgba(239,68,68,0.1)" : undefined, color: zone === "red" ? "#ef4444" : undefined }}>
                        {zoneLabel}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Normalized improvement progress over iterations. Flat curve = diminishing returns. Dashed line = projected trajectory.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Zone background */}
                      <rect x={padL} y={padT} width={plotW} height={plotH * 0.3} fill="rgba(34,197,94,0.05)" />
                      <rect x={padL} y={padT + plotH * 0.3} width={plotW} height={plotH * 0.4} fill="rgba(234,179,8,0.05)" />
                      <rect x={padL} y={padT + plotH * 0.7} width={plotW} height={plotH * 0.3} fill="rgba(239,68,68,0.05)" />
                      {/* Grid */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <line key={f} x1={padL} y1={padT + f * plotH} x2={padL + plotW} y2={padT + f * plotH}
                          stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                      ))}
                      {/* Now boundary */}
                      <line x1={scaleX(chrono.length)} y1={padT} x2={scaleX(chrono.length)} y2={padT + plotH}
                        stroke="var(--color-text-muted)" strokeWidth="1" strokeDasharray="4,3" opacity="0.5" />
                      <text x={scaleX(chrono.length)} y={padT - 2} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)">Now</text>
                      {/* Regret curve */}
                      <path d={regretPath} fill="none" stroke={zoneColors[zone]} strokeWidth="2" strokeLinecap="round" />
                      {/* Projection */}
                      {projPath && <path d={projPath} fill="none" stroke={zoneColors[zone]} strokeWidth="1.5" strokeDasharray="4,3" opacity="0.5" />}
                      {/* Y-axis */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL - 4} y={scaleY(f) + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(f * 100).toFixed(0)}%
                        </text>
                      ))}
                      {/* X-axis */}
                      <text x={padL} y={H - 4} textAnchor="start" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">0</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{totalIters}</text>
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">Iteration</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: zoneColors[zone], borderRadius: 1, marginRight: 4, verticalAlign: "middle" }} />Improvement</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 0, borderTop: `2px dashed ${zoneColors[zone]}`, opacity: 0.5, marginRight: 4, verticalAlign: "middle" }} />Projected</span>
                      <span className="efficiency-legend-item" style={{ fontFamily: "var(--font-mono)" }}>Efficiency: {(efficiencyRatio * 100).toFixed(1)}%</span>
                    </div>
                  </div>
                );
              })()}

              {/* Cumulative Regret Curve */}
              {trials.length >= 10 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const vals = trials.map(t => Number(t.kpis[objKey]) || 0);
                // Assume minimize: regret = value - bestPossible; use running best as proxy
                const globalBest = Math.min(...vals);
                // cumulative regret for BO
                let cumRegret = 0;
                const boRegret = vals.map(v => { cumRegret += Math.max(0, v - globalBest); return cumRegret; });
                // random baseline: average regret per trial * iteration
                const avgVal = vals.reduce((a, b) => a + b, 0) / vals.length;
                const avgRegretPerTrial = Math.max(0, avgVal - globalBest);
                const randomRegret = vals.map((_, i) => avgRegretPerTrial * (i + 1));

                const maxR = Math.max(boRegret[boRegret.length - 1], randomRegret[randomRegret.length - 1], 1);
                const W = 400, H = 180, padL = 52, padR = 16, padT = 28, padB = 32;
                const plotW = W - padL - padR, plotH = H - padT - padB;
                const n = vals.length;

                const toX = (i: number) => padL + (i / (n - 1)) * plotW;
                const toY = (v: number) => padT + (1 - v / maxR) * plotH;

                const boPath = boRegret.map((v, i) => `${i === 0 ? "M" : "L"}${toX(i).toFixed(1)},${toY(v).toFixed(1)}`).join(" ");
                const randPath = randomRegret.map((v, i) => `${i === 0 ? "M" : "L"}${toX(i).toFixed(1)},${toY(v).toFixed(1)}`).join(" ");

                // Find divergence point: where BO regret drops significantly below random
                let divergeIdx = -1;
                for (let i = 3; i < n; i++) {
                  if (randomRegret[i] > 0 && boRegret[i] / randomRegret[i] < 0.7) { divergeIdx = i; break; }
                }

                const savings = maxR > 0 ? ((1 - boRegret[n - 1] / randomRegret[n - 1]) * 100) : 0;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }}>
                      <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                        <TrendingDown size={16} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Cumulative Regret</h2>
                      </div>
                      <span className="findings-badge" style={{ background: savings > 30 ? "var(--color-green-bg)" : savings > 10 ? "var(--color-yellow-bg)" : "var(--color-red-bg)", color: savings > 30 ? "var(--color-green)" : savings > 10 ? "var(--color-yellow)" : "var(--color-red)" }}>
                        {savings > 0 ? `${savings.toFixed(0)}% less regret` : "No improvement"}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Cumulative distance from optimal. Lower is better. Dashed = random baseline.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Y-axis labels */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <Fragment key={f}>
                          <line x1={padL} y1={padT + (1 - f) * plotH} x2={padL + plotW} y2={padT + (1 - f) * plotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="2,3" />
                          <text x={padL - 6} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                            {(f * maxR).toFixed(1)}
                          </text>
                        </Fragment>
                      ))}
                      {/* X-axis label */}
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)">Trials</text>
                      {/* Random baseline (dashed) */}
                      <path d={randPath} fill="none" stroke="var(--color-text-muted)" strokeWidth="1.5" strokeDasharray="5,3" opacity="0.6" />
                      {/* BO regret (solid) */}
                      <path d={boPath} fill="none" stroke="var(--color-primary)" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Fill between random and BO */}
                      <path
                        d={`${boPath} L${toX(n - 1).toFixed(1)},${toY(randomRegret[n - 1]).toFixed(1)} ${randomRegret.slice().reverse().map((v, i) => `L${toX(n - 1 - i).toFixed(1)},${toY(v).toFixed(1)}`).join(" ")} Z`}
                        fill="var(--color-primary)"
                        opacity="0.07"
                      />
                      {/* Divergence marker */}
                      {divergeIdx >= 0 && (
                        <>
                          <line x1={toX(divergeIdx)} y1={padT} x2={toX(divergeIdx)} y2={padT + plotH} stroke="var(--color-green)" strokeWidth="1" strokeDasharray="3,2" opacity="0.6" />
                          <text x={toX(divergeIdx) + 4} y={padT + 10} fontSize="8" fill="var(--color-green)" fontFamily="var(--font-mono)">diverge</text>
                        </>
                      )}
                      {/* End markers */}
                      <circle cx={toX(n - 1)} cy={toY(boRegret[n - 1])} r="3" fill="var(--color-primary)" />
                      <circle cx={toX(n - 1)} cy={toY(randomRegret[n - 1])} r="3" fill="var(--color-text-muted)" opacity="0.6" />
                    </svg>
                    {/* Legend */}
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 2, background: "var(--color-primary)", marginRight: 4, verticalAlign: "middle" }} />BO</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 2, background: "var(--color-text-muted)", marginRight: 4, verticalAlign: "middle", borderTop: "1px dashed var(--color-text-muted)" }} />Random</span>
                    </div>
                  </div>
                );
              })()}

              {/* Dominated Region / Best-so-far Area */}
              {trials.length >= 10 && (() => {
                const drObjKey = Object.keys(trials[0].kpis)[0];
                const drVals = trials.map(t => Number(t.kpis[drObjKey]) || 0);
                let drBest = drVals[0];
                const drBestLine = drVals.map(v => { drBest = Math.min(drBest, v); return drBest; });
                const drMin = Math.min(...drVals), drMax = Math.max(...drVals);
                const drRange = drMax - drMin || 1;

                const W = 400, H = 160, padL = 52, padR = 16, padT = 24, padB = 28;
                const plotW = W - padL - padR, plotH = H - padT - padB;
                const n = drVals.length;
                const toX = (i: number) => padL + (i / (n - 1)) * plotW;
                const toY = (v: number) => padT + (1 - (v - drMin) / drRange) * plotH;

                // Best-so-far line path
                const bsfPath = drBestLine.map((v, i) => `${i === 0 ? "M" : "L"}${toX(i).toFixed(1)},${toY(v).toFixed(1)}`).join(" ");
                // Area under best-so-far (dominated region)
                const areaPath = `${bsfPath} L${toX(n - 1).toFixed(1)},${(padT + plotH).toFixed(1)} L${padL},${(padT + plotH).toFixed(1)} Z`;

                // Dominated area ratio (how much of the objective range is dominated)
                const dominatedPct = drRange > 0 ? ((drMax - drBestLine[n - 1]) / drRange * 100) : 0;

                // Milestones: when best improved
                const milestones: { idx: number; val: number }[] = [];
                for (let i = 1; i < n; i++) {
                  if (drBestLine[i] < drBestLine[i - 1]) milestones.push({ idx: i, val: drBestLine[i] });
                }

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }}>
                      <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                        <Flag size={16} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Dominated Region</h2>
                      </div>
                      <span className="findings-badge" style={{ background: "var(--color-green-bg)", color: "var(--color-green)" }}>
                        {dominatedPct.toFixed(0)}% dominated
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Shaded area shows the dominated region below worst outcome. More shading = more progress.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Y-axis */}
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={f}>
                          <line x1={padL} y1={padT + (1 - f) * plotH} x2={padL + plotW} y2={padT + (1 - f) * plotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="2,3" />
                          <text x={padL - 6} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                            {(drMin + f * drRange).toFixed(3)}
                          </text>
                        </Fragment>
                      ))}
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)">Trials</text>
                      {/* Dominated area fill */}
                      <path d={areaPath} fill="var(--color-primary)" opacity="0.12" />
                      {/* Best-so-far line */}
                      <path d={bsfPath} fill="none" stroke="var(--color-primary)" strokeWidth="2" strokeLinecap="round" />
                      {/* Trial dots */}
                      {drVals.map((v, i) => (
                        <circle key={i} cx={toX(i)} cy={toY(v)} r="1.5" fill="var(--color-text-muted)" opacity="0.3" />
                      ))}
                      {/* Milestone markers */}
                      {milestones.slice(-5).map((m, i) => (
                        <Fragment key={i}>
                          <circle cx={toX(m.idx)} cy={toY(m.val)} r="3.5" fill="var(--color-primary)" stroke="white" strokeWidth="1" />
                        </Fragment>
                      ))}
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", fontSize: "0.75rem", color: "var(--color-text-muted)" }}>
                      <span>{milestones.length} improvement{milestones.length !== 1 ? "s" : ""}</span>
                      <span>Best at trial #{milestones.length > 0 ? milestones[milestones.length - 1].idx : 0}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Sample Efficiency Tracker */}
              {trials.length >= 15 && (() => {
                const seObjKey = Object.keys(trials[0].kpis)[0];
                const seVals = trials.map(t => Number(t.kpis[seObjKey]) || 0);
                // Best-so-far
                let seBest = seVals[0];
                const seBsf = seVals.map(v => { seBest = Math.min(seBest, v); return seBest; });
                // Improvement per window
                const seWinSize = Math.max(5, Math.floor(trials.length / 10));
                const seWindows: { start: number; end: number; improvement: number; cumImprove: number }[] = [];
                let seCumImprove = 0;
                for (let i = 0; i < trials.length; i += seWinSize) {
                  const end = Math.min(i + seWinSize - 1, trials.length - 1);
                  const winImprove = Math.abs(seBsf[end] - seBsf[i]);
                  seCumImprove += winImprove;
                  seWindows.push({ start: i, end, improvement: winImprove, cumImprove: seCumImprove });
                }
                if (seWindows.length < 2) return null;

                const seMaxImprove = Math.max(...seWindows.map(w => w.improvement), 0.001);
                const seMaxCum = seWindows[seWindows.length - 1].cumImprove || 1;

                const seW = 440, seH = 160, sePadL = 44, sePadR = 44, sePadT = 16, sePadB = 28;
                const sePlotW = seW - sePadL - sePadR;
                const sePlotH = seH - sePadT - sePadB;
                const barW = Math.max(8, sePlotW / seWindows.length - 4);

                // ROI threshold: average improvement
                const seAvgImprove = seWindows.reduce((s, w) => s + w.improvement, 0) / seWindows.length;
                const roiY = sePadT + sePlotH - (seAvgImprove / seMaxImprove) * sePlotH;

                // Recent efficiency ratio
                const lastThird = seWindows.slice(-Math.ceil(seWindows.length / 3));
                const firstThird = seWindows.slice(0, Math.ceil(seWindows.length / 3));
                const recentAvg = lastThird.reduce((s, w) => s + w.improvement, 0) / lastThird.length;
                const earlyAvg = firstThird.reduce((s, w) => s + w.improvement, 0) / firstThird.length;
                const efficiencyRatio = earlyAvg > 0 ? recentAvg / earlyAvg : 0;

                // Cumulative improvement line
                const cumPath = seWindows.map((w, i) => {
                  const x = sePadL + (i + 0.5) / seWindows.length * sePlotW;
                  const y = sePadT + sePlotH - (w.cumImprove / seMaxCum) * sePlotH;
                  return `${i === 0 ? "M" : "L"}${x.toFixed(1)},${y.toFixed(1)}`;
                }).join(" ");

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Zap size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Sample Efficiency</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Improvement per {seWinSize}-trial window. Declining bars = diminishing returns.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", color: efficiencyRatio < 0.3 ? "var(--color-red, #ef4444)" : efficiencyRatio < 0.7 ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)" }}>
                        {(efficiencyRatio * 100).toFixed(0)}% recent efficiency
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={seW} height={seH} viewBox={`0 0 ${seW} ${seH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Grid */}
                        {[0, 0.25, 0.5, 0.75, 1].map(f => (
                          <line key={f} x1={sePadL} y1={sePadT + (1 - f) * sePlotH} x2={sePadL + sePlotW} y2={sePadT + (1 - f) * sePlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                        ))}
                        {/* Bars (improvement per window) */}
                        {seWindows.map((w, i) => {
                          const x = sePadL + (i + 0.5) / seWindows.length * sePlotW - barW / 2;
                          const h = (w.improvement / seMaxImprove) * sePlotH;
                          const barColor = w.improvement > seAvgImprove ? "rgba(34,197,94,0.5)" : "rgba(234,179,8,0.4)";
                          return (
                            <rect key={i} x={x} y={sePadT + sePlotH - h} width={barW} height={Math.max(h, 1)} fill={barColor} rx={2}>
                              <title>Window {i + 1}: trials {w.start}–{w.end}, improvement {w.improvement.toPrecision(3)}</title>
                            </rect>
                          );
                        })}
                        {/* ROI threshold line */}
                        <line x1={sePadL} y1={roiY} x2={sePadL + sePlotW} y2={roiY} stroke="var(--color-text-muted)" strokeWidth={1} strokeDasharray="4,3" opacity={0.5} />
                        <text x={sePadL + sePlotW + 3} y={roiY + 3} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">avg</text>
                        {/* Cumulative improvement line (right axis) */}
                        <path d={cumPath} fill="none" stroke="rgba(99,102,241,0.7)" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                        {/* Dots on cumulative line */}
                        {seWindows.map((w, i) => {
                          const x = sePadL + (i + 0.5) / seWindows.length * sePlotW;
                          const y = sePadT + sePlotH - (w.cumImprove / seMaxCum) * sePlotH;
                          return <circle key={i} cx={x} cy={y} r={2.5} fill="rgba(99,102,241,0.8)" />;
                        })}
                        {/* Left Y axis label */}
                        <text x={8} y={sePadT + sePlotH / 2} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" transform={`rotate(-90,8,${sePadT + sePlotH / 2})`}>
                          Δ per window
                        </text>
                        {/* Right Y axis label */}
                        <text x={seW - 8} y={sePadT + sePlotH / 2} textAnchor="middle" fontSize="9" fill="rgba(99,102,241,0.7)" fontFamily="var(--font-mono)" transform={`rotate(90,${seW - 8},${sePadT + sePlotH / 2})`}>
                          Cumulative
                        </text>
                        {/* X axis */}
                        <text x={sePadL + sePlotW / 2} y={seH - 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          Trial Window
                        </text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(34,197,94,0.5)", marginRight: 4, verticalAlign: "middle" }} />Above avg</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(234,179,8,0.4)", marginRight: 4, verticalAlign: "middle" }} />Below avg</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 3, background: "rgba(99,102,241,0.7)", marginRight: 4, verticalAlign: "middle" }} />Cumulative</span>
                    </div>
                  </div>
                );
              })()}

              {/* Noise-Signal Decomposition Gauge */}
              {trials.length >= 10 && (() => {
                const nsObjKey = Object.keys(trials[0].kpis)[0];
                const nsVals = trials.map(t => Number(t.kpis[nsObjKey]) || 0);
                const nsMean = nsVals.reduce((a, b) => a + b, 0) / nsVals.length;
                const nsGlobalVar = nsVals.reduce((a, v) => a + (v - nsMean) ** 2, 0) / nsVals.length;
                // Estimate noise: average local variance from k nearest neighbors
                const nsParamKeys = Object.keys(trials[0].parameters);
                const nsNormTrials = trials.map(t => nsParamKeys.map(k => Number(t.parameters[k]) || 0));
                const nsK = Math.min(5, Math.floor(trials.length / 3));
                let nsNoiseSum = 0;
                for (let i = 0; i < trials.length; i++) {
                  const nsDists = nsNormTrials.map((nt, j) => ({
                    j,
                    d: nt.reduce((s, v, dim) => s + (v - nsNormTrials[i][dim]) ** 2, 0),
                  })).filter(x => x.j !== i).sort((a, b) => a.d - b.d).slice(0, nsK);
                  const nsNeighVals = nsDists.map(x => nsVals[x.j]);
                  const nsLocalMean = nsNeighVals.reduce((a, b) => a + b, 0) / nsNeighVals.length;
                  nsNoiseSum += nsNeighVals.reduce((a, v) => a + (v - nsLocalMean) ** 2, 0) / nsNeighVals.length;
                }
                const nsNoiseVar = nsNoiseSum / trials.length;
                const nsSignalVar = Math.max(0, nsGlobalVar - nsNoiseVar);
                const nsRatio = nsGlobalVar > 0 ? nsNoiseVar / nsGlobalVar : 0;
                const nsSnr = nsNoiseVar > 0 ? nsSignalVar / nsNoiseVar : 99;
                const nsStatus = nsRatio < 0.3 ? "Signal-dominant" : nsRatio < 0.6 ? "Moderate noise" : "Noise-dominant";
                const nsColor = nsRatio < 0.3 ? "#22c55e" : nsRatio < 0.6 ? "#eab308" : "#ef4444";
                const nsW = 300, nsH = 120, nsPad = 20;
                const nsBarW = 30, nsBarH = nsH - 2 * nsPad;
                const nsBarX = nsPad + 40;
                const nsBarY = nsPad;
                const nsFillH = nsBarH * Math.min(nsRatio, 1);
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "flex-start", gap: "10px", marginBottom: "8px" }}>
                      <Volume2 size={16} style={{ color: "var(--color-primary)", marginTop: 2 }} />
                      <div style={{ flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Noise-Signal Decomposition</h2>
                        <p style={{ margin: "2px 0 0", fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                          Ratio of measurement noise to total objective variance.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ background: nsColor + "22", color: nsColor, border: `1px solid ${nsColor}44` }}>
                        SNR: {nsSnr.toFixed(1)}
                      </span>
                    </div>
                    <svg width={nsW} height={nsH} viewBox={`0 0 ${nsW} ${nsH}`} role="img" aria-label="Noise-signal gauge" style={{ display: "block", margin: "0 auto" }}>
                      {/* Gauge background */}
                      <rect x={nsBarX} y={nsBarY} width={nsBarW} height={nsBarH} rx={4} fill="var(--color-border)" />
                      {/* Noise fill (from bottom) */}
                      <rect x={nsBarX} y={nsBarY + nsBarH - nsFillH} width={nsBarW} height={nsFillH} rx={4} fill={nsColor} opacity={0.7} />
                      {/* Zone lines */}
                      <line x1={nsBarX - 4} y1={nsBarY + nsBarH * 0.4} x2={nsBarX + nsBarW + 4} y2={nsBarY + nsBarH * 0.4} stroke="var(--color-text-muted)" strokeWidth={0.5} strokeDasharray="3,2" />
                      <line x1={nsBarX - 4} y1={nsBarY + nsBarH * 0.7} x2={nsBarX + nsBarW + 4} y2={nsBarY + nsBarH * 0.7} stroke="var(--color-text-muted)" strokeWidth={0.5} strokeDasharray="3,2" />
                      {/* Zone labels */}
                      <text x={nsBarX + nsBarW + 10} y={nsBarY + nsBarH * 0.2} fontSize="9" fill="#ef4444" fontFamily="var(--font-mono)">Noise-heavy</text>
                      <text x={nsBarX + nsBarW + 10} y={nsBarY + nsBarH * 0.55} fontSize="9" fill="#eab308" fontFamily="var(--font-mono)">Moderate</text>
                      <text x={nsBarX + nsBarW + 10} y={nsBarY + nsBarH * 0.85} fontSize="9" fill="#22c55e" fontFamily="var(--font-mono)">Signal-clear</text>
                      {/* Percentage labels */}
                      <text x={nsBarX - 6} y={nsBarY + 4} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">100%</text>
                      <text x={nsBarX - 6} y={nsBarY + nsBarH} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">0%</text>
                      {/* Current level marker */}
                      <line x1={nsBarX - 2} y1={nsBarY + nsBarH - nsFillH} x2={nsBarX + nsBarW + 2} y2={nsBarY + nsBarH - nsFillH} stroke={nsColor} strokeWidth={2} />
                      <text x={nsBarX - 6} y={nsBarY + nsBarH - nsFillH + 3} textAnchor="end" fontSize="9" fill={nsColor} fontWeight="600" fontFamily="var(--font-mono)">{(nsRatio * 100).toFixed(0)}%</text>
                      {/* Stats on right */}
                      <text x={nsBarX + nsBarW + 10} y={nsH - 6} fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                        σ²noise: {nsNoiseVar.toPrecision(3)} | σ²signal: {nsSignalVar.toPrecision(3)}
                      </text>
                    </svg>
                    <div style={{ textAlign: "center", marginTop: "4px", fontSize: "0.82rem", fontWeight: 600, color: nsColor }}>
                      {nsStatus}
                    </div>
                  </div>
                );
              })()}

              {/* Budget Utilization Curve */}
              {trials.length >= 3 && (() => {
                const buObs = [...trials].sort((a, b) => a.iteration - b.iteration);
                const buObjKey = campaign.objective_names?.[0] || Object.keys(buObs[0].kpis)[0];
                const buDir = (campaign.objective_directions?.[buObjKey] || "minimize") === "minimize" ? -1 : 1;
                const buVals = buObs.map(o => (o.kpis[buObjKey] ?? 0) * buDir);
                const buN = buVals.length;
                const buBest: number[] = [];
                let buRunBest = -Infinity;
                for (let i = 0; i < buN; i++) { buRunBest = Math.max(buRunBest, buVals[i]); buBest.push(buRunBest); }
                const buStart = buBest[0];
                const buEnd = buBest[buN - 1];
                const buRange = buEnd - buStart || 1;
                const buFrac = buBest.map(v => Math.max(0, Math.min(1, (v - buStart) / buRange)));
                // AUC via trapezoidal rule
                let buAUC = 0;
                for (let i = 1; i < buN; i++) {
                  const dx = 1 / (buN - 1);
                  buAUC += (buFrac[i - 1] + buFrac[i]) * 0.5 * dx;
                }
                const buAF = buAUC > 0 ? buAUC / 0.5 : 1.0;
                const buW = 200, buH = 80, buPad = 20;
                const buPts = buFrac.map((f, i) => ({
                  x: buPad + (i / (buN - 1)) * (buW - 2 * buPad),
                  y: buH - buPad - f * (buH - 2 * buPad),
                }));
                const buDiagStart = { x: buPad, y: buH - buPad };
                const buDiagEnd = { x: buW - buPad, y: buPad };
                // Build fill path between curve and diagonal
                const buCurvePath = buPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const buDiagPath = buPts.map((_, i) => {
                  const t = i / (buN - 1);
                  const dx = buDiagStart.x + t * (buDiagEnd.x - buDiagStart.x);
                  const dy = buDiagStart.y + t * (buDiagEnd.y - buDiagStart.y);
                  return `${dx.toFixed(1)},${dy.toFixed(1)}`;
                }).reverse().map((s, i) => `${i === 0 ? "L" : "L"}${s}`).join(" ");
                const buFillPath = buCurvePath + " " + buDiagPath + " Z";
                const buFillColor = buAF >= 1.0 ? "rgba(34,197,94,0.18)" : "rgba(239,68,68,0.15)";
                const buAccColor = buAF >= 1.0 ? "#22c55e" : "#ef4444";
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Gauge size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Budget Utilization</h3>
                      <span className="findings-badge" style={{ background: buAccColor + "18", color: buAccColor, marginLeft: "auto" }}>
                        {buAF.toFixed(1)}x acceleration
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${buW} ${buH}`} style={{ display: "block" }}>
                      {/* Grid lines */}
                      {[0.25, 0.5, 0.75].map(t => (
                        <Fragment key={`bug${t}`}>
                          <line x1={buPad + t * (buW - 2 * buPad)} y1={buPad} x2={buPad + t * (buW - 2 * buPad)} y2={buH - buPad} stroke="var(--color-border)" strokeWidth="0.5" />
                          <line x1={buPad} y1={buH - buPad - t * (buH - 2 * buPad)} x2={buW - buPad} y2={buH - buPad - t * (buH - 2 * buPad)} stroke="var(--color-border)" strokeWidth="0.5" />
                        </Fragment>
                      ))}
                      {/* Axes */}
                      <line x1={buPad} y1={buH - buPad} x2={buW - buPad} y2={buH - buPad} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                      <line x1={buPad} y1={buPad} x2={buPad} y2={buH - buPad} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                      {/* Fill between curve and diagonal */}
                      <path d={buFillPath} fill={buFillColor} />
                      {/* Random baseline diagonal */}
                      <line x1={buDiagStart.x} y1={buDiagStart.y} x2={buDiagEnd.x} y2={buDiagEnd.y} stroke="var(--color-text-muted)" strokeWidth="1" strokeDasharray="4 3" opacity={0.6} />
                      {/* Campaign curve */}
                      <polyline points={buPts.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ")} fill="none" stroke="#3b82f6" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Endpoint dot */}
                      <circle cx={buPts[buPts.length - 1].x} cy={buPts[buPts.length - 1].y} r="3" fill="#3b82f6" />
                      {/* Labels */}
                      <text x={buPad - 2} y={buH - buPad + 11} fontSize="7" fill="var(--color-text-muted)" textAnchor="start">0%</text>
                      <text x={buW - buPad + 2} y={buH - buPad + 11} fontSize="7" fill="var(--color-text-muted)" textAnchor="end">100%</text>
                      <text x={buPad - 4} y={buH - buPad} fontSize="7" fill="var(--color-text-muted)" textAnchor="end">0</text>
                      <text x={buPad - 4} y={buPad + 3} fontSize="7" fill="var(--color-text-muted)" textAnchor="end">1</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        <span style={{ display: "inline-block", width: 12, height: 2, background: "#3b82f6", borderRadius: 1 }} /> Campaign
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        <span style={{ display: "inline-block", width: 12, height: 0, borderTop: "1.5px dashed var(--color-text-muted)" }} /> Random baseline
                      </span>
                      <span>AUC: {buAUC.toFixed(3)}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Information Gain Efficiency */}
              {trials.length >= 6 && (() => {
                const igObjKey = campaign.objective_names?.[0] || Object.keys(trials[0].kpis)[0];
                const igSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const igVals = igSorted.map(t => t.kpis[igObjKey] ?? 0);
                const igN = igVals.length;
                const igWinSize = Math.max(3, Math.floor(igN / 12));
                // Compute rolling variance reduction (proxy for information gain)
                const igGains: { iter: number; gain: number }[] = [];
                for (let i = igWinSize; i < igN; i += Math.max(1, Math.floor(igWinSize / 2))) {
                  const before = igVals.slice(Math.max(0, i - igWinSize * 2), i - igWinSize);
                  const after = igVals.slice(i - igWinSize, i);
                  if (before.length < 2 || after.length < 2) continue;
                  const varBefore = (() => { const m = before.reduce((a, b) => a + b, 0) / before.length; return before.reduce((a, v) => a + (v - m) ** 2, 0) / before.length; })();
                  const varAfter = (() => { const m = after.reduce((a, b) => a + b, 0) / after.length; return after.reduce((a, v) => a + (v - m) ** 2, 0) / after.length; })();
                  const gain = varBefore > 1e-12 ? Math.max(0, 0.5 * Math.log(varBefore / Math.max(varAfter, 1e-15))) : 0;
                  igGains.push({ iter: igSorted[i].iteration, gain: Math.min(gain, 3) });
                }
                if (igGains.length < 3) return null;
                const igMax = Math.max(...igGains.map(g => g.gain), 0.01);
                const igAvg = igGains.reduce((a, g) => a + g.gain, 0) / igGains.length;
                const igRecent = igGains.slice(-3).reduce((a, g) => a + g.gain, 0) / 3;
                const igPhase = igRecent > igAvg * 0.75 ? "Active learning" : igRecent > igAvg * 0.3 ? "Diminishing" : "Saturated";
                const igPhaseColor = igPhase === "Active learning" ? "#22c55e" : igPhase === "Diminishing" ? "#f59e0b" : "#ef4444";
                const igW = 200, igH = 65, igPadX = 18, igPadY = 10;
                const igChartW = igW - 2 * igPadX, igChartH = igH - 2 * igPadY;
                const igPts = igGains.map((g, i) => ({
                  x: igPadX + (i / (igGains.length - 1)) * igChartW,
                  y: igH - igPadY - (g.gain / igMax) * igChartH,
                }));
                const igPath = igPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const igAreaPath = `M${igPts[0].x},${igH - igPadY} ${igPts.map(p => `L${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ")} L${igPts[igPts.length - 1].x},${igH - igPadY} Z`;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Waves size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Information Gain</h3>
                      <span className="findings-badge" style={{ background: igPhaseColor + "18", color: igPhaseColor, marginLeft: "auto" }}>
                        {igPhase}
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${igW} ${igH}`} style={{ display: "block" }}>
                      <defs>
                        <linearGradient id="ig-fill" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor={igPhaseColor} stopOpacity="0.25" />
                          <stop offset="100%" stopColor={igPhaseColor} stopOpacity="0.02" />
                        </linearGradient>
                      </defs>
                      {/* Grid lines */}
                      {[0.25, 0.5, 0.75].map(t => (
                        <line key={`igg${t}`} x1={igPadX} y1={igH - igPadY - t * igChartH} x2={igW - igPadX} y2={igH - igPadY - t * igChartH} stroke="var(--color-border)" strokeWidth="0.5" />
                      ))}
                      {/* Fill */}
                      <path d={igAreaPath} fill="url(#ig-fill)" />
                      {/* Line */}
                      <path d={igPath} fill="none" stroke={igPhaseColor} strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Endpoint */}
                      <circle cx={igPts[igPts.length - 1].x} cy={igPts[igPts.length - 1].y} r="2.5" fill={igPhaseColor} />
                      {/* Labels */}
                      <text x={igPadX} y={igH - 1} fontSize="5.5" fill="var(--color-text-muted)">early</text>
                      <text x={igW - igPadX} y={igH - 1} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">recent</text>
                      <text x={igPadX - 2} y={igPadY + 3} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">high</text>
                      <text x={igPadX - 2} y={igH - igPadY} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">low</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 2 }}>
                      <span>Avg gain: {igAvg.toFixed(3)} nats/window</span>
                      <span>Recent: {igRecent.toFixed(3)} nats/window</span>
                    </div>
                  </div>
                );
              })()}

              {/* Surrogate Fidelity Gauge */}
              {trials.length >= 10 && (() => {
                const sfK = 5; // k-NN neighbourhood size
                const sfTrials = trials.slice(-Math.min(trials.length, 60));
                const sfSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (sfSpecs.length === 0) return null;

                // Normalize parameters to [0,1]
                const sfNorm = sfTrials.map(t => sfSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                  const lo = s.lower ?? 0, hi = s.upper ?? 1;
                  return hi > lo ? (Number(t.parameters[s.name]) - lo) / (hi - lo) : 0.5;
                }));
                const sfKpi = Object.keys(sfTrials[0]?.kpis || {})[0];
                if (!sfKpi) return null;
                const sfYs = sfTrials.map(t => Number(t.kpis[sfKpi]) || 0);

                // For each point, compute LOO prediction variance using k-NN
                const sfVars: number[] = [];
                for (let i = 0; i < sfNorm.length; i++) {
                  const dists = sfNorm.map((pt, j) => ({
                    d: Math.sqrt(pt.reduce((s, v, k) => s + (v - sfNorm[i][k]) ** 2, 0)),
                    j,
                  })).filter(x => x.j !== i).sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, sfK);
                  const nMean = neighbors.reduce((s, n) => s + sfYs[n.j], 0) / sfK;
                  const nVar = neighbors.reduce((s, n) => s + (sfYs[n.j] - nMean) ** 2, 0) / sfK;
                  sfVars.push(nVar);
                }

                const sfGlobalVar = (() => {
                  const m = sfYs.reduce((a, b) => a + b, 0) / sfYs.length;
                  return sfYs.reduce((s, y) => s + (y - m) ** 2, 0) / sfYs.length;
                })();
                const sfAvgLocalVar = sfVars.reduce((a, b) => a + b, 0) / sfVars.length;
                // Fidelity = 1 - (avg local variance / global variance), clamped [0,1]
                const sfFidelity = sfGlobalVar > 0 ? Math.max(0, Math.min(1, 1 - sfAvgLocalVar / sfGlobalVar)) : 0.5;
                const sfPct = sfFidelity * 100;

                // Gauge geometry
                const sfW = 200, sfH = 115, sfCx = sfW / 2, sfCy = 95, sfR = 72;
                const sfAngleStart = Math.PI; // 180° arc (left to right)
                const sfNeedleAngle = sfAngleStart - sfFidelity * Math.PI;
                const sfNeedleLen = sfR - 8;
                const sfNx = sfCx + sfNeedleLen * Math.cos(sfNeedleAngle);
                const sfNy = sfCy - sfNeedleLen * Math.sin(sfNeedleAngle);

                // Arc segment helper
                const sfArc = (startFrac: number, endFrac: number) => {
                  const a1 = sfAngleStart - startFrac * Math.PI;
                  const a2 = sfAngleStart - endFrac * Math.PI;
                  const x1 = sfCx + sfR * Math.cos(a1), y1 = sfCy - sfR * Math.sin(a1);
                  const x2 = sfCx + sfR * Math.cos(a2), y2 = sfCy - sfR * Math.sin(a2);
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${sfR},${sfR} 0 0,1 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };

                const sfColor = sfPct >= 70 ? "#22c55e" : sfPct >= 40 ? "#f59e0b" : "#ef4444";
                const sfLabel = sfPct >= 70 ? "High fidelity" : sfPct >= 40 ? "Moderate" : "Low fidelity";

                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Gauge size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Surrogate Fidelity</h3>
                      <span className="findings-badge" style={{ background: sfColor + "18", color: sfColor, marginLeft: "auto" }}>
                        {sfPct.toFixed(0)}% fidelity
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${sfW} ${sfH}`} style={{ display: "block", margin: "0 auto" }}>
                      {/* Background arcs: red, yellow, green */}
                      <path d={sfArc(0, 0.4)} fill="none" stroke="rgba(239,68,68,0.2)" strokeWidth="14" strokeLinecap="round" />
                      <path d={sfArc(0.4, 0.7)} fill="none" stroke="rgba(245,158,11,0.2)" strokeWidth="14" strokeLinecap="round" />
                      <path d={sfArc(0.7, 1)} fill="none" stroke="rgba(34,197,94,0.2)" strokeWidth="14" strokeLinecap="round" />
                      {/* Active fill up to current fidelity */}
                      <path d={sfArc(0, sfFidelity)} fill="none" stroke={sfColor} strokeWidth="14" strokeLinecap="round" opacity={0.7} />
                      {/* Tick marks */}
                      {[0, 0.4, 0.7, 1].map((f, i) => {
                        const a = sfAngleStart - f * Math.PI;
                        const x1 = sfCx + (sfR + 10) * Math.cos(a), y1 = sfCy - (sfR + 10) * Math.sin(a);
                        const x2 = sfCx + (sfR + 15) * Math.cos(a), y2 = sfCy - (sfR + 15) * Math.sin(a);
                        return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke="var(--color-text-muted)" strokeWidth="1" opacity={0.5} />;
                      })}
                      {/* Labels at thresholds */}
                      <text x={sfCx - sfR - 12} y={sfCy + 10} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">0%</text>
                      <text x={sfCx} y={sfCy - sfR - 8} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">50%</text>
                      <text x={sfCx + sfR + 12} y={sfCy + 10} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">100%</text>
                      {/* Needle */}
                      <line x1={sfCx} y1={sfCy} x2={sfNx} y2={sfNy} stroke={sfColor} strokeWidth="2.5" strokeLinecap="round" />
                      <circle cx={sfCx} cy={sfCy} r="4" fill={sfColor} />
                      {/* Center value */}
                      <text x={sfCx} y={sfCy - 18} textAnchor="middle" fontSize="18" fontWeight="700" fill={sfColor} fontFamily="var(--font-mono)">{sfPct.toFixed(0)}%</text>
                      <text x={sfCx} y={sfCy - 6} textAnchor="middle" fontSize="7.5" fill="var(--color-text-muted)">{sfLabel}</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 2 }}>
                      <span>σ²_local: {sfAvgLocalVar.toFixed(5)}</span>
                      <span>σ²_global: {sfGlobalVar.toFixed(5)}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Prediction Calibration Plot */}
              {trials.length >= 10 && (() => {
                const pc2Sorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const pc2KpiKey = Object.keys(pc2Sorted[0]?.kpis || {})[0];
                if (!pc2KpiKey) return null;
                const pc2Vals = pc2Sorted.map(t => t.kpis[pc2KpiKey] ?? 0);
                const pc2N = pc2Vals.length;

                // LOO prediction: for each point i, predict using k=5 nearest neighbors
                const pc2K = Math.min(5, pc2N - 1);
                const pc2Predictions: number[] = [];
                for (let i = 0; i < pc2N; i++) {
                  const pc2Dists: { d: number; v: number }[] = [];
                  for (let j = 0; j < pc2N; j++) {
                    if (j === i) continue;
                    const pKeys = Object.keys(pc2Sorted[i].parameters);
                    let dist = 0;
                    for (const pk of pKeys) {
                      const diff = (Number(pc2Sorted[i].parameters[pk]) || 0) - (Number(pc2Sorted[j].parameters[pk]) || 0);
                      dist += diff * diff;
                    }
                    pc2Dists.push({ d: Math.sqrt(dist), v: pc2Vals[j] });
                  }
                  pc2Dists.sort((a, b) => a.d - b.d);
                  const pc2Neighbors = pc2Dists.slice(0, pc2K);
                  const pc2Pred = pc2Neighbors.reduce((s, n) => s + n.v, 0) / pc2Neighbors.length;
                  pc2Predictions.push(pc2Pred);
                }

                // Compute residual std from LOO
                const pc2Residuals = pc2Vals.map((v, i) => v - pc2Predictions[i]);
                const pc2ResMean = pc2Residuals.reduce((a, b) => a + b, 0) / pc2N;
                const pc2ResStd = Math.sqrt(pc2Residuals.reduce((s, r) => s + (r - pc2ResMean) ** 2, 0) / pc2N) || 0.001;

                // For calibration: compute predicted percentile for each point
                // using Gaussian CDF approximation: P(x) ≈ 0.5 * (1 + erf(x / sqrt(2)))
                const pc2Erf = (x: number) => {
                  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429;
                  const p = 0.3275911;
                  const sign = x < 0 ? -1 : 1;
                  const t = 1 / (1 + p * Math.abs(x));
                  const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                  return sign * y;
                };
                const pc2NormCdf = (x: number) => 0.5 * (1 + pc2Erf(x / Math.SQRT2));

                // Predicted percentile: where does observed fall in predicted distribution N(pred, std)?
                const pc2PredPercentiles = pc2Vals.map((v, i) => pc2NormCdf((v - pc2Predictions[i]) / pc2ResStd));

                // Observed percentile: rank among all observed values
                const pc2ObsPercentiles = pc2Vals.map(v => {
                  const rank = pc2Vals.filter(o => o <= v).length;
                  return rank / pc2N;
                });

                // Bin into 10 bins and compute average predicted & observed percentile
                const pc2NBins = 10;
                const pc2Bins: { pred: number; obs: number }[] = [];
                for (let b = 0; b < pc2NBins; b++) {
                  const lo = b / pc2NBins, hi = (b + 1) / pc2NBins;
                  const inBin = pc2PredPercentiles.map((pp, i) => ({ pp, op: pc2ObsPercentiles[i] })).filter(d => d.pp >= lo && d.pp < hi);
                  if (inBin.length > 0) {
                    pc2Bins.push({
                      pred: inBin.reduce((s, d) => s + d.pp, 0) / inBin.length,
                      obs: inBin.reduce((s, d) => s + d.op, 0) / inBin.length,
                    });
                  }
                }

                // Expected Calibration Error
                const pc2ECE = pc2Bins.length > 0
                  ? pc2Bins.reduce((s, b) => s + Math.abs(b.pred - b.obs), 0) / pc2Bins.length
                  : 0;
                const pc2Cal = pc2ECE < 0.08 ? "Well-calibrated" : pc2ECE < 0.15 ? "Moderate" : "Miscalibrated";
                const pc2CalColor = pc2ECE < 0.08 ? "#22c55e" : pc2ECE < 0.15 ? "#f59e0b" : "#ef4444";

                // SVG layout
                const pc2W = 280, pc2H = 180, pc2Pad = 36;
                const pc2PlotW = pc2W - 2 * pc2Pad, pc2PlotH = pc2H - 2 * pc2Pad;

                return (
                  <div className="card" style={{ marginBottom: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <ScatterChart size={16} style={{ color: "var(--color-primary)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Prediction Calibration</h3>
                      <span className="findings-badge" style={{ background: pc2CalColor + "18", color: pc2CalColor, marginLeft: "auto" }}>
                        ECE: {(pc2ECE * 100).toFixed(1)}%
                      </span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: 8 }}>
                      LOO predicted percentile vs observed — {pc2Cal}
                    </div>
                    <svg width={pc2W} height={pc2H} viewBox={`0 0 ${pc2W} ${pc2H}`} style={{ width: "100%", height: "auto" }}>
                      {/* Grid lines */}
                      {[0, 0.25, 0.5, 0.75, 1].map(v => (
                        <Fragment key={`pc2g${v}`}>
                          <line
                            x1={pc2Pad} y1={pc2Pad + pc2PlotH * (1 - v)}
                            x2={pc2Pad + pc2PlotW} y2={pc2Pad + pc2PlotH * (1 - v)}
                            stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3"
                          />
                          <text x={pc2Pad - 4} y={pc2Pad + pc2PlotH * (1 - v) + 3} fontSize="6" fill="var(--color-text-muted)" textAnchor="end">{(v * 100).toFixed(0)}%</text>
                          <text x={pc2Pad + pc2PlotW * v} y={pc2H - pc2Pad + 12} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">{(v * 100).toFixed(0)}%</text>
                        </Fragment>
                      ))}
                      {/* Perfect calibration line (diagonal) */}
                      <line x1={pc2Pad} y1={pc2Pad + pc2PlotH} x2={pc2Pad + pc2PlotW} y2={pc2Pad} stroke="var(--color-text-muted)" strokeWidth="1" strokeDasharray="4,4" opacity="0.5" />
                      {/* Binned calibration points */}
                      {pc2Bins.map((b, i) => (
                        <circle
                          key={`pc2b${i}`}
                          cx={pc2Pad + b.pred * pc2PlotW}
                          cy={pc2Pad + (1 - b.obs) * pc2PlotH}
                          r="4"
                          fill={pc2CalColor}
                          opacity="0.8"
                          stroke="white"
                          strokeWidth="1"
                        />
                      ))}
                      {/* Calibration line connecting bins */}
                      {pc2Bins.length > 1 && (
                        <polyline
                          points={pc2Bins.map(b => `${pc2Pad + b.pred * pc2PlotW},${pc2Pad + (1 - b.obs) * pc2PlotH}`).join(" ")}
                          fill="none"
                          stroke={pc2CalColor}
                          strokeWidth="1.5"
                          strokeLinejoin="round"
                        />
                      )}
                      {/* Scatter of individual points (faint) */}
                      {pc2PredPercentiles.map((pp, i) => (
                        <circle
                          key={`pc2p${i}`}
                          cx={pc2Pad + pp * pc2PlotW}
                          cy={pc2Pad + (1 - pc2ObsPercentiles[i]) * pc2PlotH}
                          r="1.5"
                          fill="var(--color-primary)"
                          opacity="0.2"
                        />
                      ))}
                      {/* Axis labels */}
                      <text x={pc2Pad + pc2PlotW / 2} y={pc2H - 4} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">Predicted Percentile</text>
                      <text x={8} y={pc2Pad + pc2PlotH / 2} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 8, ${pc2Pad + pc2PlotH / 2})`}>Observed Percentile</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span>σ_residual: {pc2ResStd.toFixed(4)}</span>
                      <span>{pc2Bins.length} bins from {pc2N} points</span>
                    </div>
                  </div>
                );
              })()}

              {/* Uncertainty Evolution Ribbon */}
              {trials.length >= 15 && (() => {
                const ueSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const ueKpiKey = Object.keys(ueSorted[0]?.kpis || {})[0];
                if (!ueKpiKey) return null;
                const ueN = ueSorted.length;
                const ueK = Math.min(5, ueN - 1);
                const ueWinSize = Math.max(5, Math.floor(ueN / 10));

                // For each window, compute average k-NN LOO variance as uncertainty proxy
                const ueWindows: { iter: number; uncertainty: number; bestSoFar: number }[] = [];
                let ueBest = Infinity;
                for (let w = 0; w < ueN - ueWinSize + 1; w += Math.max(1, Math.floor(ueWinSize / 2))) {
                  const winTrials = ueSorted.slice(w, w + ueWinSize);
                  // Compute k-NN LOO variance for each point in window
                  let varSum = 0;
                  for (let i = 0; i < winTrials.length; i++) {
                    const pKeys = Object.keys(winTrials[i].parameters);
                    const dists: { d: number; v: number }[] = [];
                    for (let j = 0; j < winTrials.length; j++) {
                      if (j === i) continue;
                      let dist = 0;
                      for (const pk of pKeys) {
                        const diff = (Number(winTrials[i].parameters[pk]) || 0) - (Number(winTrials[j].parameters[pk]) || 0);
                        dist += diff * diff;
                      }
                      dists.push({ d: Math.sqrt(dist), v: winTrials[j].kpis[ueKpiKey] ?? 0 });
                    }
                    dists.sort((a, b) => a.d - b.d);
                    const neighbors = dists.slice(0, ueK);
                    const nMean = neighbors.reduce((s, n) => s + n.v, 0) / neighbors.length;
                    const nVar = neighbors.reduce((s, n) => s + (n.v - nMean) ** 2, 0) / neighbors.length;
                    varSum += nVar;
                  }
                  const avgVar = varSum / winTrials.length;
                  // Track best so far
                  for (const t of winTrials) {
                    const v = t.kpis[ueKpiKey] ?? 0;
                    if (v < ueBest) ueBest = v;
                  }
                  ueWindows.push({ iter: w + Math.floor(ueWinSize / 2), uncertainty: avgVar, bestSoFar: ueBest });
                }

                if (ueWindows.length < 3) return null;

                const ueMaxUnc = Math.max(...ueWindows.map(w => w.uncertainty)) || 0.001;
                const ueMinUnc = Math.min(...ueWindows.map(w => w.uncertainty));

                // Trend: is uncertainty decreasing?
                const ueFirst3 = ueWindows.slice(0, 3).reduce((s, w) => s + w.uncertainty, 0) / 3;
                const ueLast3 = ueWindows.slice(-3).reduce((s, w) => s + w.uncertainty, 0) / 3;
                const ueReduction = ueFirst3 > 0 ? ((ueFirst3 - ueLast3) / ueFirst3) * 100 : 0;
                const ueLabel = ueReduction > 30 ? "Converging" : ueReduction > 10 ? "Narrowing" : ueReduction > -10 ? "Stable" : "Diverging";
                const ueLabelColor = ueReduction > 30 ? "#22c55e" : ueReduction > 10 ? "#3b82f6" : ueReduction > -10 ? "var(--color-text-muted)" : "#ef4444";

                // SVG
                const ueW = 300, ueH = 120, uePadL = 36, uePadR = 10, uePadT = 10, uePadB = 20;
                const uePlotW = ueW - uePadL - uePadR;
                const uePlotH = ueH - uePadT - uePadB;
                const ueXScale = (i: number) => uePadL + (i / (ueWindows.length - 1)) * uePlotW;
                const ueYScale = (v: number) => uePadT + uePlotH - ((v - ueMinUnc) / (ueMaxUnc - ueMinUnc || 1)) * uePlotH;

                // Build ribbon path (upper = uncertainty, lower = 0 baseline)
                const ueUpperPath = ueWindows.map((w, i) => `${i === 0 ? "M" : "L"}${ueXScale(i).toFixed(1)},${ueYScale(w.uncertainty).toFixed(1)}`).join(" ");
                const ueLowerPath = [...ueWindows].reverse().map((_, i) => `L${ueXScale(ueWindows.length - 1 - i).toFixed(1)},${(uePadT + uePlotH).toFixed(1)}`).join(" ");
                const ueRibbonPath = `${ueUpperPath} ${ueLowerPath} Z`;

                return (
                  <div className="card" style={{ marginBottom: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Wind size={16} style={{ color: "var(--color-primary)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Uncertainty Evolution</h3>
                      <span className="findings-badge" style={{ background: ueLabelColor + "18", color: ueLabelColor, marginLeft: "auto" }}>
                        {ueLabel}
                      </span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: 8 }}>
                      Rolling k-NN LOO variance — {ueReduction > 0 ? `${ueReduction.toFixed(0)}% reduction` : `${Math.abs(ueReduction).toFixed(0)}% increase`}
                    </div>
                    <svg width={ueW} height={ueH} viewBox={`0 0 ${ueW} ${ueH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Grid */}
                      {[0, 0.5, 1].map(f => {
                        const v = ueMinUnc + f * (ueMaxUnc - ueMinUnc);
                        return (
                          <Fragment key={`ueg${f}`}>
                            <line x1={uePadL} y1={ueYScale(v)} x2={uePadL + uePlotW} y2={ueYScale(v)} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                            <text x={uePadL - 4} y={ueYScale(v) + 3} fontSize="6" fill="var(--color-text-muted)" textAnchor="end">{v.toPrecision(2)}</text>
                          </Fragment>
                        );
                      })}
                      {/* Ribbon fill */}
                      <path d={ueRibbonPath} fill="url(#ueGrad)" opacity="0.3" />
                      <defs>
                        <linearGradient id="ueGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor="#ef4444" />
                          <stop offset="50%" stopColor="#f59e0b" />
                          <stop offset="100%" stopColor="#22c55e" />
                        </linearGradient>
                      </defs>
                      {/* Upper line */}
                      <polyline
                        points={ueWindows.map((w, i) => `${ueXScale(i)},${ueYScale(w.uncertainty)}`).join(" ")}
                        fill="none"
                        stroke={ueLabelColor}
                        strokeWidth="1.5"
                        strokeLinejoin="round"
                      />
                      {/* Dots */}
                      {ueWindows.map((w, i) => (
                        <circle key={`ued${i}`} cx={ueXScale(i)} cy={ueYScale(w.uncertainty)} r="2" fill={ueLabelColor} />
                      ))}
                      {/* X axis label */}
                      <text x={uePadL + uePlotW / 2} y={ueH - 2} fontSize="6.5" fill="var(--color-text-muted)" textAnchor="middle">Iteration Window</text>
                      <text x={6} y={uePadT + uePlotH / 2} fontSize="6.5" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 6, ${uePadT + uePlotH / 2})`}>Local Variance</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span>k={ueK} neighbors, {ueWinSize}-trial windows</span>
                      <span>{ueWindows.length} windows</span>
                    </div>
                  </div>
                );
              })()}

              {/* Exploration Density Shift */}
              {trials.length >= 12 && (() => {
                const edSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (edSpecs.length === 0) return null;
                const edSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const edWinSize = Math.max(4, Math.floor(edSorted.length / 4));
                const edWindows: { start: number; end: number; label: string }[] = [];
                for (let i = 0; i <= edSorted.length - edWinSize; i += Math.max(1, Math.floor(edWinSize / 2))) {
                  edWindows.push({ start: i, end: i + edWinSize, label: `W${edWindows.length + 1}` });
                  if (edWindows.length >= 6) break;
                }
                if (edWindows.length < 2) return null;
                // For each window, compute centroid and spread (avg distance to centroid) in normalized space
                const edNorm = (t: Record<string, number>) => edSpecs.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1;
                  return hi > lo ? (Number(t[sp.name]) - lo) / (hi - lo) : 0.5;
                });
                const edMetrics = edWindows.map(w => {
                  const pts = edSorted.slice(w.start, w.end).map(t => edNorm(t.parameters));
                  const d = edSpecs.length;
                  const centroid = Array.from({ length: d }, (_, j) => pts.reduce((s, p) => s + p[j], 0) / pts.length);
                  const spread = pts.reduce((s, p) => s + Math.sqrt(p.reduce((a, v, j) => a + (v - centroid[j]) ** 2, 0)), 0) / pts.length;
                  // Density = inverse of spread (higher = more concentrated)
                  const density = spread > 0 ? 1 / spread : 10;
                  return { label: w.label, spread, density, centroidShift: 0 };
                });
                // Compute centroid shift between consecutive windows
                for (let i = 1; i < edMetrics.length; i++) {
                  const ptsA = edSorted.slice(edWindows[i - 1].start, edWindows[i - 1].end).map(t => edNorm(t.parameters));
                  const ptsB = edSorted.slice(edWindows[i].start, edWindows[i].end).map(t => edNorm(t.parameters));
                  const d = edSpecs.length;
                  const cA = Array.from({ length: d }, (_, j) => ptsA.reduce((s, p) => s + p[j], 0) / ptsA.length);
                  const cB = Array.from({ length: d }, (_, j) => ptsB.reduce((s, p) => s + p[j], 0) / ptsB.length);
                  edMetrics[i].centroidShift = Math.sqrt(cA.reduce((s, v, j) => s + (v - cB[j]) ** 2, 0));
                }
                const edMaxSpread = Math.max(...edMetrics.map(m => m.spread), 0.01);
                const edMaxShift = Math.max(...edMetrics.map(m => m.centroidShift), 0.01);
                const edFirstSpread = (edMetrics[0].spread + (edMetrics[1]?.spread ?? edMetrics[0].spread)) / 2;
                const edLastSpread = (edMetrics[edMetrics.length - 1].spread + (edMetrics[edMetrics.length - 2]?.spread ?? edMetrics[edMetrics.length - 1].spread)) / 2;
                const edTrend = edFirstSpread > 0 ? ((edLastSpread - edFirstSpread) / edFirstSpread * 100) : 0;
                const edLabel = edTrend < -15 ? "Concentrating" : edTrend > 15 ? "Expanding" : "Stable";
                const edColor = edTrend < -15 ? "var(--color-blue)" : edTrend > 15 ? "#22c55e" : "var(--color-text-muted)";
                // Chart dimensions
                const edW = 320, edH = 100, edPadL = 36, edPadR = 10, edPadT = 12, edPadB = 22;
                const edPlotW = edW - edPadL - edPadR;
                const edPlotH = edH - edPadT - edPadB;
                const edBarW = Math.min(20, (edPlotW / edMetrics.length) * 0.6);
                const edGap = edPlotW / edMetrics.length;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <Droplets size={15} style={{ color: "var(--color-primary)" }} />
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Exploration Density Shift</h3>
                      </div>
                      <span className="findings-badge" style={{ background: edColor, color: "#fff" }}>{edLabel} ({edTrend > 0 ? "+" : ""}{edTrend.toFixed(0)}%)</span>
                    </div>
                    <svg width={edW} height={edH} viewBox={`0 0 ${edW} ${edH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Y axis labels */}
                      <text x={edPadL - 4} y={edPadT + 4} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">High</text>
                      <text x={edPadL - 4} y={edPadT + edPlotH} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">Low</text>
                      <text x={edPadL - 2} y={edPadT + edPlotH / 2 + 2} fontSize="5" fill="var(--color-text-muted)" textAnchor="end" transform={`rotate(-90, ${edPadL - 14}, ${edPadT + edPlotH / 2})`}>Spread</text>
                      {/* Bars for spread + dots for centroid shift */}
                      {edMetrics.map((m, i) => {
                        const cx = edPadL + i * edGap + edGap / 2;
                        const barH = (m.spread / edMaxSpread) * edPlotH;
                        const shiftY = edPadT + edPlotH - (m.centroidShift / edMaxShift) * edPlotH * 0.9;
                        const barColor = m.spread / edMaxSpread > 0.6 ? "#22c55e" : m.spread / edMaxSpread > 0.3 ? "var(--color-primary)" : "#f97316";
                        return (
                          <g key={i}>
                            <rect x={cx - edBarW / 2} y={edPadT + edPlotH - barH} width={edBarW} height={barH} rx={2} fill={barColor} opacity={0.7} />
                            {i > 0 && (
                              <line
                                x1={edPadL + (i - 1) * edGap + edGap / 2}
                                y1={edPadT + edPlotH - (edMetrics[i - 1].centroidShift / edMaxShift) * edPlotH * 0.9}
                                x2={cx} y2={shiftY}
                                stroke="#a855f7" strokeWidth="1.2" strokeDasharray="3,2"
                              />
                            )}
                            <circle cx={cx} cy={shiftY} r="2.5" fill="#a855f7" />
                            <text x={cx} y={edPadT + edPlotH + 12} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle">{m.label}</text>
                          </g>
                        );
                      })}
                      {/* Baseline */}
                      <line x1={edPadL} y1={edPadT + edPlotH} x2={edPadL + edPlotW} y2={edPadT + edPlotH} stroke="var(--color-border)" strokeWidth="0.5" />
                    </svg>
                    <div style={{ display: "flex", gap: 16, marginTop: 4, flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "var(--color-primary)", marginRight: 4, verticalAlign: "middle", borderRadius: 2, opacity: 0.7 }} />Spread</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 0, borderTop: "2px dashed #a855f7", marginRight: 4, verticalAlign: "middle" }} />Centroid Shift</span>
                      <span className="efficiency-legend-item" style={{ marginLeft: "auto", fontSize: "0.7rem" }}>{edSpecs.length}D space, {edWindows.length} windows</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Convergence Radar */}
              {trials.length >= 12 && (() => {
                const crSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (crSpecs.length < 3) return null;
                const crMaxParams = Math.min(crSpecs.length, 8);
                const crParams = crSpecs.slice(0, crMaxParams);
                const crSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const crEarlyN = Math.max(4, Math.floor(crSorted.length * 0.3));
                const crLateN = Math.max(4, Math.floor(crSorted.length * 0.3));
                const crEarly = crSorted.slice(0, crEarlyN);
                const crLate = crSorted.slice(-crLateN);
                // Per-parameter: variance ratio = late_var / early_var
                const crVariance = (arr: number[]) => {
                  const m = arr.reduce((a, b) => a + b, 0) / arr.length;
                  return arr.reduce((s, v) => s + (v - m) ** 2, 0) / arr.length;
                };
                const crData = crParams.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1; const range = hi - lo || 1;
                  const earlyNorm = crEarly.map(t => (Number(t.parameters[sp.name]) - lo) / range);
                  const lateNorm = crLate.map(t => (Number(t.parameters[sp.name]) - lo) / range);
                  const earlyVar = crVariance(earlyNorm);
                  const lateVar = crVariance(lateNorm);
                  const ratio = earlyVar > 1e-10 ? lateVar / earlyVar : (lateVar < 1e-10 ? 0 : 2);
                  return { name: sp.name, ratio: Math.min(ratio, 2), converged: ratio < 0.5 };
                });
                const crConvergedCount = crData.filter(d => d.converged).length;
                const crLabel = crConvergedCount === crData.length ? "Fully Converged" : crConvergedCount > crData.length / 2 ? "Converging" : "Exploring";
                const crColor = crConvergedCount === crData.length ? "#22c55e" : crConvergedCount > crData.length / 2 ? "#eab308" : "var(--color-primary)";
                // Radar chart
                const crW = 200, crH = 200;
                const crCx = crW / 2, crCy = crH / 2, crR = 70;
                const crN = crData.length;
                const crAngle = (i: number) => (Math.PI * 2 * i) / crN - Math.PI / 2;
                const crPt = (i: number, r: number) => ({
                  x: crCx + Math.cos(crAngle(i)) * r,
                  y: crCy + Math.sin(crAngle(i)) * r,
                });
                // Grid rings at 0.5, 1.0, 1.5, 2.0
                const crRings = [0.5, 1.0, 1.5, 2.0];
                const crDataPath = crData.map((d, i) => {
                  const p = crPt(i, (d.ratio / 2) * crR);
                  return `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`;
                }).join(" ") + " Z";
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <CircleDot size={15} style={{ color: crColor }} />
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Parameter Convergence</h3>
                      </div>
                      <span className="findings-badge" style={{ background: crColor, color: "#fff" }}>{crLabel} ({crConvergedCount}/{crN})</span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={crW} height={crH} viewBox={`0 0 ${crW} ${crH}`} style={{ maxWidth: "100%" }}>
                        {/* Grid rings */}
                        {crRings.map(ring => {
                          const r = (ring / 2) * crR;
                          const pts = Array.from({ length: crN }, (_, i) => crPt(i, r));
                          const d = pts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") + " Z";
                          return <path key={ring} d={d} fill="none" stroke="var(--color-border)" strokeWidth="0.5" opacity={ring === 1 ? 0.8 : 0.3} />;
                        })}
                        {/* Axis lines */}
                        {crData.map((_, i) => {
                          const p = crPt(i, crR);
                          return <line key={i} x1={crCx} y1={crCy} x2={p.x} y2={p.y} stroke="var(--color-border)" strokeWidth="0.3" />;
                        })}
                        {/* 1.0 reference ring (equal variance) - dashed */}
                        {(() => {
                          const r = 0.5 * crR;
                          const pts = Array.from({ length: crN }, (_, i) => crPt(i, r));
                          const d = pts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") + " Z";
                          return <path d={d} fill="none" stroke="#eab308" strokeWidth="0.8" strokeDasharray="3,2" opacity={0.5} />;
                        })()}
                        {/* Data polygon */}
                        <path d={crDataPath} fill="var(--color-primary)" fillOpacity={0.15} stroke="var(--color-primary)" strokeWidth="1.5" />
                        {/* Data points */}
                        {crData.map((d, i) => {
                          const p = crPt(i, (d.ratio / 2) * crR);
                          return <circle key={i} cx={p.x} cy={p.y} r="3" fill={d.converged ? "#22c55e" : "var(--color-primary)"} stroke="white" strokeWidth="0.8" />;
                        })}
                        {/* Labels */}
                        {crData.map((d, i) => {
                          const p = crPt(i, crR + 14);
                          return (
                            <text key={i} x={p.x} y={p.y} fontSize="5.5" fill={d.converged ? "#22c55e" : "var(--color-text-muted)"} textAnchor="middle" dominantBaseline="middle" fontWeight={d.converged ? "600" : "400"}>
                              {d.name.length > 8 ? d.name.slice(0, 7) + "…" : d.name}
                            </text>
                          );
                        })}
                        {/* Center label */}
                        <text x={crCx} y={crCy - 4} fontSize="5" fill="var(--color-text-muted)" textAnchor="middle">variance</text>
                        <text x={crCx} y={crCy + 4} fontSize="5" fill="var(--color-text-muted)" textAnchor="middle">ratio</text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: 12, justifyContent: "center", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>Inner = converged (&lt;0.5×)</span>
                      <span style={{ color: "#eab308" }}>--- = equal (1.0×)</span>
                      <span>Outer = diverging (&gt;1.0×)</span>
                    </div>
                  </div>
                );
              })()}

              {/* Campaign Coherence Score */}
              {trials.length >= 10 && (() => {
                const ccSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (ccSpecs.length === 0) return null;
                const ccSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const ccN = ccSorted.length;
                const ccKey = Object.keys(ccSorted[0]?.kpis || {})[0];
                if (!ccKey) return null;
                const ccKpis = ccSorted.map(t => Number(t.kpis[ccKey]) || 0);

                // 1. Calibration: LOO k-NN prediction accuracy
                const ccK = Math.min(5, ccN - 1);
                const ccNorms = ccSorted.map(t => {
                  const vals: number[] = [];
                  ccSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                    vals.push(((Number(t.parameters[s.name]) || 0) - (s.lower ?? 0)) / range);
                  });
                  return vals;
                });
                let ccTotalErr = 0;
                for (let i = 0; i < ccN; i++) {
                  const dists = ccNorms.map((v, j) => ({ d: j === i ? Infinity : Math.sqrt(v.reduce((s, x, k) => s + (x - ccNorms[i][k]) ** 2, 0)), j }));
                  dists.sort((a, b) => a.d - b.d);
                  const pred = dists.slice(0, ccK).reduce((s, d) => s + ccKpis[d.j], 0) / ccK;
                  ccTotalErr += Math.abs(pred - ccKpis[i]);
                }
                const ccMAE = ccTotalErr / ccN;
                const ccKpiStd = Math.sqrt(ccKpis.reduce((s, v) => s + (v - ccKpis.reduce((a, b) => a + b, 0) / ccN) ** 2, 0) / ccN) || 1;
                const ccCalibration = Math.max(0, Math.min(1, 1 - ccMAE / ccKpiStd));

                // 2. Exploration balance: novelty of recent 20% vs overall spread
                const ccRecent = ccNorms.slice(-Math.max(5, Math.floor(ccN * 0.2)));
                const ccRecentCentroid = ccRecent[0].map((_, k) => ccRecent.reduce((s, v) => s + v[k], 0) / ccRecent.length);
                const ccAllCentroid = ccNorms[0].map((_, k) => ccNorms.reduce((s, v) => s + v[k], 0) / ccN);
                const ccRecentSpread = ccRecent.reduce((s, v) => s + Math.sqrt(v.reduce((ss, x, k) => ss + (x - ccRecentCentroid[k]) ** 2, 0)), 0) / ccRecent.length;
                const ccAllSpread = ccNorms.reduce((s, v) => s + Math.sqrt(v.reduce((ss, x, k) => ss + (x - ccAllCentroid[k]) ** 2, 0)), 0) / ccN;
                const ccExploration = Math.max(0, Math.min(1, ccRecentSpread / (ccAllSpread || 1)));

                // 3. Convergence: improvement in last 30% vs first 30%
                const cc30 = Math.max(3, Math.floor(ccN * 0.3));
                const ccEarlyBest = Math.min(...ccKpis.slice(0, cc30));
                const ccLateBest = Math.min(...ccKpis.slice(-cc30));
                const ccOverallRange = Math.max(...ccKpis) - Math.min(...ccKpis) || 1;
                const ccConvergence = Math.max(0, Math.min(1, (ccEarlyBest - ccLateBest) / ccOverallRange));

                // Weighted score
                const ccScore = Math.round((ccCalibration * 0.4 + ccExploration * 0.3 + ccConvergence * 0.3) * 100);
                const ccStatus = ccScore >= 70 ? "Healthy" : ccScore >= 40 ? "Investigate" : "Critical";
                const ccStatusColor = ccScore >= 70 ? "var(--color-green, #22c55e)" : ccScore >= 40 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                // Arc drawing helper
                const ccCx = 90, ccCy = 90, ccStartAngle = -210, ccEndAngle = 30;
                const ccArc = (r: number, frac: number) => {
                  const startRad = (ccStartAngle * Math.PI) / 180;
                  const endRad = ((ccStartAngle + (ccEndAngle - ccStartAngle) * frac) * Math.PI) / 180;
                  const x1 = ccCx + r * Math.cos(startRad), y1 = ccCy + r * Math.sin(startRad);
                  const x2 = ccCx + r * Math.cos(endRad), y2 = ccCy + r * Math.sin(endRad);
                  const large = frac > 0.5 ? 1 : 0;
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${r},${r} 0 ${large} 1 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };

                const ccDimensions = [
                  { label: "Calibration", value: ccCalibration, radius: 70, color: "#3b82f6" },
                  { label: "Exploration", value: ccExploration, radius: 55, color: "#8b5cf6" },
                  { label: "Convergence", value: ccConvergence, radius: 40, color: "#10b981" },
                ];

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <HeartPulse size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Campaign Coherence</h3>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: ccStatusColor + "18", color: ccStatusColor }}>{ccStatus} ({ccScore})</span>
                    </div>
                    <div style={{ display: "flex", alignItems: "center", gap: 16 }}>
                      <svg width={180} height={140} viewBox="0 0 180 140" style={{ flexShrink: 0 }}>
                        {/* Background arcs */}
                        {ccDimensions.map((d, i) => (
                          <path key={`bg-${i}`} d={ccArc(d.radius, 1)} fill="none" stroke="var(--color-border)" strokeWidth={8} strokeLinecap="round" />
                        ))}
                        {/* Value arcs */}
                        {ccDimensions.map((d, i) => (
                          <path key={`val-${i}`} d={ccArc(d.radius, Math.max(0.01, d.value))} fill="none" stroke={d.color} strokeWidth={8} strokeLinecap="round" opacity={0.85} />
                        ))}
                        {/* Center score */}
                        <text x={ccCx} y={ccCy - 4} textAnchor="middle" fill={ccStatusColor} fontFamily="var(--font-mono)" fontSize={22} fontWeight={700}>{ccScore}</text>
                        <text x={ccCx} y={ccCy + 12} textAnchor="middle" fill="var(--color-text-muted)" fontSize={9}>/ 100</text>
                      </svg>
                      <div style={{ display: "flex", flexDirection: "column", gap: 8, fontSize: "0.78rem", flex: 1 }}>
                        {ccDimensions.map((d, i) => (
                          <div key={i} style={{ display: "flex", alignItems: "center", gap: 6 }}>
                            <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: d.color, flexShrink: 0 }} />
                            <span style={{ flex: 1 }}>{d.label}</span>
                            <span style={{ fontFamily: "var(--font-mono)", fontWeight: 600, color: d.color }}>{(d.value * 100).toFixed(0)}%</span>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div style={{ display: "flex", gap: 12, marginTop: 8, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>40% calibration + 30% exploration + 30% convergence</span>
                    </div>
                  </div>
                );
              })()}

              {/* Budget Efficiency Waterfall */}
              {trials.length >= 10 && (() => {
                const beSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (beSpecs.length === 0) return null;
                const beSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const beKey = Object.keys(beSorted[0]?.kpis || {})[0];
                if (!beKey) return null;
                const beKpis = beSorted.map(t => Number(t.kpis[beKey]) || 0);
                const beN = beSorted.length;

                // Per-parameter: compute active budget (windows where it varied) and KPI contribution
                const beData = beSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                  const vals = beSorted.map(t => Number(t.parameters[s.name]) || 0);
                  const range = ((s.upper ?? 1) - (s.lower ?? 0)) || 1;
                  // Active budget: count 5-trial windows where param std > 5% of range
                  let activeWindows = 0;
                  const winSize = Math.min(5, beN);
                  for (let i = winSize; i <= beN; i++) {
                    const w = vals.slice(i - winSize, i);
                    const mu = w.reduce((a, b) => a + b, 0) / w.length;
                    const std = Math.sqrt(w.reduce((a, v) => a + (v - mu) ** 2, 0) / w.length);
                    if (std / range > 0.05) activeWindows++;
                  }
                  const budget = activeWindows / Math.max(1, beN - winSize + 1);

                  // KPI contribution: correlation * KPI range improvement
                  const paramNorm = vals.map(v => (v - (s.lower ?? 0)) / range);
                  const kpiMean = beKpis.reduce((a, b) => a + b, 0) / beN;
                  const pMean = paramNorm.reduce((a, b) => a + b, 0) / beN;
                  const cov = paramNorm.reduce((a, v, i) => a + (v - pMean) * (beKpis[i] - kpiMean), 0) / beN;
                  const pStd = Math.sqrt(paramNorm.reduce((a, v) => a + (v - pMean) ** 2, 0) / beN) || 1;
                  const kStd = Math.sqrt(beKpis.reduce((a, v) => a + (v - kpiMean) ** 2, 0) / beN) || 1;
                  const corr = cov / (pStd * kStd);
                  const contribution = Math.abs(corr);

                  const efficiency = budget > 0.01 ? contribution / budget : 0;
                  return { name: s.name, budget, contribution, efficiency };
                }).sort((a: { efficiency: number }, b: { efficiency: number }) => b.efficiency - a.efficiency);

                const beMaxEff = Math.max(...beData.map((d: { efficiency: number }) => d.efficiency), 0.01);
                const beAvgEff = beData.reduce((s: number, d: { efficiency: number }) => s + d.efficiency, 0) / beData.length;
                const beEfficient = beData.filter((d: { efficiency: number }) => d.efficiency > beAvgEff * 1.2).length;
                const beStatus = beEfficient >= beData.length * 0.6 ? "Efficient" : beEfficient >= beData.length * 0.3 ? "Fair" : "Inefficient";
                const beStatusColor = beStatus === "Efficient" ? "var(--color-green, #22c55e)" : beStatus === "Fair" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const beLabelW = 60, beBarW = 200, bePadR = 50;
                const beRowH = 22, beH = beData.length * beRowH + 24;
                const beW = beLabelW + beBarW + bePadR;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <Coins size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Budget Efficiency</h3>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: beStatusColor + "18", color: beStatusColor }}>{beStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      KPI contribution vs exploration budget per parameter. Higher bar = better ROI.
                    </p>
                    <svg width={beW} height={beH} viewBox={`0 0 ${beW} ${beH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {beData.map((d: { name: string; budget: number; contribution: number; efficiency: number }, i: number) => {
                        const y = i * beRowH;
                        const barW = (d.efficiency / beMaxEff) * beBarW;
                        const color = d.efficiency > beAvgEff * 1.2 ? "#22c55e" : d.efficiency > beAvgEff * 0.5 ? "#eab308" : "#ef4444";
                        return (
                          <g key={i}>
                            <text x={beLabelW - 4} y={y + 14} textAnchor="end" fill="var(--color-text)" fontSize={8} fontFamily="var(--font-mono)">{d.name.length > 8 ? d.name.slice(0, 7) + "…" : d.name}</text>
                            <rect x={beLabelW} y={y + 2} width={Math.max(2, barW)} height={beRowH - 6} rx={3} fill={color} opacity={0.65} />
                            {/* Budget indicator (thin line at bottom) */}
                            <rect x={beLabelW} y={y + beRowH - 5} width={d.budget * beBarW} height={2} rx={1} fill="var(--color-primary)" opacity={0.4} />
                            <text x={beLabelW + Math.max(2, barW) + 4} y={y + 14} fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{(d.efficiency * 100).toFixed(0)}%</text>
                          </g>
                        );
                      })}
                      {/* Axis */}
                      <line x1={beLabelW} y1={beH - 16} x2={beLabelW + beBarW} y2={beH - 16} stroke="var(--color-border)" strokeWidth={0.5} />
                      <text x={beLabelW} y={beH - 6} fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">0</text>
                      <text x={beLabelW + beBarW} y={beH - 6} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{(beMaxEff * 100).toFixed(0)}%</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span><span style={{ display: "inline-block", width: 12, height: 3, background: "var(--color-primary)", opacity: 0.4, marginRight: 3, verticalAlign: "middle", borderRadius: 1 }} />budget used</span>
                      <span>{beEfficient}/{beData.length} efficient params</span>
                    </div>
                  </div>
                );
              })()}

              {/* Acquisition Blindspot Detector */}
              {(() => {
                const abTrials = (campaign.observations || []).filter((o: { iteration: number; parameters: Record<string, number>; kpi_values: Record<string, number> }) => o.kpi_values?.objective != null);
                const abParams = (campaign.spec?.parameters || []).filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (abTrials.length < 10 || abParams.length < 2) return null;

                // Normalize all trials into [0,1] space
                const abNorm = abTrials.map((t: { parameters: Record<string, number> }) =>
                  abParams.map((p: { name: string; lower?: number; upper?: number }) => {
                    const lo = p.lower!, hi = p.upper!, range = hi - lo || 1;
                    return ((t.parameters[p.name] ?? lo) - lo) / range;
                  })
                );

                // Create 6×6 grid on top-2-variance parameters (reuse pattern)
                const abVarScores = abParams.map((_p: { name: string; lower?: number; upper?: number }, pi: number) => {
                  const vals = abNorm.map((n: number[]) => n[pi]);
                  const mean = vals.reduce((a: number, b: number) => a + b, 0) / vals.length;
                  return { pi, variance: vals.reduce((a: number, v: number) => a + (v - mean) ** 2, 0) / vals.length };
                }).sort((a: { variance: number }, b: { variance: number }) => b.variance - a.variance);
                const abP0 = abVarScores[0].pi, abP1 = abVarScores[1].pi;

                const abGridN = 6;
                const abCells: { gx: number; gy: number; density: number; variance: number; blindspot: number }[] = [];
                const abKpis = abTrials.map((t: { kpi_values: Record<string, number> }) => t.kpi_values.objective);

                for (let gy = 0; gy < abGridN; gy++) {
                  for (let gx = 0; gx < abGridN; gx++) {
                    const cx = (gx + 0.5) / abGridN, cy = (gy + 0.5) / abGridN;
                    // Count nearby trials (density)
                    let density = 0, localKpis: number[] = [];
                    abNorm.forEach((n: number[], i: number) => {
                      const dx = n[abP0] - cx, dy = n[abP1] - cy;
                      const dist = Math.sqrt(dx * dx + dy * dy);
                      if (dist < 0.25) { density++; localKpis.push(abKpis[i]); }
                    });
                    // Local variance (uncertainty proxy)
                    let variance = 0;
                    if (localKpis.length >= 2) {
                      const m = localKpis.reduce((a, b) => a + b, 0) / localKpis.length;
                      variance = Math.sqrt(localKpis.reduce((a, v) => a + (v - m) ** 2, 0) / localKpis.length);
                    } else {
                      // High uncertainty if no data
                      const globalStd = (() => { const m = abKpis.reduce((a: number, b: number) => a + b, 0) / abKpis.length; return Math.sqrt(abKpis.reduce((a: number, v: number) => a + (v - m) ** 2, 0) / abKpis.length); })();
                      variance = globalStd;
                    }
                    // Blindspot = high variance * low density
                    const maxDensity = abTrials.length / (abGridN * abGridN) * 3;
                    const normDensity = Math.min(density / maxDensity, 1);
                    const blindspot = variance * (1 - normDensity);
                    abCells.push({ gx, gy, density, variance, blindspot });
                  }
                }

                const abMaxBlind = Math.max(...abCells.map(c => c.blindspot), 0.001);
                const abHighCount = abCells.filter(c => c.blindspot / abMaxBlind > 0.6).length;
                const abPct = abHighCount / abCells.length;
                const abStatus = abPct < 0.15 ? "Well Covered" : abPct < 0.3 ? "Some Gaps" : "Blindspots";
                const abColor = abStatus === "Well Covered" ? "var(--color-green, #22c55e)" : abStatus === "Some Gaps" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const abCellW = 36, abCellH = 36;
                const abPadL = 50, abPadT = 10, abPadB = 30;
                const abW = abPadL + abGridN * abCellW + 10;
                const abH = abPadT + abGridN * abCellH + abPadB;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <EyeOff size={15} style={{ color: abColor }} />
                      <h2 style={{ margin: 0 }}>Acquisition Blindspots</h2>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: 8, background: abColor + "18", color: abColor }}>{abStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Regions with high uncertainty but low sampling density. Red = potential blindspots.
                    </p>
                    <svg width={abW} height={abH} viewBox={`0 0 ${abW} ${abH}`} style={{ width: "100%", height: "auto", maxHeight: 260 }}>
                      {abCells.map((c, i) => {
                        const norm = c.blindspot / abMaxBlind;
                        const r = Math.round(norm > 0.6 ? 180 + 75 * norm : 60 * norm);
                        const g = Math.round(norm > 0.6 ? 80 * (1 - norm) : 100 + 100 * (1 - norm));
                        const b = Math.round(norm > 0.3 ? 50 : 180 * (1 - norm));
                        return (
                          <rect key={i} x={abPadL + c.gx * abCellW + 1} y={abPadT + (abGridN - 1 - c.gy) * abCellH + 1} width={abCellW - 2} height={abCellH - 2} rx={3} fill={`rgb(${r},${g},${b})`} opacity={0.85}>
                            <title>{`${abParams[abP0].name}=[${(c.gx / abGridN).toFixed(2)},${((c.gx + 1) / abGridN).toFixed(2)}], ${abParams[abP1].name}=[${(c.gy / abGridN).toFixed(2)},${((c.gy + 1) / abGridN).toFixed(2)}]\nDensity: ${c.density} trials\nBlindspot: ${(norm * 100).toFixed(0)}%`}</title>
                          </rect>
                        );
                      })}
                      {/* Density dots */}
                      {abCells.filter(c => c.density > 0).map((c, i) => (
                        <text key={`d${i}`} x={abPadL + c.gx * abCellW + abCellW / 2} y={abPadT + (abGridN - 1 - c.gy) * abCellH + abCellH / 2 + 4} textAnchor="middle" fontSize={9} fill="white" fontWeight={600} opacity={0.9}>{c.density}</text>
                      ))}
                      {/* Y-axis label */}
                      <text x={abPadL - 4} y={abPadT + abGridN * abCellH / 2} textAnchor="end" fontSize={9} fill="var(--color-text-muted)" transform={`rotate(-90,${abPadL - 4},${abPadT + abGridN * abCellH / 2})`}>{abParams[abP1].name}</text>
                      {/* X-axis label */}
                      <text x={abPadL + abGridN * abCellW / 2} y={abH - 4} textAnchor="middle" fontSize={9} fill="var(--color-text-muted)">{abParams[abP0].name}</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 6 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(30,180,150)" }} /> safe</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(220,60,30)" }} /> blindspot</span>
                      <span style={{ marginLeft: "auto" }}>{abHighCount}/{abCells.length} high-risk cells</span>
                    </div>
                  </div>
                );
              })()}

              {/* Search Concentration — Batch 21 */}
              {trials.length >= 8 && (() => {
                const scSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (scSpecs.length < 2) return null;
                const scSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const scParams = scSpecs.slice(0, 2);
                const scN = 8;
                // Build density grid: count trials per cell
                const scGrid: number[][] = Array.from({ length: scN }, () => Array(scN).fill(0));
                scSorted.forEach(t => {
                  const xSpec = scParams[0];
                  const ySpec = scParams[1];
                  const xv = t.parameters[xSpec.name];
                  const yv = t.parameters[ySpec.name];
                  if (xv == null || yv == null) return;
                  const xi = Math.min(scN - 1, Math.max(0, Math.floor(((xv - xSpec.lower!) / (xSpec.upper! - xSpec.lower!)) * scN)));
                  const yi = Math.min(scN - 1, Math.max(0, Math.floor(((yv - ySpec.lower!) / (ySpec.upper! - ySpec.lower!)) * scN)));
                  scGrid[yi][xi]++;
                });
                const scMax = Math.max(1, ...scGrid.flat());
                // Compute Gini coefficient for concentration
                const scFlat = scGrid.flat().sort((a, b) => a - b);
                const scTotal = scFlat.reduce((s, v) => s + v, 0);
                let scGiniNum = 0;
                scFlat.forEach((v, i) => { scGiniNum += (2 * (i + 1) - scFlat.length - 1) * v; });
                const scGini = scTotal > 0 ? scGiniNum / (scFlat.length * scTotal) : 0;
                // Fraction of cells with zero trials
                const scEmptyFrac = scFlat.filter(v => v === 0).length / scFlat.length;
                const scBadge = scGini < 0.3 ? "Well Spread" : scGini < 0.55 ? "Moderate" : "Concentrated";
                const scBadgeColor = scGini < 0.3 ? "var(--color-green, #22c55e)" : scGini < 0.55 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const scCellSize = 22;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Locate size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Search Concentration</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: scBadgeColor + "18", color: scBadgeColor }}>{scBadge}</span>
                    </div>
                    <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
                      <svg width={scCellSize * scN + 2} height={scCellSize * scN + 2} style={{ flexShrink: 0 }}>
                        {scGrid.map((row, yi) => row.map((count, xi) => {
                          const norm = count / scMax;
                          const r = Math.round(240 - norm * 180);
                          const g = Math.round(240 - norm * 60);
                          const b = Math.round(240 - norm * 180);
                          return (
                            <rect key={`sc-${yi}-${xi}`} x={xi * scCellSize + 1} y={yi * scCellSize + 1} width={scCellSize - 1} height={scCellSize - 1} rx={2} fill={count === 0 ? "var(--color-bg-secondary, #f8f9fa)" : `rgb(${r},${g},${b})`} stroke="var(--color-border)" strokeWidth={0.3}>
                              <title>{scParams[0].name}[{xi}] × {scParams[1].name}[{yi}]: {count} trials</title>
                            </rect>
                          );
                        }))}
                      </svg>
                      <div style={{ flex: 1, fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                        <div style={{ marginBottom: "6px" }}>
                          <span style={{ fontWeight: 600, color: "var(--color-text)" }}>Gini: {scGini.toFixed(2)}</span>
                          <span style={{ marginLeft: "8px" }}>(0 = uniform, 1 = all in one cell)</span>
                        </div>
                        <div style={{ marginBottom: "4px" }}>Empty cells: {(scEmptyFrac * 100).toFixed(0)}% of grid</div>
                        <div style={{ marginBottom: "4px" }}>Peak density: {scMax} trials in hottest cell</div>
                        <div style={{ fontSize: "0.73rem", fontStyle: "italic", marginTop: "6px" }}>
                          {scGini > 0.55 ? "Search is concentrated in a few regions — consider increasing exploration." : scGini > 0.3 ? "Moderate spread — some regions under-explored." : "Good coverage across the search space."}
                        </div>
                      </div>
                    </div>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.7rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      <span>{scParams[0].name} →</span>
                      <span>↓ {scParams[1].name}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Uncertainty Decomposition — Batch 22 */}
              {trials.length >= 12 && (() => {
                const udSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const udKpis = udSorted.map(t => Object.values(t.kpis)[0] ?? 0);
                const udWin = 8;
                const udWindows: { epistemic: number; aleatoric: number; total: number }[] = [];
                for (let i = 0; i <= udKpis.length - udWin; i += Math.max(1, Math.floor(udWin / 2))) {
                  const window = udKpis.slice(i, i + udWin);
                  const mean = window.reduce((s, v) => s + v, 0) / window.length;
                  const totalVar = window.reduce((s, v) => s + (v - mean) ** 2, 0) / window.length;
                  // Aleatoric: average pairwise distance between adjacent trials (measurement noise proxy)
                  let noiseSum = 0;
                  for (let j = 1; j < window.length; j++) noiseSum += (window[j] - window[j - 1]) ** 2;
                  const aleatoric = noiseSum / (2 * (window.length - 1));
                  const epistemic = Math.max(0, totalVar - aleatoric);
                  udWindows.push({ epistemic, aleatoric, total: totalVar });
                }
                if (udWindows.length < 3) return null;
                const udMaxTotal = Math.max(0.0001, ...udWindows.map(w => w.total));
                // Ratio of epistemic to total — higher = model is uncertain (can learn more)
                const udRecentEpi = udWindows.slice(-3).reduce((s, w) => s + w.epistemic, 0) / (3 * Math.max(0.0001, udWindows.slice(-3).reduce((s, w) => s + w.total, 0)));
                const udBadge = udRecentEpi > 0.6 ? "Model-Limited" : udRecentEpi > 0.3 ? "Balanced" : "Noise-Limited";
                const udBadgeColor = udRecentEpi > 0.6 ? "var(--color-blue, #3b82f6)" : udRecentEpi > 0.3 ? "var(--color-green, #22c55e)" : "var(--color-yellow, #eab308)";
                const udW = 240, udH = 80, udPadL = 4, udPadR = 4, udPadT = 6, udPadB = 14;
                const udPlotW = udW - udPadL - udPadR;
                const udPlotH = udH - udPadT - udPadB;
                // Build stacked area paths
                const udPoints = udWindows.map((w, i) => ({
                  x: udPadL + (i / Math.max(1, udWindows.length - 1)) * udPlotW,
                  epiY: udPadT + (1 - w.epistemic / udMaxTotal) * udPlotH,
                  totalY: udPadT + (1 - w.total / udMaxTotal) * udPlotH,
                  baseY: udPadT + udPlotH,
                }));
                // Aleatoric area (bottom): baseY to epiY offset
                const udAleaTop = udPoints.map(p => ({ x: p.x, y: udPadT + (1 - (udWindows[udPoints.indexOf(p)]?.aleatoric ?? 0) / udMaxTotal) * udPlotH }));
                const udAleaPath = `M${udPoints[0].x},${udPoints[0].baseY} ` + udAleaTop.map(p => `L${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") + ` L${udPoints[udPoints.length - 1].x},${udPoints[udPoints.length - 1].baseY} Z`;
                const udTotalPath = `M${udPoints[0].x},${udPoints[0].baseY} ` + udPoints.map(p => `L${p.x.toFixed(1)},${p.totalY.toFixed(1)}`).join(" ") + ` L${udPoints[udPoints.length - 1].x},${udPoints[udPoints.length - 1].baseY} Z`;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Split size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Uncertainty Decomposition</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: udBadgeColor + "18", color: udBadgeColor }}>{udBadge}</span>
                    </div>
                    <svg width={udW} height={udH} style={{ width: "100%", maxWidth: udW }}>
                      <path d={udTotalPath} fill="rgba(59,130,246,0.25)" stroke="none" />
                      <path d={udAleaPath} fill="rgba(234,179,8,0.35)" stroke="none" />
                      {/* Top line */}
                      <path d={udPoints.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.totalY.toFixed(1)}`).join(" ")} fill="none" stroke="var(--color-primary)" strokeWidth={1.2} />
                      <text x={udW / 2} y={udH - 1} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">Window Index</text>
                    </svg>
                    <div style={{ display: "flex", gap: "12px", fontSize: "0.75rem", marginTop: "4px" }}>
                      <span style={{ display: "flex", alignItems: "center", gap: "3px" }}>
                        <span style={{ width: 10, height: 6, background: "rgba(59,130,246,0.3)", display: "inline-block", borderRadius: 1 }} /> Epistemic (model)
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: "3px" }}>
                        <span style={{ width: 10, height: 6, background: "rgba(234,179,8,0.4)", display: "inline-block", borderRadius: 1 }} /> Aleatoric (noise)
                      </span>
                    </div>
                    <div style={{ fontSize: "0.73rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      Epistemic ratio: <strong style={{ color: "var(--color-text)" }}>{(udRecentEpi * 100).toFixed(0)}%</strong>
                      <span style={{ marginLeft: "6px", fontStyle: "italic" }}>
                        {udRecentEpi > 0.6 ? " — model still learning, keep exploring" : udRecentEpi > 0.3 ? " — balanced uncertainty, normal optimization" : " — noise-limited, consider better measurements"}
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Model Distrust Meter */}
              {trials.length >= 15 && (() => {
                const dmSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (dmSpecs.length < 2) return null;
                const dmObjKey = Object.keys(trials[0].kpis)[0];
                const dmSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // compute LOO k-NN predictions for rolling windows
                const dmK = Math.min(5, Math.floor(dmSorted.length / 4));
                const dmNorm = (v: number, lo: number, hi: number) => hi > lo ? (v - lo) / (hi - lo) : 0;
                const dmRanges = dmSpecs.map((s: { name: string; lower?: number; upper?: number }) => ({
                  name: s.name, lo: s.lower!, hi: s.upper!
                }));
                // baseline RMSE: first 60% of trials
                const dmSplit = Math.max(10, Math.floor(dmSorted.length * 0.6));
                const dmBaseline = dmSorted.slice(0, dmSplit);
                const dmRecent = dmSorted.slice(dmSplit);
                const dmPredErr = (pool: typeof dmSorted, test: typeof dmSorted) => {
                  if (pool.length < dmK + 1 || test.length === 0) return 0;
                  let sumSq = 0;
                  for (const t of test) {
                    const dists = pool.filter(p => p !== t).map(p => {
                      let d2 = 0;
                      for (const r of dmRanges) {
                        const a = dmNorm(t.parameters[r.name] ?? 0, r.lo, r.hi);
                        const b = dmNorm(p.parameters[r.name] ?? 0, r.lo, r.hi);
                        d2 += (a - b) ** 2;
                      }
                      return { dist: Math.sqrt(d2), val: p.kpis[dmObjKey] ?? 0 };
                    }).sort((a, b) => a.dist - b.dist);
                    const pred = dists.slice(0, dmK).reduce((s, d) => s + d.val, 0) / dmK;
                    sumSq += (pred - (t.kpis[dmObjKey] ?? 0)) ** 2;
                  }
                  return Math.sqrt(sumSq / test.length);
                };
                const dmBaseRMSE = dmPredErr(dmBaseline, dmBaseline.slice(-Math.min(10, dmBaseline.length)));
                const dmRecentRMSE = dmPredErr(dmSorted, dmRecent);
                // OOD detection: how many recent trials are far from training distribution
                const dmMeanDist = (() => {
                  let sum = 0;
                  for (const t of dmBaseline) {
                    const dists = dmBaseline.filter(p => p !== t).map(p => {
                      let d2 = 0;
                      for (const r of dmRanges) {
                        const a = dmNorm(t.parameters[r.name] ?? 0, r.lo, r.hi);
                        const b = dmNorm(p.parameters[r.name] ?? 0, r.lo, r.hi);
                        d2 += (a - b) ** 2;
                      }
                      return Math.sqrt(d2);
                    });
                    dists.sort((a, b) => a - b);
                    sum += dists[0] ?? 0;
                  }
                  return sum / dmBaseline.length;
                })();
                const dmThreshold = dmMeanDist * 3;
                let dmOOD = 0;
                for (const t of dmRecent) {
                  const minD = Math.min(...dmBaseline.map(p => {
                    let d2 = 0;
                    for (const r of dmRanges) {
                      const a = dmNorm(t.parameters[r.name] ?? 0, r.lo, r.hi);
                      const b = dmNorm(p.parameters[r.name] ?? 0, r.lo, r.hi);
                      d2 += (a - b) ** 2;
                    }
                    return Math.sqrt(d2);
                  }));
                  if (minD > dmThreshold) dmOOD++;
                }
                const dmOODRate = dmRecent.length > 0 ? dmOOD / dmRecent.length : 0;
                // Trust score
                const dmRMSEDrift = dmBaseRMSE > 0 ? Math.abs(dmRecentRMSE - dmBaseRMSE) / dmBaseRMSE : 0;
                const dmTrust = Math.max(0, Math.min(1, 1 - 0.5 * Math.min(1, dmRMSEDrift) - 0.35 * dmOODRate - 0.15 * Math.min(1, dmRecentRMSE * 5)));
                const dmBadge = dmTrust > 0.7 ? "Trustworthy" : dmTrust > 0.4 ? "Caution" : "Unreliable";
                const dmColor = dmTrust > 0.7 ? "var(--color-green, #22c55e)" : dmTrust > 0.4 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Gauge visualization
                const dmW = 220, dmH = 130;
                const dmAngle = Math.PI * (1 - dmTrust);
                const dmCx = dmW / 2, dmCy = dmH - 10;
                const dmR = 80;
                const dmNeedleX = dmCx + dmR * 0.85 * Math.cos(Math.PI - dmAngle);
                const dmNeedleY = dmCy - dmR * 0.85 * Math.sin(Math.PI - dmAngle);
                // Arc segments: red (0-0.4), yellow (0.4-0.7), green (0.7-1.0)
                const dmArc = (start: number, end: number) => {
                  const s = Math.PI - Math.PI * start;
                  const e = Math.PI - Math.PI * end;
                  const x1 = dmCx + dmR * Math.cos(s);
                  const y1 = dmCy - dmR * Math.sin(s);
                  const x2 = dmCx + dmR * Math.cos(e);
                  const y2 = dmCy - dmR * Math.sin(e);
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${dmR},${dmR} 0 0 1 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };
                return (
                  <div className="card" style={{ padding: "20px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "10px", marginBottom: "12px" }}>
                      <Shield size={18} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.95rem" }}>Model Distrust Meter</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: dmColor + "22", color: dmColor }}>{dmBadge}</span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={dmW} height={dmH} viewBox={`0 0 ${dmW} ${dmH}`}>
                        {/* Background arcs */}
                        <path d={dmArc(0, 0.4)} fill="none" stroke="var(--color-red, #ef4444)" strokeWidth="14" strokeLinecap="round" opacity={0.2} />
                        <path d={dmArc(0.4, 0.7)} fill="none" stroke="var(--color-yellow, #eab308)" strokeWidth="14" strokeLinecap="round" opacity={0.2} />
                        <path d={dmArc(0.7, 1.0)} fill="none" stroke="var(--color-green, #22c55e)" strokeWidth="14" strokeLinecap="round" opacity={0.2} />
                        {/* Active arc */}
                        <path d={dmArc(0, dmTrust)} fill="none" stroke={dmColor} strokeWidth="14" strokeLinecap="round" />
                        {/* Needle */}
                        <line x1={dmCx} y1={dmCy} x2={dmNeedleX} y2={dmNeedleY} stroke={dmColor} strokeWidth="2.5" strokeLinecap="round" />
                        <circle cx={dmCx} cy={dmCy} r="5" fill={dmColor} />
                        {/* Score */}
                        <text x={dmCx} y={dmCy - 25} textAnchor="middle" style={{ fontSize: "1.4rem", fontWeight: 700, fontFamily: "var(--font-mono)", fill: dmColor }}>{(dmTrust * 100).toFixed(0)}%</text>
                        <text x={dmCx} y={dmCy - 8} textAnchor="middle" style={{ fontSize: "0.65rem", fill: "var(--color-text-muted)" }}>Trust Score</text>
                        {/* Labels */}
                        <text x="15" y={dmCy - 2} style={{ fontSize: "0.6rem", fill: "var(--color-red, #ef4444)" }}>Low</text>
                        <text x={dmW - 25} y={dmCy - 2} style={{ fontSize: "0.6rem", fill: "var(--color-green, #22c55e)" }}>High</text>
                      </svg>
                    </div>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "8px", marginTop: "8px" }}>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>RMSE Drift</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)", color: dmRMSEDrift > 0.5 ? "var(--color-red, #ef4444)" : "var(--color-text)" }}>{(dmRMSEDrift * 100).toFixed(0)}%</div>
                      </div>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>OOD Rate</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)", color: dmOODRate > 0.3 ? "var(--color-red, #ef4444)" : "var(--color-text)" }}>{(dmOODRate * 100).toFixed(0)}%</div>
                      </div>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>Recent RMSE</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)" }}>{dmRecentRMSE.toFixed(4)}</div>
                      </div>
                    </div>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "8px", textAlign: "center" }}>
                      {dmBadge === "Trustworthy" ? "Model predictions are reliable — proceed with confidence." :
                       dmBadge === "Caution" ? "Model shows some drift — verify critical suggestions manually." :
                       "Model unreliable — consider collecting more data or retraining."}
                    </div>
                  </div>
                );
              })()}

              {/* Generalization Gap Meter — k-fold CV prediction error gap */}
              {(() => {
                const ggObs = campaign.observations || [];
                if (ggObs.length < 8) return null;
                const ggSorted = [...ggObs].sort((a, b) => a.iteration - b.iteration);
                const ggObjKey = Object.keys(ggSorted[0].kpi_values)[0];
                if (!ggObjKey) return null;
                const ggSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (ggSpecs.length === 0) return null;
                // Build feature matrix and target vector
                const ggX = ggSorted.map(o => ggSpecs.map((s: { name: string }) => Number(o.parameters[s.name]) || 0));
                const ggY = ggSorted.map(o => Number(o.kpi_values[ggObjKey]) || 0);
                const ggN = ggX.length;
                // k-fold cross-validation (k=5 or fewer)
                const ggK = Math.min(5, ggN);
                const ggFoldSize = Math.floor(ggN / ggK);
                const ggFoldErrors: number[] = [];
                const ggTrainErrors: number[] = [];
                for (let f = 0; f < ggK; f++) {
                  const ggTestStart = f * ggFoldSize;
                  const ggTestEnd = f === ggK - 1 ? ggN : (f + 1) * ggFoldSize;
                  const ggTrainX: number[][] = [];
                  const ggTrainY: number[] = [];
                  const ggTestX: number[][] = [];
                  const ggTestY: number[] = [];
                  for (let i = 0; i < ggN; i++) {
                    if (i >= ggTestStart && i < ggTestEnd) {
                      ggTestX.push(ggX[i]);
                      ggTestY.push(ggY[i]);
                    } else {
                      ggTrainX.push(ggX[i]);
                      ggTrainY.push(ggY[i]);
                    }
                  }
                  if (ggTrainX.length < 2 || ggTestX.length < 1) continue;
                  // Simple k-NN regression (k=3) for lightweight CV
                  const ggKnn = 3;
                  const ggPredTest = ggTestX.map(tx => {
                    const dists = ggTrainX.map((trx, idx) => ({
                      d: Math.sqrt(trx.reduce((s, v, j) => s + (v - tx[j]) ** 2, 0)),
                      y: ggTrainY[idx],
                    })).sort((a, b) => a.d - b.d);
                    const neighbors = dists.slice(0, Math.min(ggKnn, dists.length));
                    return neighbors.reduce((s, n) => s + n.y, 0) / neighbors.length;
                  });
                  const ggPredTrain = ggTrainX.map(tx => {
                    const dists = ggTrainX.map((trx, idx) => ({
                      d: Math.sqrt(trx.reduce((s, v, j) => s + (v - tx[j]) ** 2, 0)),
                      y: ggTrainY[idx],
                    })).sort((a, b) => a.d - b.d);
                    const neighbors = dists.slice(1, Math.min(ggKnn + 1, dists.length)); // skip self
                    return neighbors.length > 0 ? neighbors.reduce((s, n) => s + n.y, 0) / neighbors.length : ggTrainY[0];
                  });
                  const ggTestErr = Math.sqrt(ggTestY.reduce((s, y, i) => s + (y - ggPredTest[i]) ** 2, 0) / ggTestY.length);
                  const ggTrainErr = Math.sqrt(ggTrainY.reduce((s, y, i) => s + (y - ggPredTrain[i]) ** 2, 0) / ggTrainY.length);
                  ggFoldErrors.push(ggTestErr);
                  ggTrainErrors.push(ggTrainErr);
                }
                if (ggFoldErrors.length < 2) return null;
                const ggAvgTest = ggFoldErrors.reduce((s, v) => s + v, 0) / ggFoldErrors.length;
                const ggAvgTrain = ggTrainErrors.reduce((s, v) => s + v, 0) / ggTrainErrors.length;
                const ggGap = ggAvgTrain > 0 ? ((ggAvgTest - ggAvgTrain) / ggAvgTrain) * 100 : 0;
                const ggBadge = ggGap < 5 ? "Well-Calibrated" : ggGap < 15 ? "Moderate" : "Unreliable";
                const ggBadgeColor = ggGap < 5 ? "var(--color-green, #22c55e)" : ggGap < 15 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Gauge visualization
                const ggW = 280, ggH = 100;
                const ggCx = ggW / 2, ggCy = 85, ggR = 65;
                const ggAngle = Math.min(Math.max(ggGap / 30, 0), 1) * Math.PI; // 0-30% mapped to 0-180deg
                const ggNeedleX = ggCx - ggR * 0.8 * Math.cos(ggAngle);
                const ggNeedleY = ggCy - ggR * 0.8 * Math.sin(ggAngle);
                // Arc segments: 0-5% green, 5-15% yellow, 15-30% red
                const ggArc = (startPct: number, endPct: number) => {
                  const a1 = Math.PI - (startPct / 30) * Math.PI;
                  const a2 = Math.PI - (endPct / 30) * Math.PI;
                  const x1 = ggCx + ggR * Math.cos(a1);
                  const y1 = ggCy - ggR * Math.sin(a1);
                  const x2 = ggCx + ggR * Math.cos(a2);
                  const y2 = ggCy - ggR * Math.sin(a2);
                  return `M ${x1} ${y1} A ${ggR} ${ggR} 0 0 0 ${x2} ${y2}`;
                };
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Cpu size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Generalization Gap Meter</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: ggBadgeColor + "18", color: ggBadgeColor }}>{ggBadge}</span>
                    </div>
                    <svg width={ggW} height={ggH} viewBox={`0 0 ${ggW} ${ggH}`} style={{ display: "block", margin: "0 auto" }}>
                      {/* Gauge arcs */}
                      <path d={ggArc(0, 5)} fill="none" stroke="var(--color-green, #22c55e)" strokeWidth="10" strokeLinecap="round" opacity={0.3} />
                      <path d={ggArc(5, 15)} fill="none" stroke="var(--color-yellow, #eab308)" strokeWidth="10" strokeLinecap="round" opacity={0.3} />
                      <path d={ggArc(15, 30)} fill="none" stroke="var(--color-red, #ef4444)" strokeWidth="10" strokeLinecap="round" opacity={0.3} />
                      {/* Active arc */}
                      <path d={ggArc(0, Math.min(ggGap, 30))} fill="none" stroke={ggBadgeColor} strokeWidth="10" strokeLinecap="round" opacity={0.8} />
                      {/* Needle */}
                      <line x1={ggCx} y1={ggCy} x2={ggNeedleX} y2={ggNeedleY} stroke={ggBadgeColor} strokeWidth="2.5" strokeLinecap="round" />
                      <circle cx={ggCx} cy={ggCy} r="4" fill={ggBadgeColor} />
                      {/* Labels */}
                      <text x={ggCx} y={ggCy - ggR - 8} textAnchor="middle" style={{ fontSize: "1.3rem", fontWeight: 700, fontFamily: "var(--font-mono)", fill: ggBadgeColor }}>{ggGap.toFixed(1)}%</text>
                      <text x={ggCx - ggR + 5} y={ggCy + 5} textAnchor="start" style={{ fontSize: "0.55rem", fill: "var(--color-green, #22c55e)" }}>0%</text>
                      <text x={ggCx + ggR - 5} y={ggCy + 5} textAnchor="end" style={{ fontSize: "0.55rem", fill: "var(--color-red, #ef4444)" }}>30%</text>
                    </svg>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "8px", marginTop: "8px" }}>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>Train RMSE</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)" }}>{ggAvgTrain.toFixed(4)}</div>
                      </div>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>Test RMSE</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)" }}>{ggAvgTest.toFixed(4)}</div>
                      </div>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>{ggK}-Fold CV</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)" }}>{ggFoldErrors.length} folds</div>
                      </div>
                    </div>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "8px", textAlign: "center" }}>
                      {ggBadge === "Well-Calibrated" ? "Model generalizes well — predictions are reliable for unseen experiments." :
                       ggBadge === "Moderate" ? "Some overfitting detected — consider more diverse training data." :
                       "High generalization gap — model may not transfer to new experimental regions."}
                    </div>
                  </div>
                );
              })()}

              {/* Optimization Momentum — second derivative of improvement */}
              {(() => {
                const omObs = campaign.observations || [];
                if (omObs.length < 10) return null;
                const omSorted = [...omObs].sort((a, b) => a.iteration - b.iteration);
                const omObjKey = Object.keys(omSorted[0].kpi_values)[0];
                if (!omObjKey) return null;
                const omDir = campaign.objective_directions?.[omObjKey] === "minimize" ? -1 : 1;
                // Compute best-so-far curve
                let omBest = -Infinity;
                const omBSF: number[] = [];
                for (const o of omSorted) {
                  const v = (Number(o.kpi_values[omObjKey]) || 0) * omDir;
                  if (v > omBest) omBest = v;
                  omBSF.push(omBest);
                }
                // Compute velocity (first derivative) in windows of 5
                const omWinSize = 5;
                const omVelocities: number[] = [];
                for (let i = omWinSize; i < omBSF.length; i++) {
                  omVelocities.push((omBSF[i] - omBSF[i - omWinSize]) / omWinSize);
                }
                if (omVelocities.length < 4) return null;
                // Compute acceleration (second derivative)
                const omAccels: number[] = [];
                for (let i = 1; i < omVelocities.length; i++) {
                  omAccels.push(omVelocities[i] - omVelocities[i - 1]);
                }
                // Recent momentum: average of last 5 accelerations
                const omRecentN = Math.min(5, omAccels.length);
                const omRecent = omAccels.slice(-omRecentN);
                const omAvgAccel = omRecent.reduce((s, v) => s + v, 0) / omRecentN;
                const omAvgVel = omVelocities.slice(-omRecentN).reduce((s, v) => s + v, 0) / omRecentN;
                const omBadge = omAvgAccel > 0.001 ? "Accelerating" : omAvgAccel > -0.001 ? "Steady" : "Decelerating";
                const omBadgeColor = omAvgAccel > 0.001 ? "var(--color-green, #22c55e)" : omAvgAccel > -0.001 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Spark chart of velocity + acceleration
                const omW = 280, omH = 80, omPadL = 8, omPadR = 8, omPadT = 12, omPadB = 18;
                const omPlotW = omW - omPadL - omPadR;
                const omPlotH = omH - omPadT - omPadB;
                const omMaxV = Math.max(...omVelocities.map(Math.abs), 0.001);
                const omVelPts = omVelocities.map((v, i) => ({
                  x: omPadL + (i / (omVelocities.length - 1)) * omPlotW,
                  y: omPadT + (0.5 - (v / omMaxV) * 0.45) * omPlotH + omPlotH * 0.25,
                }));
                const omVelLine = omVelPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // Area fill below velocity
                const omBaseY = omPadT + omPlotH * 0.75;
                const omAreaPath = omVelLine + `L${omVelPts[omVelPts.length - 1].x.toFixed(1)},${omBaseY} L${omVelPts[0].x.toFixed(1)},${omBaseY} Z`;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Waypoints size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Optimization Momentum</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: omBadgeColor + "18", color: omBadgeColor }}>{omBadge}</span>
                    </div>
                    <svg width={omW} height={omH} viewBox={`0 0 ${omW} ${omH}`} style={{ display: "block", margin: "0 auto" }}>
                      <defs>
                        <linearGradient id="omGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor={omBadgeColor} stopOpacity="0.25" />
                          <stop offset="100%" stopColor={omBadgeColor} stopOpacity="0.02" />
                        </linearGradient>
                      </defs>
                      {/* Zero line */}
                      <line x1={omPadL} y1={omBaseY} x2={omW - omPadR} y2={omBaseY} stroke="var(--color-border)" strokeWidth="1" strokeDasharray="4,3" />
                      {/* Area */}
                      <path d={omAreaPath} fill="url(#omGrad)" />
                      {/* Velocity line */}
                      <path d={omVelLine} fill="none" stroke={omBadgeColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      <circle cx={omVelPts[omVelPts.length - 1].x} cy={omVelPts[omVelPts.length - 1].y} r="3.5" fill={omBadgeColor} />
                      {/* Labels */}
                      <text x={omPadL} y={omH - 2} style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Early</text>
                      <text x={omW - omPadR} y={omH - 2} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Recent</text>
                      <text x={omW / 2} y={omH - 2} textAnchor="middle" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Improvement velocity</text>
                    </svg>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px", marginTop: "8px" }}>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>Velocity</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)", color: omAvgVel > 0 ? "var(--color-green, #22c55e)" : "var(--color-text-muted)" }}>{omAvgVel > 0 ? "+" : ""}{omAvgVel.toFixed(5)}/iter</div>
                      </div>
                      <div style={{ textAlign: "center", padding: "6px", background: "var(--color-bg-secondary)", borderRadius: "6px" }}>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>Acceleration</div>
                        <div style={{ fontSize: "0.85rem", fontWeight: 600, fontFamily: "var(--font-mono)", color: omBadgeColor }}>{omAvgAccel > 0 ? "+" : ""}{omAvgAccel.toFixed(5)}</div>
                      </div>
                    </div>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "8px", textAlign: "center" }}>
                      {omBadge === "Accelerating" ? "Improvement rate is increasing — the optimizer is gaining momentum." :
                       omBadge === "Steady" ? "Improvement rate is stable — consistent progress being made." :
                       "Improvement rate is declining — consider changing strategy or expanding search space."}
                    </div>
                  </div>
                );
              })()}

              {/* Feasibility Tracker */}
              {trials.length >= 10 && (() => {
                const ftObjKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!ftObjKey) return null;
                const ftSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Define "infeasible" as bottom 10% performers (simulating constraint violations)
                const ftAllVals = ftSorted.map(t => t.kpis[ftObjKey]);
                const ftSortedVals = [...ftAllVals].sort((a, b) => a - b);
                const ftThreshold = ftSortedVals[Math.floor(ftSortedVals.length * 0.1)];
                // Rolling windows
                const ftWinSize = Math.max(5, Math.floor(ftSorted.length / 8));
                const ftWindows: { start: number; feasibleRate: number }[] = [];
                for (let i = 0; i + ftWinSize <= ftSorted.length; i += Math.max(1, Math.floor(ftWinSize / 2))) {
                  const win = ftSorted.slice(i, i + ftWinSize);
                  const feasible = win.filter(t => t.kpis[ftObjKey] > ftThreshold).length;
                  ftWindows.push({ start: win[0].iteration, feasibleRate: feasible / win.length });
                }
                if (ftWindows.length < 2) return null;
                const ftAvgRate = ftWindows.reduce((s, w) => s + w.feasibleRate, 0) / ftWindows.length;
                const ftRecentRate = ftWindows[ftWindows.length - 1].feasibleRate;
                const ftBadge = ftRecentRate > 0.92 ? "Healthy" : ftRecentRate > 0.8 ? "Caution" : "At Risk";
                const ftBadgeColor = ftRecentRate > 0.92 ? "var(--color-green, #22c55e)" : ftRecentRate > 0.8 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // SVG area chart
                const ftW = 260, ftH = 80, ftPadL = 4, ftPadR = 4, ftPadT = 6, ftPadB = 14;
                const ftPlotW = ftW - ftPadL - ftPadR;
                const ftPlotH = ftH - ftPadT - ftPadB;
                const ftPts = ftWindows.map((w, i) => ({
                  x: ftPadL + (i / Math.max(1, ftWindows.length - 1)) * ftPlotW,
                  y: ftPadT + (1 - w.feasibleRate) * ftPlotH,
                }));
                const ftLine = ftPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const ftArea = ftLine + ` L${ftPts[ftPts.length - 1].x.toFixed(1)},${(ftPadT + ftPlotH).toFixed(1)} L${ftPts[0].x.toFixed(1)},${(ftPadT + ftPlotH).toFixed(1)} Z`;
                // Threshold line at 90%
                const ftThreshY = ftPadT + (1 - 0.9) * ftPlotH;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Flame size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Feasibility Tracker</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: ftBadgeColor + "18", color: ftBadgeColor }}>{ftBadge}</span>
                    </div>
                    <svg width={ftW} height={ftH} style={{ width: "100%", maxWidth: ftW }}>
                      <defs>
                        <linearGradient id="ft-grad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor="var(--color-green, #22c55e)" stopOpacity={0.3} />
                          <stop offset="100%" stopColor="var(--color-green, #22c55e)" stopOpacity={0.02} />
                        </linearGradient>
                      </defs>
                      <path d={ftArea} fill="url(#ft-grad)" />
                      <path d={ftLine} fill="none" stroke="var(--color-green, #22c55e)" strokeWidth={1.5} strokeLinecap="round" />
                      <line x1={ftPadL} x2={ftPadL + ftPlotW} y1={ftThreshY} y2={ftThreshY} stroke="var(--color-red, #ef4444)" strokeWidth={0.8} strokeDasharray="3,2" opacity={0.5} />
                      <text x={ftPadL + ftPlotW - 2} y={ftThreshY - 2} textAnchor="end" fontSize={6.5} fill="var(--color-red, #ef4444)" opacity={0.7}>90%</text>
                      {ftPts.map((p, i) => (
                        <circle key={`ft-pt-${i}`} cx={p.x} cy={p.y} r={i === ftPts.length - 1 ? 3 : 1.5} fill={ftWindows[i].feasibleRate > 0.9 ? "var(--color-green, #22c55e)" : "var(--color-red, #ef4444)"} opacity={0.8}>
                          <title>Window {i + 1}: {(ftWindows[i].feasibleRate * 100).toFixed(0)}% feasible</title>
                        </circle>
                      ))}
                      <text x={ftW / 2} y={ftH - 1} textAnchor="middle" fontSize={7.5} fill="var(--color-text-muted)">Trial Window</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "4px", fontSize: "0.73rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>Avg: <strong style={{ color: "var(--color-text)" }}>{(ftAvgRate * 100).toFixed(0)}%</strong></span>
                      <span style={{ color: ftBadgeColor, fontWeight: 600 }}>Recent: {(ftRecentRate * 100).toFixed(0)}%</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {ftBadge === "Healthy" ? "High feasibility rate — experiments consistently produce valid results." :
                       ftBadge === "Caution" ? "Some infeasible experiments detected — monitor parameter boundaries." :
                       "Significant infeasibility — review constraints and parameter ranges."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Objective Headroom (Batch 27) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 6) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const obs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (obs.length < 6) return null;
                // build best-so-far series
                const ohBest: number[] = [];
                let ohRunBest = -Infinity;
                obs.forEach((o: { kpi_values: Record<string, number> }) => {
                  const v = o.kpi_values[kpiKey];
                  if (v > ohRunBest) ohRunBest = v;
                  ohBest.push(ohRunBest);
                });
                // fit asymptotic model: y = a - b * exp(-c * x)
                // use heuristic: a ≈ extrapolated ceiling, b = a - y0, c from mid-point
                const ohN = ohBest.length;
                const ohY0 = ohBest[0];
                const ohYn = ohBest[ohN - 1];
                // estimate ceiling: if improvement is decelerating, extrapolate
                const ohRecentGain = ohYn - ohBest[Math.max(0, ohN - Math.floor(ohN / 3))];
                const ohEarlyGain = ohBest[Math.floor(ohN / 3)] - ohY0;
                const ohDecelRatio = ohEarlyGain > 0 ? ohRecentGain / ohEarlyGain : 1;
                // ceiling estimate: project remaining gain based on deceleration
                const ohTotalGain = ohYn - ohY0;
                const ohEstCeiling = ohTotalGain > 0 ? ohYn + ohTotalGain * Math.max(0.05, ohDecelRatio) * 0.5 : ohYn * 1.1;
                const ohPctReached = ohEstCeiling !== ohY0
                  ? Math.min(1, Math.max(0, (ohYn - ohY0) / (ohEstCeiling - ohY0)))
                  : 1;
                const ohBadge = ohPctReached > 0.85 ? "Near Ceiling" : ohPctReached > 0.5 ? "Room to Grow" : "Early Stage";
                const ohBadgeColor = ohPctReached > 0.85 ? "var(--color-red, #ef4444)" : ohPctReached > 0.5 ? "var(--color-yellow, #eab308)" : "var(--color-blue, #3b82f6)";
                // gauge arc SVG
                const ohW = 220, ohH = 130;
                const ohCx = ohW / 2, ohCy = 110, ohR = 85;
                const ohStartAngle = Math.PI;
                const ohEndAngle = 0;
                const ohValAngle = ohStartAngle - ohPctReached * Math.PI;
                const ohArcPath = (startA: number, endA: number) => {
                  const x1 = ohCx + ohR * Math.cos(startA);
                  const y1 = ohCy - ohR * Math.sin(startA);
                  const x2 = ohCx + ohR * Math.cos(endA);
                  const y2 = ohCy - ohR * Math.sin(endA);
                  const large = Math.abs(startA - endA) > Math.PI ? 1 : 0;
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${ohR},${ohR} 0 ${large} 0 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };
                const ohNeedleX = ohCx + (ohR - 15) * Math.cos(ohValAngle);
                const ohNeedleY = ohCy - (ohR - 15) * Math.sin(ohValAngle);
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Milestone size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Objective Headroom</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: ohBadgeColor, color: "#fff" }}>{ohBadge}</span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={ohW} height={ohH} viewBox={`0 0 ${ohW} ${ohH}`}>
                        {/* background arc */}
                        <path d={ohArcPath(ohStartAngle, ohEndAngle)} fill="none" stroke="var(--color-border, #e2e8f0)" strokeWidth="14" strokeLinecap="round" />
                        {/* filled arc */}
                        <path d={ohArcPath(ohStartAngle, ohValAngle)} fill="none" stroke={ohBadgeColor} strokeWidth="14" strokeLinecap="round" opacity="0.85" />
                        {/* needle */}
                        <line x1={ohCx} y1={ohCy} x2={ohNeedleX} y2={ohNeedleY} stroke="var(--color-text, #1e293b)" strokeWidth="2" strokeLinecap="round" />
                        <circle cx={ohCx} cy={ohCy} r="4" fill="var(--color-text, #1e293b)" />
                        {/* percentage label */}
                        <text x={ohCx} y={ohCy - 25} textAnchor="middle" fontSize="22" fontWeight="700" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{(ohPctReached * 100).toFixed(0)}%</text>
                        <text x={ohCx} y={ohCy - 8} textAnchor="middle" fontSize="10" fill="var(--color-text-muted, #64748b)">of estimated ceiling</text>
                        {/* scale labels */}
                        <text x={ohCx - ohR - 5} y={ohCy + 14} textAnchor="middle" fontSize="9" fill="var(--color-text-muted, #64748b)">0%</text>
                        <text x={ohCx + ohR + 5} y={ohCy + 14} textAnchor="middle" fontSize="9" fill="var(--color-text-muted, #64748b)">100%</text>
                      </svg>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", textAlign: "center", marginTop: "4px" }}>
                      Current best: {ohYn.toPrecision(4)} · Est. ceiling: {ohEstCeiling.toPrecision(4)}
                    </div>
                  </div>
                );
              })()}

              {/* ── Budget Efficiency Curve (Batch 28) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const beObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (beObs.length < 10) return null;
                // build best-so-far
                const beBest: number[] = [];
                let beRun = -Infinity;
                beObs.forEach((o: { kpi_values: Record<string, number> }) => {
                  const v = o.kpi_values[kpiKey];
                  if (v > beRun) beRun = v;
                  beBest.push(beRun);
                });
                // compute marginal improvement in sliding windows of 5
                const beWin = 5;
                const beEfficiency: number[] = [];
                for (let i = beWin; i < beBest.length; i++) {
                  const gain = beBest[i] - beBest[i - beWin];
                  beEfficiency.push(gain / beWin);
                }
                if (beEfficiency.length < 3) return null;
                // trend: compare last third to first third
                const beThird = Math.max(1, Math.floor(beEfficiency.length / 3));
                const beEarlyAvg = beEfficiency.slice(0, beThird).reduce((s, v) => s + v, 0) / beThird;
                const beLateAvg = beEfficiency.slice(-beThird).reduce((s, v) => s + v, 0) / beThird;
                const beRatio = beEarlyAvg !== 0 ? beLateAvg / beEarlyAvg : beLateAvg > 0 ? 2 : 0;
                const beBadge = beRatio > 1.2 ? "Improving" : beRatio > 0.5 ? "Steady" : "Diminishing";
                const beBadgeColor = beBadge === "Improving" ? "var(--color-green, #22c55e)" : beBadge === "Steady" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // area chart
                const beW = 260, beH = 70;
                const bePad = { l: 5, r: 5, t: 6, b: 14 };
                const bePlotW = beW - bePad.l - bePad.r;
                const bePlotH = beH - bePad.t - bePad.b;
                const beMin = Math.min(...beEfficiency);
                const beMax = Math.max(...beEfficiency);
                const beRange = beMax - beMin || 1;
                const bePoints = beEfficiency.map((v, i) => ({
                  x: bePad.l + (i / (beEfficiency.length - 1)) * bePlotW,
                  y: bePad.t + (1 - (v - beMin) / beRange) * bePlotH,
                }));
                const beLine = bePoints.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const beArea = beLine + ` L${bePoints[bePoints.length - 1].x.toFixed(1)},${bePad.t + bePlotH} L${bePoints[0].x.toFixed(1)},${bePad.t + bePlotH} Z`;
                // zero line
                const beZeroY = beMin < 0 ? bePad.t + (1 - (0 - beMin) / beRange) * bePlotH : bePad.t + bePlotH;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Coins size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Budget Efficiency Curve</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: beBadgeColor, color: "#fff" }}>{beBadge}</span>
                    </div>
                    <svg width={beW} height={beH} viewBox={`0 0 ${beW} ${beH}`} style={{ display: "block", width: "100%" }}>
                      <path d={beArea} fill={beBadgeColor} opacity="0.15" />
                      <path d={beLine} fill="none" stroke={beBadgeColor} strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                      <line x1={bePad.l} y1={beZeroY} x2={beW - bePad.r} y2={beZeroY} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="0.5" strokeDasharray="3,3" />
                      <text x={bePad.l} y={beH - 1} fontSize="8" fill="var(--color-text-muted, #64748b)">trial {beWin + 1}</text>
                      <text x={beW - bePad.r} y={beH - 1} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">trial {beObs.length}</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      Marginal improvement per trial — {beBadge === "Improving" ? "optimizer is becoming more efficient." : beBadge === "Steady" ? "consistent improvement rate." : "returns are diminishing, consider stopping or changing strategy."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Stopping Readiness (Batch 29) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const stObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (stObs.length < 10) return null;
                // 1. Plateau score: how many recent iterations without improvement
                const stBest: number[] = [];
                let stRun = -Infinity;
                stObs.forEach((o: { kpi_values: Record<string, number> }) => {
                  const v = o.kpi_values[kpiKey];
                  if (v > stRun) stRun = v;
                  stBest.push(stRun);
                });
                let stPlateauLen = 0;
                for (let i = stBest.length - 1; i > 0; i--) {
                  if (stBest[i] === stBest[i - 1]) stPlateauLen++;
                  else break;
                }
                const stPlateauScore = Math.min(1, stPlateauLen / (stObs.length * 0.3)); // 1 = long plateau
                // 2. Coverage score: fraction of parameter range explored
                const stSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                let stCoverageScore = 0;
                if (stSpecs.length > 0) {
                  const stCovRatios = stSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    if (range <= 0) return 1;
                    const vals = stObs.map((o: { parameters: Record<string, number> }) => o.parameters[s.name]).filter((v: number) => v != null);
                    if (vals.length === 0) return 0;
                    return (Math.max(...vals) - Math.min(...vals)) / range;
                  });
                  stCoverageScore = stCovRatios.reduce((s: number, v: number) => s + v, 0) / stCovRatios.length;
                }
                // 3. Deceleration score: how much improvement has slowed
                const stThird = Math.max(1, Math.floor(stObs.length / 3));
                const stEarlyGain = stBest[stThird] - stBest[0];
                const stTotalGain = stBest[stBest.length - 1] - stBest[0];
                const stDecelScore = stTotalGain > 0 ? Math.min(1, stEarlyGain / stTotalGain) : 0.5; // high = most gains came early
                // composite
                const stReadiness = stPlateauScore * 0.35 + stCoverageScore * 0.3 + stDecelScore * 0.35;
                const stBadge = stReadiness > 0.7 ? "Ready to Stop" : stReadiness > 0.45 ? "Nearly There" : "Keep Going";
                const stBadgeColor = stBadge === "Ready to Stop" ? "var(--color-green, #22c55e)" : stBadge === "Nearly There" ? "var(--color-yellow, #eab308)" : "var(--color-blue, #3b82f6)";
                // gauge arc (semicircle)
                const stW = 200, stH = 115;
                const stCx = stW / 2, stCy = 100, stR = 75;
                const stValAngle = Math.PI - stReadiness * Math.PI;
                const stArc = (startA: number, endA: number) => {
                  const x1 = stCx + stR * Math.cos(startA), y1 = stCy - stR * Math.sin(startA);
                  const x2 = stCx + stR * Math.cos(endA), y2 = stCy - stR * Math.sin(endA);
                  const lg = Math.abs(startA - endA) > Math.PI ? 1 : 0;
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${stR},${stR} 0 ${lg} 0 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };
                const stNx = stCx + (stR - 12) * Math.cos(stValAngle);
                const stNy = stCy - (stR - 12) * Math.sin(stValAngle);
                // sub-scores for mini bars
                const stScores = [
                  { label: "Plateau", value: stPlateauScore },
                  { label: "Coverage", value: stCoverageScore },
                  { label: "Deceleration", value: stDecelScore },
                ];
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Flag size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Stopping Readiness</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: stBadgeColor, color: "#fff" }}>{stBadge}</span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={stW} height={stH} viewBox={`0 0 ${stW} ${stH}`}>
                        <path d={stArc(Math.PI, 0)} fill="none" stroke="var(--color-border, #e2e8f0)" strokeWidth="12" strokeLinecap="round" />
                        <path d={stArc(Math.PI, stValAngle)} fill="none" stroke={stBadgeColor} strokeWidth="12" strokeLinecap="round" opacity="0.85" />
                        <line x1={stCx} y1={stCy} x2={stNx} y2={stNy} stroke="var(--color-text, #1e293b)" strokeWidth="2" strokeLinecap="round" />
                        <circle cx={stCx} cy={stCy} r="3.5" fill="var(--color-text, #1e293b)" />
                        <text x={stCx} y={stCy - 22} textAnchor="middle" fontSize="20" fontWeight="700" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{(stReadiness * 100).toFixed(0)}%</text>
                        <text x={stCx} y={stCy - 7} textAnchor="middle" fontSize="9" fill="var(--color-text-muted, #64748b)">readiness</text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "12px", justifyContent: "center", marginTop: "4px" }}>
                      {stScores.map(s => (
                        <div key={s.label} style={{ textAlign: "center" }}>
                          <div style={{ width: "50px", height: "4px", background: "var(--color-border, #e2e8f0)", borderRadius: "2px", overflow: "hidden" }}>
                            <div style={{ width: `${s.value * 100}%`, height: "100%", background: stBadgeColor, borderRadius: "2px" }} />
                          </div>
                          <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)", marginTop: "2px" }}>{s.label}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* ── Exploration Debt (Batch 30) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const edVals = campaign.observations.map((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey]).filter((v: number) => v != null);
                if (edVals.length < 10) return null;
                const edGlobalBest = Math.max(...edVals);
                // actual cumulative regret
                const edActual: number[] = [];
                let edCumRegret = 0;
                edVals.forEach(v => { edCumRegret += edGlobalBest - v; edActual.push(edCumRegret); });
                // random baseline: average regret per trial * n
                const edMeanVal = edVals.reduce((s, v) => s + v, 0) / edVals.length;
                const edRandomRegretPerTrial = edGlobalBest - edMeanVal;
                const edRandom = edVals.map((_: number, i: number) => edRandomRegretPerTrial * (i + 1));
                // greedy baseline: sort best-first, cumulative regret
                const edSorted = [...edVals].sort((a, b) => b - a);
                const edGreedy: number[] = [];
                let edGreedyCum = 0;
                edSorted.forEach(v => { edGreedyCum += edGlobalBest - v; edGreedy.push(edGreedyCum); });
                // ratio: actual / random at final point
                const edRatio = edRandom[edRandom.length - 1] > 0 ? edActual[edActual.length - 1] / edRandom[edRandom.length - 1] : 1;
                const edBadge = edRatio < 0.6 ? "Efficient" : edRatio < 0.85 ? "Exploratory" : "Overpaying";
                const edBadgeColor = edBadge === "Efficient" ? "var(--color-green, #22c55e)" : edBadge === "Exploratory" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // chart
                const edW = 260, edH = 75;
                const edPad = { l: 5, r: 5, t: 6, b: 14 };
                const edPlotW = edW - edPad.l - edPad.r;
                const edPlotH = edH - edPad.t - edPad.b;
                const edMaxY = Math.max(edActual[edActual.length - 1], edRandom[edRandom.length - 1], edGreedy[edGreedy.length - 1]);
                const edLine = (arr: number[]) => arr.map((v, i) => {
                  const x = edPad.l + (i / (arr.length - 1)) * edPlotW;
                  const y = edPad.t + (1 - v / (edMaxY || 1)) * edPlotH;
                  return `${i === 0 ? "M" : "L"}${x.toFixed(1)},${y.toFixed(1)}`;
                }).join(" ");
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Banknote size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Exploration Debt</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: edBadgeColor, color: "#fff" }}>{edBadge}</span>
                    </div>
                    <svg width={edW} height={edH} viewBox={`0 0 ${edW} ${edH}`} style={{ display: "block", width: "100%" }}>
                      {/* random baseline */}
                      <path d={edLine(edRandom)} fill="none" stroke="var(--color-text-muted, #94a3b8)" strokeWidth="1" strokeDasharray="4,3" opacity="0.5" />
                      {/* greedy baseline */}
                      <path d={edLine(edGreedy)} fill="none" stroke="var(--color-green, #22c55e)" strokeWidth="1" strokeDasharray="2,2" opacity="0.5" />
                      {/* actual regret */}
                      <path d={edLine(edActual)} fill="none" stroke={edBadgeColor} strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                      {/* legend */}
                      <line x1={edW - 130} y1={edPad.t + 2} x2={edW - 120} y2={edPad.t + 2} stroke={edBadgeColor} strokeWidth="1.8" />
                      <text x={edW - 117} y={edPad.t + 5} fontSize="7" fill="var(--color-text-muted, #64748b)">actual</text>
                      <line x1={edW - 85} y1={edPad.t + 2} x2={edW - 75} y2={edPad.t + 2} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="1" strokeDasharray="4,3" />
                      <text x={edW - 72} y={edPad.t + 5} fontSize="7" fill="var(--color-text-muted, #64748b)">random</text>
                      <line x1={edW - 42} y1={edPad.t + 2} x2={edW - 32} y2={edPad.t + 2} stroke="var(--color-green, #22c55e)" strokeWidth="1" strokeDasharray="2,2" />
                      <text x={edW - 29} y={edPad.t + 5} fontSize="7" fill="var(--color-text-muted, #64748b)">greedy</text>
                      <text x={edPad.l} y={edH - 1} fontSize="8" fill="var(--color-text-muted, #64748b)">1</text>
                      <text x={edW - edPad.r} y={edH - 1} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">{edVals.length}</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      Regret ratio: {(edRatio * 100).toFixed(0)}% of random — {edBadge === "Efficient" ? "exploration budget well spent." : edBadge === "Exploratory" ? "still gathering useful information." : "high exploration cost, consider more exploitation."}
                    </div>
                  </div>
                );
              })()}

              {/* Diversity Decay */}
              {trials.length >= 10 && (() => {
                const ddW = 10;
                const ddKey = Object.keys(trials[0]?.parameters ?? {})[0];
                if (!ddKey) return null;
                const ddParams = Object.keys(trials[0].parameters);
                const ddSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const ddWindows: number[] = [];
                for (let i = 0; i <= ddSorted.length - ddW; i += Math.max(1, Math.floor(ddW / 2))) {
                  const win = ddSorted.slice(i, i + ddW);
                  let ddSum = 0, ddCount = 0;
                  for (let a = 0; a < win.length; a++) {
                    for (let b = a + 1; b < win.length; b++) {
                      let d2 = 0;
                      for (const p of ddParams) {
                        const diff = (win[a].parameters[p] ?? 0) - (win[b].parameters[p] ?? 0);
                        d2 += diff * diff;
                      }
                      ddSum += Math.sqrt(d2);
                      ddCount++;
                    }
                  }
                  ddWindows.push(ddCount > 0 ? ddSum / ddCount : 0);
                }
                if (ddWindows.length < 3) return null;
                const ddMax = Math.max(...ddWindows);
                const ddMin = Math.min(...ddWindows);
                const ddRange = ddMax - ddMin || 1;
                const ddNorm = ddWindows.map(v => (v - ddMin) / ddRange);
                // Trend: compare last quarter to first quarter
                const ddQ = Math.max(1, Math.floor(ddNorm.length / 4));
                const ddEarly = ddNorm.slice(0, ddQ).reduce((a, b) => a + b, 0) / ddQ;
                const ddLate = ddNorm.slice(-ddQ).reduce((a, b) => a + b, 0) / ddQ;
                const ddDelta = ddLate - ddEarly;
                const ddBadge = ddDelta < -0.15 ? "Converging" : ddDelta > 0.15 ? "Expanding" : "Stable";
                const ddColor = ddBadge === "Converging" ? "var(--color-primary)" : ddBadge === "Expanding" ? "var(--color-blue)" : "#eab308";
                const ddW2 = 220, ddH = 48, ddPad = 2;
                const ddPts = ddNorm.map((v, i) => ({
                  x: ddPad + (i / (ddNorm.length - 1)) * (ddW2 - 2 * ddPad),
                  y: ddPad + (1 - v) * (ddH - 2 * ddPad),
                }));
                const ddLine = ddPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const ddArea = ddLine + ` L${ddPts[ddPts.length - 1].x.toFixed(1)},${ddH - ddPad} L${ddPts[0].x.toFixed(1)},${ddH - ddPad} Z`;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Minimize2 size={16} style={{ color: "var(--color-primary)" }} />
                      <strong style={{ fontSize: "0.88rem" }}>Diversity Decay</strong>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "6px", background: ddBadge === "Converging" ? "var(--color-success-bg)" : ddBadge === "Expanding" ? "rgba(59,130,246,0.12)" : "rgba(234,179,8,0.12)", color: ddColor }}>{ddBadge}</span>
                    </div>
                    <svg width={ddW2} height={ddH} viewBox={`0 0 ${ddW2} ${ddH}`} style={{ width: "100%", height: ddH, display: "block" }}>
                      <defs>
                        <linearGradient id="ddGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor={ddColor} stopOpacity="0.25" />
                          <stop offset="100%" stopColor={ddColor} stopOpacity="0.02" />
                        </linearGradient>
                      </defs>
                      <path d={ddArea} fill="url(#ddGrad)" />
                      <path d={ddLine} fill="none" stroke={ddColor} strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                      {ddPts.length > 0 && <circle cx={ddPts[ddPts.length - 1].x} cy={ddPts[ddPts.length - 1].y} r="3" fill={ddColor} />}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      <span>early</span>
                      <span>recent</span>
                    </div>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {ddBadge === "Converging" ? "Search is narrowing — optimizer is focusing on promising regions." : ddBadge === "Expanding" ? "Search is broadening — still exploring widely." : "Diversity is stable — balanced exploration and exploitation."}
                    </div>
                  </div>
                );
              })()}

              {/* Decision Journal */}
              <div className="card decision-journal-card">
                <div className="decision-journal-header" onClick={() => setShowJournal(p => !p)} style={{ cursor: "pointer" }}>
                  <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                    <BookOpen size={16} style={{ color: "var(--color-primary)" }} />
                    <h2 style={{ margin: 0 }}>Decision Journal</h2>
                    {journalEntries.length > 0 && (
                      <span className="journal-count">{journalEntries.length}</span>
                    )}
                  </div>
                  <ChevronRight size={16} style={{ transform: showJournal ? "rotate(90deg)" : "none", transition: "transform 0.2s", color: "var(--color-text-muted)" }} />
                </div>
                {showJournal && (
                  <div className="decision-journal-body">
                    <div className="journal-input-row">
                      <input
                        type="text"
                        className="journal-input"
                        placeholder="Record your reasoning, strategy changes, or observations..."
                        value={journalInput}
                        onChange={(e) => setJournalInput(e.target.value)}
                        onKeyDown={(e) => { if (e.key === "Enter") addJournalEntry(); }}
                      />
                      <button className="btn btn-sm btn-primary" onClick={addJournalEntry} disabled={!journalInput.trim()}>
                        Add
                      </button>
                    </div>
                    {journalEntries.length === 0 ? (
                      <p className="journal-empty">No entries yet. Record your experimental reasoning here for future reference.</p>
                    ) : (
                      <div className="journal-entries">
                        {journalEntries.map((entry) => (
                          <div key={entry.id} className="journal-entry">
                            <div className="journal-entry-meta">
                              <span className="journal-iter">Iter {entry.iteration}</span>
                              <span className="journal-time">{new Date(entry.timestamp).toLocaleDateString()} {new Date(entry.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}</span>
                              <button className="journal-delete" onClick={() => removeJournalEntry(entry.id)} title="Delete entry">
                                <X size={12} />
                              </button>
                            </div>
                            <div className="journal-entry-text">{entry.text}</div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Smart Advisor Panel */}
              {diagnostics && (
                <div className="card advisor-panel">
                  <div className="advisor-header">
                    <Zap size={18} />
                    <h2>What to Do Next</h2>
                  </div>
                  <div className="advisor-insights">
                    {getAdvisorInsights().map((insight, i) => (
                      <div key={i} className={`advisor-insight advisor-insight-${insight.type}`}>
                        <div className="advisor-insight-icon">
                          {insight.type === "success" ? (
                            <CheckCircle size={16} />
                          ) : insight.type === "warning" ? (
                            <AlertTriangle size={16} />
                          ) : (
                            <ArrowRight size={16} />
                          )}
                        </div>
                        <div className="advisor-insight-content">
                          <div className="advisor-insight-title">{insight.title}</div>
                          <div className="advisor-insight-desc">{insight.description}</div>
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="advisor-cta">
                    <button
                      className="btn btn-primary btn-sm"
                      onClick={() => setActiveTab("suggestions")}
                    >
                      <Sparkles size={14} /> Generate Suggestions
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}

          {activeTab === "explore" && (
            <div className="tab-panel">
              <div className="card">
                <h2>Parameter Importance</h2>
                {loadingImportance ? (
                  <div className="loading">Loading importance data...</div>
                ) : importance ? (
                  <RealParameterImportance data={importance.importances} />
                ) : (
                  <p className="empty-state">
                    Parameter importance data unavailable.
                  </p>
                )}
              </div>

              <div className="card">
                <h2>Parameter Space</h2>
                {trials.length > 0 ? (
                  <RealScatterMatrix
                    data={trials.map((t) => ({
                      ...t.parameters,
                      objective: Object.values(t.kpis)[0] ?? 0,
                    }))}
                    parameters={Object.keys(trials[0].parameters)}
                    objectiveName="objective"
                    objectiveDirection="minimize"
                  />
                ) : (
                  <p className="empty-state">
                    No parameter data available for scatter plot.
                  </p>
                )}
              </div>

              {/* Parameter Range Explorer */}
              {trials.length > 0 && campaign.spec?.parameters && (() => {
                const specs = campaign.spec.parameters;
                const rangeData = specs
                  .filter((s) => s.type === "continuous" && s.lower !== undefined && s.upper !== undefined)
                  .map((s) => {
                    const vals = trials.map((t) => Number(t.parameters[s.name]) || 0);
                    const sampledMin = Math.min(...vals);
                    const sampledMax = Math.max(...vals);
                    const fullRange = (s.upper! - s.lower!);
                    const coveragePct = fullRange > 0 ? ((sampledMax - sampledMin) / fullRange) * 100 : 0;
                    const uniqueVals = new Set(vals.map((v) => v.toFixed(4))).size;
                    return { name: s.name, lower: s.lower!, upper: s.upper!, sampledMin, sampledMax, coveragePct, uniqueVals };
                  });

                if (rangeData.length === 0) return null;
                return (
                  <div className="card">
                    <h2>Parameter Range Coverage</h2>
                    <p className="range-desc">
                      How much of each parameter's defined range has been sampled. Low coverage suggests unexplored regions.
                    </p>
                    <div className="range-list">
                      {rangeData.map((r) => (
                        <div key={r.name} className="range-row">
                          <span className="range-name mono">{r.name}</span>
                          <div className="range-track">
                            <div
                              className="range-fill"
                              style={{
                                left: `${((r.sampledMin - r.lower) / (r.upper - r.lower)) * 100}%`,
                                width: `${Math.max(((r.sampledMax - r.sampledMin) / (r.upper - r.lower)) * 100, 2)}%`,
                              }}
                            />
                          </div>
                          <span className="range-pct mono">{r.coveragePct.toFixed(0)}%</span>
                          <span className="range-bounds mono">{r.sampledMin.toFixed(2)}–{r.sampledMax.toFixed(2)}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Boundary Saturation */}
              {trials.length >= 8 && (() => {
                const specs = campaign.spec?.parameters || [];
                const bsData = specs
                  .filter((s: { name: string; lower?: number; upper?: number }) => s.lower != null && s.upper != null && s.upper! > s.lower!)
                  .map((s: { name: string; lower?: number; upper?: number }) => {
                    const vals = trials.map(t => Number(t.parameters[s.name]) || 0);
                    const range = s.upper! - s.lower!;
                    const margin = range * 0.05; // 5% of range = "at boundary"
                    const lowerHits = vals.filter(v => v <= s.lower! + margin).length;
                    const upperHits = vals.filter(v => v >= s.upper! - margin).length;
                    const lowerPct = lowerHits / trials.length;
                    const upperPct = upperHits / trials.length;
                    // Temporal trend: split into halves and check if recent has more boundary hits
                    const half = Math.floor(vals.length / 2);
                    const earlyLower = vals.slice(0, half).filter(v => v <= s.lower! + margin).length / Math.max(half, 1);
                    const lateLower = vals.slice(half).filter(v => v <= s.lower! + margin).length / Math.max(vals.length - half, 1);
                    const earlyUpper = vals.slice(0, half).filter(v => v >= s.upper! - margin).length / Math.max(half, 1);
                    const lateUpper = vals.slice(half).filter(v => v >= s.upper! - margin).length / Math.max(vals.length - half, 1);
                    return { name: s.name, lowerPct, upperPct, total: lowerPct + upperPct, lowerTrend: lateLower - earlyLower, upperTrend: lateUpper - earlyUpper };
                  })
                  .filter((d: { total: number }) => d.total > 0)
                  .sort((a: { total: number }, b: { total: number }) => b.total - a.total);

                if (bsData.length === 0) return null;

                type BsItem = { name: string; lowerPct: number; upperPct: number; total: number; lowerTrend: number; upperTrend: number };
                const bsTyped = bsData as BsItem[];
                const W = 380, rowH = 28, padL = 90, padR = 16, padT = 24, padB = 8;
                const barW = W - padL - padR;
                const H = padT + bsTyped.length * rowH + padB;
                const maxPct = Math.max(...bsTyped.map(d => Math.max(d.lowerPct, d.upperPct)), 0.05);

                const satColor = (pct: number) => {
                  if (pct > 0.2) return "rgba(239,68,68,0.7)";
                  if (pct > 0.1) return "rgba(234,179,8,0.6)";
                  if (pct > 0) return "rgba(59,130,246,0.4)";
                  return "transparent";
                };

                const warningCount = bsTyped.filter(d => d.lowerPct > 0.15 || d.upperPct > 0.15).length;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }}>
                      <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                        <AlertTriangle size={16} style={{ color: warningCount > 0 ? "var(--color-yellow)" : "var(--color-text-muted)" }} />
                        <h2 style={{ margin: 0 }}>Boundary Saturation</h2>
                      </div>
                      {warningCount > 0 && (
                        <span className="findings-badge" style={{ background: "var(--color-yellow-bg)", color: "var(--color-yellow)" }}>
                          {warningCount} param{warningCount > 1 ? "s" : ""} at bounds
                        </span>
                      )}
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      How often trials land near parameter boundaries. High saturation suggests expanding the search range.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Column headers */}
                      <text x={padL + barW * 0.25} y={14} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">Lower</text>
                      <text x={padL + barW * 0.75} y={14} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">Upper</text>
                      {bsTyped.map((d, i) => {
                        const y = padT + i * rowH;
                        const lBarW = (d.lowerPct / maxPct) * (barW / 2 - 8);
                        const uBarW = (d.upperPct / maxPct) * (barW / 2 - 8);
                        return (
                          <Fragment key={d.name}>
                            {/* Param label */}
                            <text x={padL - 6} y={y + rowH / 2 + 3} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text-primary)" style={{ fontWeight: 500 }}>
                              {d.name.length > 10 ? d.name.slice(0, 10) + "…" : d.name}
                            </text>
                            {/* Lower bar */}
                            <rect x={padL} y={y + 4} width={Math.max(lBarW, 0)} height={rowH - 8} rx="3" fill={satColor(d.lowerPct)} />
                            {d.lowerPct > 0 && (
                              <text x={padL + lBarW + 4} y={y + rowH / 2 + 3} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                                {(d.lowerPct * 100).toFixed(0)}%{d.lowerTrend > 0.05 ? " ↑" : d.lowerTrend < -0.05 ? " ↓" : ""}
                              </text>
                            )}
                            {/* Divider */}
                            <line x1={padL + barW / 2} y1={y + 2} x2={padL + barW / 2} y2={y + rowH - 2} stroke="var(--color-border)" strokeWidth="0.5" />
                            {/* Upper bar */}
                            <rect x={padL + barW / 2 + 4} y={y + 4} width={Math.max(uBarW, 0)} height={rowH - 8} rx="3" fill={satColor(d.upperPct)} />
                            {d.upperPct > 0 && (
                              <text x={padL + barW / 2 + 4 + uBarW + 4} y={y + rowH / 2 + 3} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                                {(d.upperPct * 100).toFixed(0)}%{d.upperTrend > 0.05 ? " ↑" : d.upperTrend < -0.05 ? " ↓" : ""}
                              </text>
                            )}
                          </Fragment>
                        );
                      })}
                    </svg>
                  </div>
                );
              })()}

              {/* Local Optima Basin Map */}
              {trials.length >= 12 && (() => {
                const loSpecs = campaign.spec?.parameters || [];
                const loContSpecs = loSpecs.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (loContSpecs.length < 2) return null;
                // Pick top 2 parameters by variance
                const loParamVars = loContSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                  const vals = trials.map(t => Number(t.parameters[s.name]) || 0);
                  const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                  const variance = vals.reduce((a, v) => a + (v - mean) ** 2, 0) / vals.length;
                  return { ...s, variance };
                }).sort((a: { variance: number }, b: { variance: number }) => b.variance - a.variance);
                const loP1 = loParamVars[0] as { name: string; lower: number; upper: number };
                const loP2 = loParamVars[1] as { name: string; lower: number; upper: number };
                const loObjKey = Object.keys(trials[0].kpis)[0];
                const loObjVals = trials.map(t => Number(t.kpis[loObjKey]) || 0);
                const loMin = Math.min(...loObjVals);
                const loMax = Math.max(...loObjVals);
                const loRange = loMax - loMin || 1;

                // Grid-based landscape approximation using IDW interpolation
                const loW = 320, loH = 220, loPad = 40;
                const plotW = loW - 2 * loPad, plotH = loH - 2 * loPad;
                const gridN = 16;
                const loTrialPts = trials.map((t, i) => ({
                  x: (Number(t.parameters[loP1.name]) - loP1.lower) / (loP1.upper - loP1.lower),
                  y: (Number(t.parameters[loP2.name]) - loP2.lower) / (loP2.upper - loP2.lower),
                  z: loObjVals[i],
                }));

                // IDW interpolation on grid
                const loGrid: number[][] = [];
                for (let gy = 0; gy < gridN; gy++) {
                  loGrid[gy] = [];
                  for (let gx = 0; gx < gridN; gx++) {
                    const px = (gx + 0.5) / gridN;
                    const py = (gy + 0.5) / gridN;
                    let wSum = 0, vSum = 0;
                    for (const pt of loTrialPts) {
                      const dist = Math.sqrt((px - pt.x) ** 2 + (py - pt.y) ** 2) + 0.001;
                      const w = 1 / (dist * dist);
                      wSum += w;
                      vSum += w * pt.z;
                    }
                    loGrid[gy][gx] = vSum / wSum;
                  }
                }

                // Find local minima in grid
                const loBasins: { gx: number; gy: number; val: number }[] = [];
                for (let gy = 1; gy < gridN - 1; gy++) {
                  for (let gx = 1; gx < gridN - 1; gx++) {
                    const v = loGrid[gy][gx];
                    const neighbors = [loGrid[gy-1][gx], loGrid[gy+1][gx], loGrid[gy][gx-1], loGrid[gy][gx+1]];
                    if (neighbors.every(n => v <= n)) {
                      loBasins.push({ gx, gy, val: v });
                    }
                  }
                }
                loBasins.sort((a, b) => a.val - b.val);
                const topBasins = loBasins.slice(0, 5);

                // Color function: blue (good) to red (bad)
                const loColor = (v: number) => {
                  const t = loRange > 0 ? (v - loMin) / loRange : 0.5;
                  const r = Math.round(59 + t * 196);
                  const g = Math.round(130 - t * 80);
                  const b = Math.round(246 - t * 196);
                  return `rgb(${r},${g},${b})`;
                };

                const cellW = plotW / gridN;
                const cellH = plotH / gridN;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Layers size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Local Optima Basin Map</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          IDW-interpolated landscape showing {loP1.name} vs {loP2.name}. Cooler = better.
                        </p>
                      </div>
                      {topBasins.length > 0 && (
                        <span className="findings-badge" style={{ marginLeft: "auto" }}>
                          {topBasins.length} basin{topBasins.length !== 1 ? "s" : ""} found
                        </span>
                      )}
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={loW} height={loH} viewBox={`0 0 ${loW} ${loH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Heatmap cells */}
                        {loGrid.flatMap((row, gy) =>
                          row.map((v, gx) => (
                            <rect
                              key={`${gy}-${gx}`}
                              x={loPad + gx * cellW}
                              y={loPad + gy * cellH}
                              width={cellW + 0.5}
                              height={cellH + 0.5}
                              fill={loColor(v)}
                              opacity={0.75}
                            />
                          ))
                        )}
                        {/* Trial points */}
                        {loTrialPts.map((pt, i) => (
                          <circle
                            key={i}
                            cx={loPad + pt.x * plotW}
                            cy={loPad + pt.y * plotH}
                            r={3}
                            fill="none"
                            stroke="rgba(255,255,255,0.7)"
                            strokeWidth={1}
                          />
                        ))}
                        {/* Basin markers */}
                        {topBasins.map((b, i) => {
                          const bx = loPad + (b.gx + 0.5) / gridN * plotW;
                          const by = loPad + (b.gy + 0.5) / gridN * plotH;
                          return (
                            <g key={i}>
                              <circle cx={bx} cy={by} r={8} fill="none" stroke="#fff" strokeWidth={2} strokeDasharray="3,2" />
                              <text x={bx} y={by + 4} textAnchor="middle" fontSize="9" fontWeight="700" fill="#fff">
                                {i + 1}
                              </text>
                            </g>
                          );
                        })}
                        {/* Axes labels */}
                        <text x={loPad + plotW / 2} y={loH - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          {loP1.name}
                        </text>
                        <text x={10} y={loPad + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" transform={`rotate(-90,10,${loPad + plotH / 2})`}>
                          {loP2.name}
                        </text>
                        {/* Axis ticks */}
                        {[0, 0.5, 1].map(f => (
                          <g key={f}>
                            <text x={loPad + f * plotW} y={loPad + plotH + 14} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {(loP1.lower + f * (loP1.upper - loP1.lower)).toPrecision(3)}
                            </text>
                            <text x={loPad - 4} y={loPad + (1 - f) * plotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {(loP2.lower + f * (loP2.upper - loP2.lower)).toPrecision(3)}
                            </text>
                          </g>
                        ))}
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(59,130,246)", marginRight: 4, verticalAlign: "middle" }} />Better (lower)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(255,50,50)", marginRight: 4, verticalAlign: "middle" }} />Worse (higher)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", border: "2px dashed #fff", marginRight: 4, verticalAlign: "middle" }} />Basin center</span>
                    </div>
                  </div>
                );
              })()}

              {/* Prediction Residual Map */}
              {trials.length >= 12 && (() => {
                const prSpecs = campaign.spec?.parameters || [];
                const prContSpecs = prSpecs.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (prContSpecs.length < 2) return null;
                const prObjKey = Object.keys(trials[0].kpis)[0];
                // Pick top 2 parameters by correlation with objective
                const prObjVals = trials.map(t => Number(t.kpis[prObjKey]) || 0);
                const prMeanObj = prObjVals.reduce((a, b) => a + b, 0) / prObjVals.length;
                const prParamCorrs = prContSpecs.map((s: { name: string }) => {
                  const vals = trials.map(t => Number(t.parameters[s.name]) || 0);
                  const meanP = vals.reduce((a, b) => a + b, 0) / vals.length;
                  let num = 0, denP = 0, denO = 0;
                  for (let i = 0; i < vals.length; i++) {
                    const dp = vals[i] - meanP;
                    const doVal = prObjVals[i] - prMeanObj;
                    num += dp * doVal;
                    denP += dp * dp;
                    denO += doVal * doVal;
                  }
                  return { name: s.name, corr: Math.abs(denP > 0 && denO > 0 ? num / Math.sqrt(denP * denO) : 0) };
                }).sort((a: { corr: number }, b: { corr: number }) => b.corr - a.corr);
                const prP1Name = prParamCorrs[0].name;
                const prP2Name = prParamCorrs.length > 1 ? prParamCorrs[1].name : prParamCorrs[0].name;
                const prSpec1 = prContSpecs.find((s: { name: string }) => s.name === prP1Name) as { name: string; lower: number; upper: number };
                const prSpec2 = prContSpecs.find((s: { name: string }) => s.name === prP2Name) as { name: string; lower: number; upper: number };
                if (!prSpec1 || !prSpec2) return null;

                // LOO nearest-neighbor residuals
                const pKeys = Object.keys(trials[0].parameters);
                const prResiduals = trials.map((t, idx) => {
                  const actual = prObjVals[idx];
                  let bestDist = Infinity, predicted = actual;
                  for (let j = 0; j < trials.length; j++) {
                    if (j === idx) continue;
                    let dist = 0;
                    for (const k of pKeys) {
                      const diff = (Number(t.parameters[k]) || 0) - (Number(trials[j].parameters[k]) || 0);
                      dist += diff * diff;
                    }
                    if (dist < bestDist) {
                      bestDist = dist;
                      predicted = prObjVals[j];
                    }
                  }
                  return {
                    x: (Number(t.parameters[prP1Name]) - prSpec1.lower) / (prSpec1.upper - prSpec1.lower),
                    y: (Number(t.parameters[prP2Name]) - prSpec2.lower) / (prSpec2.upper - prSpec2.lower),
                    residual: actual - predicted,
                  };
                });

                const prMaxRes = Math.max(...prResiduals.map(r => Math.abs(r.residual)), 0.001);
                const prW = 320, prH = 240, prPadL = 44, prPadR = 16, prPadT = 16, prPadB = 32;
                const prPlotW = prW - prPadL - prPadR;
                const prPlotH = prH - prPadT - prPadB;

                // Mean absolute residual
                const mae = prResiduals.reduce((s, r) => s + Math.abs(r.residual), 0) / prResiduals.length;

                // Bias: mean residual
                const bias = prResiduals.reduce((s, r) => s + r.residual, 0) / prResiduals.length;
                const biasLabel = Math.abs(bias) < mae * 0.3 ? "Balanced" : bias > 0 ? "Over-predicting" : "Under-predicting";

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <AlertTriangle size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Prediction Residuals</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Where the surrogate over/under-predicts, mapped on {prP1Name} vs {prP2Name}.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        {biasLabel}
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={prW} height={prH} viewBox={`0 0 ${prW} ${prH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Grid */}
                        {[0, 0.5, 1].map(f => (
                          <g key={f}>
                            <line x1={prPadL + f * prPlotW} y1={prPadT} x2={prPadL + f * prPlotW} y2={prPadT + prPlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                            <line x1={prPadL} y1={prPadT + f * prPlotH} x2={prPadL + prPlotW} y2={prPadT + f * prPlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                          </g>
                        ))}
                        {/* Residual points */}
                        {prResiduals.map((r, i) => {
                          const cx = prPadL + r.x * prPlotW;
                          const cy = prPadT + (1 - r.y) * prPlotH;
                          const normRes = r.residual / prMaxRes;
                          // Red = over-prediction (actual > predicted, residual > 0), Blue = under-prediction
                          const color = normRes > 0
                            ? `rgba(239,68,68,${Math.min(Math.abs(normRes) * 0.8 + 0.2, 1)})`
                            : `rgba(59,130,246,${Math.min(Math.abs(normRes) * 0.8 + 0.2, 1)})`;
                          const radius = 3 + Math.abs(normRes) * 4;
                          return (
                            <circle key={i} cx={cx} cy={cy} r={radius} fill={color} stroke="rgba(255,255,255,0.3)" strokeWidth={0.5}>
                              <title>Trial {i}: {prP1Name}={Number(trials[i].parameters[prP1Name]).toPrecision(3)}, {prP2Name}={Number(trials[i].parameters[prP2Name]).toPrecision(3)}, residual={r.residual.toPrecision(3)}</title>
                            </circle>
                          );
                        })}
                        {/* Axis labels */}
                        <text x={prPadL + prPlotW / 2} y={prH - 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          {prP1Name}
                        </text>
                        <text x={10} y={prPadT + prPlotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" transform={`rotate(-90,10,${prPadT + prPlotH / 2})`}>
                          {prP2Name}
                        </text>
                        {/* Tick labels */}
                        {[0, 0.5, 1].map(f => (
                          <g key={f}>
                            <text x={prPadL + f * prPlotW} y={prPadT + prPlotH + 14} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {(prSpec1.lower + f * (prSpec1.upper - prSpec1.lower)).toPrecision(3)}
                            </text>
                            <text x={prPadL - 4} y={prPadT + (1 - f) * prPlotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {(prSpec2.lower + f * (prSpec2.upper - prSpec2.lower)).toPrecision(3)}
                            </text>
                          </g>
                        ))}
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(239,68,68,0.7)", marginRight: 4, verticalAlign: "middle" }} />Over-predicting</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(59,130,246,0.7)", marginRight: 4, verticalAlign: "middle" }} />Under-predicting</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.78rem", color: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>
                        MAE: {mae.toPrecision(3)}
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Lengthscale Adequacy Indicator */}
              {trials.length >= 10 && (() => {
                const laSpecs = campaign.spec?.parameters || [];
                const laContSpecs = laSpecs.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (laContSpecs.length < 2) return null;
                // For each parameter, compute median nearest-neighbor distance
                const laResults = laContSpecs.map((spec: { name: string; lower?: number; upper?: number }) => {
                  const range = (spec.upper ?? 1) - (spec.lower ?? 0);
                  const vals = trials.map(t => Number(t.parameters[spec.name]) || 0);
                  const sorted = [...vals].sort((a, b) => a - b);
                  // Nearest neighbor distances
                  const nnDists: number[] = [];
                  for (let i = 0; i < sorted.length; i++) {
                    let minD = Infinity;
                    if (i > 0) minD = Math.min(minD, sorted[i] - sorted[i - 1]);
                    if (i < sorted.length - 1) minD = Math.min(minD, sorted[i + 1] - sorted[i]);
                    nnDists.push(minD);
                  }
                  nnDists.sort((a, b) => a - b);
                  const medianNN = nnDists[Math.floor(nnDists.length / 2)];
                  const resolution = range > 0 ? medianNN / range : 0;
                  // Critical threshold: ~1/sqrt(n) as rough heuristic for GP resolution
                  const critical = 1 / Math.sqrt(trials.length);
                  const adequate = resolution <= critical;
                  return { name: spec.name, resolution, critical, adequate, range };
                });
                const laAdequateCount = laResults.filter((r: { adequate: boolean }) => r.adequate).length;
                const laMaxRes = Math.max(...laResults.map((r: { resolution: number }) => r.resolution), 0.01);
                const laW = 320, laRowH = 22, laPadL = 80, laPadR = 60, laPadT = 8, laPadB = 20;
                const laH = laPadT + laResults.length * laRowH + laPadB;
                const laPlotW = laW - laPadL - laPadR;
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "flex-start", gap: "10px", marginBottom: "8px" }}>
                      <Ruler size={16} style={{ color: "var(--color-primary)", marginTop: 2 }} />
                      <div style={{ flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Sampling Resolution</h2>
                        <p style={{ margin: "2px 0 0", fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                          Median nearest-neighbor distance per parameter vs. critical threshold.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ background: laAdequateCount === laResults.length ? "rgba(34,197,94,0.12)" : "rgba(234,179,8,0.12)", color: laAdequateCount === laResults.length ? "#22c55e" : "#eab308", border: `1px solid ${laAdequateCount === laResults.length ? "#22c55e44" : "#eab30844"}` }}>
                        {laAdequateCount}/{laResults.length} adequate
                      </span>
                    </div>
                    <svg width={laW} height={laH} viewBox={`0 0 ${laW} ${laH}`} role="img" aria-label="Sampling resolution per parameter" style={{ display: "block" }}>
                      {laResults.map((r: { name: string; resolution: number; critical: number; adequate: boolean }, i: number) => {
                        const y = laPadT + i * laRowH;
                        const barW = Math.max(2, (r.resolution / laMaxRes) * laPlotW);
                        const critX = laPadL + (r.critical / laMaxRes) * laPlotW;
                        const barColor = r.adequate ? "#22c55e" : r.resolution < r.critical * 2 ? "#eab308" : "#ef4444";
                        return (
                          <g key={r.name}>
                            <text x={laPadL - 6} y={y + laRowH / 2 + 3} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text-primary)">{r.name}</text>
                            <rect x={laPadL} y={y + 3} width={laPlotW} height={laRowH - 6} rx={3} fill="var(--color-border)" />
                            <rect x={laPadL} y={y + 3} width={Math.min(barW, laPlotW)} height={laRowH - 6} rx={3} fill={barColor} opacity={0.6}>
                              <title>{r.name}: resolution {(r.resolution * 100).toFixed(1)}% of range (threshold: {(r.critical * 100).toFixed(1)}%)</title>
                            </rect>
                            {/* Critical threshold mark */}
                            <line x1={critX} y1={y + 1} x2={critX} y2={y + laRowH - 1} stroke="var(--color-text-muted)" strokeWidth={1.5} strokeDasharray="3,2" />
                            <text x={laW - laPadR + 6} y={y + laRowH / 2 + 3} fontSize="9" fontFamily="var(--font-mono)" fill={barColor} fontWeight="600">
                              {(r.resolution * 100).toFixed(1)}%
                            </text>
                          </g>
                        );
                      })}
                      {/* Threshold label */}
                      <text x={laPadL + (laResults[0].critical / laMaxRes) * laPlotW} y={laH - 4} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                        threshold
                      </text>
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "#22c55e", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />Adequate</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "#eab308", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />Marginal</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "#ef4444", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />Too coarse</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>Dashed = 1/√n threshold</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Variance Decomposition */}
              {trials.length >= 8 && (() => {
                const vdObjKey = campaign.objective_names?.[0] || Object.keys(trials[0].kpis)[0];
                const vdParams = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (vdParams.length < 2) return null;
                const vdObjVals = trials.map(t => t.kpis[vdObjKey] ?? 0);
                const vdMean = vdObjVals.reduce((a: number, b: number) => a + b, 0) / vdObjVals.length;
                const vdTotalVar = vdObjVals.reduce((a: number, v: number) => a + (v - vdMean) ** 2, 0) / vdObjVals.length;
                if (vdTotalVar < 1e-15) return null;
                const vdK = 5;
                const vdColors = ["#3b82f6", "#14b8a6", "#f59e0b", "#f43f5e", "#8b5cf6", "#06b6d4", "#84cc16"];
                // Compute marginal variance for each parameter
                const vdMarginals: { name: string; variance: number; color: string }[] = [];
                for (let pi = 0; pi < Math.min(vdParams.length, 6); pi++) {
                  const sp = vdParams[pi] as { name: string; lower?: number; upper?: number };
                  const pVals = trials.map(t => t.parameters[sp.name] ?? 0);
                  const sorted = pVals.map((v: number, i: number) => ({ v, obj: vdObjVals[i] })).sort((a: { v: number }, b: { v: number }) => a.v - b.v);
                  const binSize = Math.max(1, Math.floor(sorted.length / vdK));
                  const binMeans: number[] = [];
                  for (let b = 0; b < vdK; b++) {
                    const start = b * binSize;
                    const end = b === vdK - 1 ? sorted.length : (b + 1) * binSize;
                    const slice = sorted.slice(start, end);
                    if (slice.length === 0) continue;
                    binMeans.push(slice.reduce((a: number, c: { obj: number }) => a + c.obj, 0) / slice.length);
                  }
                  const bmMean = binMeans.reduce((a, b) => a + b, 0) / binMeans.length;
                  const margVar = binMeans.reduce((a, v) => a + (v - bmMean) ** 2, 0) / binMeans.length;
                  vdMarginals.push({ name: sp.name, variance: margVar, color: vdColors[pi % vdColors.length] });
                }
                const vdMargSum = vdMarginals.reduce((a, m) => a + m.variance, 0);
                // Interaction: residual not explained by marginals
                const vdInteraction = Math.max(0, vdTotalVar - vdMargSum) * 0.4; // conservative estimate
                const vdResidual = Math.max(0, vdTotalVar - vdMargSum - vdInteraction);
                const vdAll = vdMarginals.reduce((a, m) => a + m.variance, 0) + vdInteraction + vdResidual;
                const vdBarW = 200, vdBarH = 22;
                let vdX = 0;
                const vdSegments = vdMarginals.map(m => {
                  const w = (m.variance / vdAll) * vdBarW;
                  const seg = { x: vdX, w, color: m.color, name: m.name, pct: (m.variance / vdAll) * 100 };
                  vdX += w;
                  return seg;
                });
                const vdIntW = (vdInteraction / vdAll) * vdBarW;
                const vdResW = (vdResidual / vdAll) * vdBarW;
                const vdDominant = vdMarginals.length > 0 && (vdMarginals[0].variance / vdAll) > 0.6 ?
                  vdMarginals.reduce((max, m) => m.variance > max.variance ? m : max) : null;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 10 }}>
                      <PieChart size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Variance Decomposition</h3>
                      {vdDominant && (
                        <span className="findings-badge" style={{ background: "#f59e0b18", color: "#f59e0b", marginLeft: "auto" }}>
                          {vdDominant.name} dominates ({(vdDominant.variance / vdAll * 100).toFixed(0)}%)
                        </span>
                      )}
                    </div>
                    <svg width="100%" viewBox={`0 0 ${vdBarW} ${vdBarH + 30}`} style={{ display: "block" }}>
                      <defs>
                        <pattern id="vd-hatch" patternUnits="userSpaceOnUse" width="5" height="5" patternTransform="rotate(45)">
                          <line x1="0" y1="0" x2="0" y2="5" stroke="#64748b" strokeWidth="1.5" />
                        </pattern>
                      </defs>
                      {/* Stacked bar */}
                      {vdSegments.map((seg, i) => (
                        <rect key={`vds${i}`} x={seg.x} y={0} width={Math.max(seg.w, 0.5)} height={vdBarH} fill={seg.color} rx={i === 0 ? 4 : 0} opacity={0.85} />
                      ))}
                      {/* Interaction segment */}
                      <rect x={vdX} y={0} width={Math.max(vdIntW, 0.5)} height={vdBarH} fill="url(#vd-hatch)" opacity={0.6} />
                      {/* Residual segment */}
                      <rect x={vdX + vdIntW} y={0} width={Math.max(vdResW, 0.5)} height={vdBarH} fill="#e2e8f0" rx={0} />
                      {/* Last segment rounded right */}
                      <rect x={vdBarW - 4} y={0} width={4} height={vdBarH} fill="#e2e8f0" rx={4} />
                      {/* Legend below */}
                      {vdSegments.slice(0, 4).map((seg, i) => (
                        <g key={`vdl${i}`} transform={`translate(${i * 50}, ${vdBarH + 6})`}>
                          <rect x={0} y={0} width={7} height={7} rx={1.5} fill={seg.color} opacity={0.85} />
                          <text x={10} y={6.5} fontSize="5.5" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">{seg.name.length > 6 ? seg.name.slice(0, 6) + ".." : seg.name}</text>
                        </g>
                      ))}
                      {vdIntW > 2 && (
                        <g transform={`translate(${Math.min(vdSegments.length, 4) * 50}, ${vdBarH + 6})`}>
                          <rect x={0} y={0} width={7} height={7} rx={1.5} fill="url(#vd-hatch)" />
                          <text x={10} y={6.5} fontSize="5.5" fill="var(--color-text-muted)">Interactions</text>
                        </g>
                      )}
                    </svg>
                    <div style={{ display: "flex", gap: 12, flexWrap: "wrap", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      {vdSegments.slice(0, 4).map(seg => (
                        <span key={seg.name}><strong style={{ color: seg.color }}>{seg.pct.toFixed(0)}%</strong> {seg.name}</span>
                      ))}
                      {vdIntW > 2 && <span><strong style={{ color: "#64748b" }}>{((vdInteraction / vdAll) * 100).toFixed(0)}%</strong> interactions</span>}
                    </div>
                  </div>
                );
              })()}

              {/* Ensemble Disagreement Map */}
              {trials.length >= 10 && (() => {
                const edSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (edSpecs.length < 2) return null;
                const edObjKey = campaign.objective_names?.[0] || Object.keys(trials[0].kpis)[0];
                // Pick top-2 parameters by variance in objective across quantile bins
                const edVarScores = edSpecs.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const vals = trials.map(t => t.parameters[sp.name] ?? 0);
                  const objs = trials.map(t => t.kpis[edObjKey] ?? 0);
                  const sorted = vals.map((v: number, i: number) => ({ v, o: objs[i] })).sort((a: { v: number }, b: { v: number }) => a.v - b.v);
                  const half = Math.floor(sorted.length / 2);
                  const lo = sorted.slice(0, half).map((s: { o: number }) => s.o);
                  const hi = sorted.slice(half).map((s: { o: number }) => s.o);
                  const loMean = lo.reduce((a: number, b: number) => a + b, 0) / lo.length;
                  const hiMean = hi.reduce((a: number, b: number) => a + b, 0) / hi.length;
                  return { name: sp.name, lo: sp.lower ?? 0, hi: sp.upper ?? 1, score: Math.abs(hiMean - loMean) };
                }).sort((a: { score: number }, b: { score: number }) => b.score - a.score);
                const edP1 = edVarScores[0], edP2 = edVarScores[1];
                // Build 10x10 grid of LOO disagreement
                const edG = 10;
                const edGrid: number[][] = Array.from({ length: edG }, () => Array(edG).fill(0));
                const edNorm = (v: number, lo: number, hi: number) => hi > lo ? (v - lo) / (hi - lo) : 0.5;
                // For each grid cell, compute LOO prediction disagreement (std of k-nearest preds)
                const edK = 5;
                for (let gi = 0; gi < edG; gi++) {
                  for (let gj = 0; gj < edG; gj++) {
                    const cx = (gi + 0.5) / edG;
                    const cy = (gj + 0.5) / edG;
                    // Find k nearest trials
                    const dists = trials.map((t, idx) => ({
                      idx,
                      d: Math.sqrt((edNorm(t.parameters[edP1.name], edP1.lo, edP1.hi) - cx) ** 2 + (edNorm(t.parameters[edP2.name], edP2.lo, edP2.hi) - cy) ** 2),
                      obj: t.kpis[edObjKey] ?? 0,
                    })).sort((a, b) => a.d - b.d).slice(0, edK);
                    // LOO predictions: each point predicts using remaining k-1
                    const preds: number[] = [];
                    for (let li = 0; li < dists.length; li++) {
                      const others = dists.filter((_, j) => j !== li);
                      const wSum = others.reduce((a, o) => a + 1 / Math.max(o.d, 0.01), 0);
                      const pred = others.reduce((a, o) => a + (o.obj / Math.max(o.d, 0.01)), 0) / Math.max(wSum, 1e-10);
                      preds.push(pred);
                    }
                    const predMean = preds.reduce((a, b) => a + b, 0) / preds.length;
                    const disagreement = Math.sqrt(preds.reduce((a, v) => a + (v - predMean) ** 2, 0) / preds.length);
                    edGrid[gi][gj] = disagreement;
                  }
                }
                const edMax = Math.max(...edGrid.flat(), 1e-10);
                const edAvg = edGrid.flat().reduce((a, b) => a + b, 0) / (edG * edG);
                const edCellW = 14, edCellH = 14;
                const edSvgW = edG * edCellW + 30, edSvgH = edG * edCellH + 25;
                const edOx = 25, edOy = 5;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Grid3x3 size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Model Disagreement</h3>
                      <span className="findings-badge" style={{ background: edAvg / edMax > 0.5 ? "#8b5cf618" : "#22c55e18", color: edAvg / edMax > 0.5 ? "#8b5cf6" : "#22c55e", marginLeft: "auto" }}>
                        avg {((edAvg / edMax) * 100).toFixed(0)}% disagreement
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${edSvgW} ${edSvgH}`} style={{ display: "block" }}>
                      {/* Heatmap cells */}
                      {edGrid.map((row, gi) => row.map((val, gj) => {
                        const intensity = val / edMax;
                        const r = Math.round(255 * intensity);
                        const g = Math.round(255 * (1 - intensity * 0.7));
                        const b = Math.round(180 + 75 * intensity);
                        return (
                          <rect key={`ed${gi}-${gj}`} x={edOx + gi * edCellW} y={edOy + (edG - 1 - gj) * edCellH} width={edCellW - 1} height={edCellH - 1} rx={2} fill={`rgb(${r},${g},${b})`} opacity={0.8} />
                        );
                      }))}
                      {/* Observation dots */}
                      {trials.slice(-40).map((t, i) => {
                        const nx = edNorm(t.parameters[edP1.name], edP1.lo, edP1.hi);
                        const ny = edNorm(t.parameters[edP2.name], edP2.lo, edP2.hi);
                        return <circle key={`edo${i}`} cx={edOx + nx * edG * edCellW} cy={edOy + (1 - ny) * edG * edCellH} r="1.8" fill="white" stroke="#333" strokeWidth="0.5" />;
                      })}
                      {/* Axis labels */}
                      <text x={edOx + edG * edCellW / 2} y={edSvgH - 1} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">{edP1.name}</text>
                      <text x={3} y={edOy + edG * edCellH / 2} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 3, ${edOy + edG * edCellH / 2})`}>{edP2.name}</text>
                    </svg>
                    <div style={{ display: "flex", gap: 8, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(255,76,255)" }} /> High
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(128,191,218)" }} /> Medium
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(0,255,180)" }} /> Low
                      </span>
                      <span style={{ marginLeft: "auto" }}>LOO cross-validation on {edK}-NN</span>
                    </div>
                  </div>
                );
              })()}

              {/* Response Surface Curvature */}
              {trials.length >= 12 && (() => {
                const rcSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rcSpecs.length === 0) return null;
                const rcKpi = Object.keys(trials[0]?.kpis || {})[0];
                if (!rcKpi) return null;

                // For each parameter, estimate curvature using binned 2nd-order finite differences
                const rcData = rcSpecs.slice(0, 8).map((s: { name: string; lower?: number; upper?: number }) => {
                  const lo = s.lower ?? 0, hi = s.upper ?? 1;
                  const range = hi - lo || 1;
                  const nBins = 5;
                  const binWidth = range / nBins;
                  // Bin trials by parameter value, compute mean kpi per bin
                  const bins: { sum: number; count: number }[] = Array.from({ length: nBins }, () => ({ sum: 0, count: 0 }));
                  for (const t of trials) {
                    const v = Number(t.parameters[s.name]) || 0;
                    const bi = Math.min(nBins - 1, Math.max(0, Math.floor((v - lo) / binWidth)));
                    bins[bi].sum += Number(t.kpis[rcKpi]) || 0;
                    bins[bi].count++;
                  }
                  const binMeans = bins.map(b => b.count > 0 ? b.sum / b.count : NaN);
                  // Compute average absolute 2nd derivative (curvature proxy)
                  let curvSum = 0, curvCount = 0;
                  for (let i = 1; i < nBins - 1; i++) {
                    if (!isNaN(binMeans[i - 1]) && !isNaN(binMeans[i]) && !isNaN(binMeans[i + 1])) {
                      const d2 = Math.abs(binMeans[i + 1] - 2 * binMeans[i] + binMeans[i - 1]);
                      curvSum += d2;
                      curvCount++;
                    }
                  }
                  const curvature = curvCount > 0 ? curvSum / curvCount : 0;
                  return { name: s.name, curvature, binMeans };
                });

                const rcMax = Math.max(...rcData.map(d => d.curvature), 0.001);
                const rcW = 260, rcH = 22 * rcData.length + 28;
                const rcPadL = 80, rcPadR = 50, rcPadT = 4;
                const rcBarH = 14;
                const rcPlotW = rcW - rcPadL - rcPadR;

                const rcHighCurv = rcData.filter(d => d.curvature / rcMax > 0.6).length;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Aperture size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Response Surface Curvature</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Estimated 2nd-derivative magnitude per parameter. High curvature = nonlinear response.
                        </p>
                      </div>
                      {rcHighCurv > 0 && (
                        <span className="findings-badge" style={{ marginLeft: "auto", color: "#8b5cf6", borderColor: "rgba(139,92,246,0.3)" }}>
                          {rcHighCurv} nonlinear
                        </span>
                      )}
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={rcW} height={rcH} viewBox={`0 0 ${rcW} ${rcH}`} style={{ display: "block", margin: "0 auto" }}>
                        {rcData.map((d, i) => {
                          const y = rcPadT + i * 22;
                          const barW = (d.curvature / rcMax) * rcPlotW;
                          const color = d.curvature / rcMax > 0.6 ? "#8b5cf6" : d.curvature / rcMax > 0.3 ? "#3b82f6" : "var(--color-text-muted)";
                          return (
                            <g key={i}>
                              <text x={rcPadL - 6} y={y + rcBarH / 2 + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fontWeight={d.curvature / rcMax > 0.6 ? 600 : 400} fill={color}>
                                {d.name.length > 10 ? d.name.slice(0, 9) + "…" : d.name}
                              </text>
                              <rect x={rcPadL} y={y} width={rcPlotW} height={rcBarH} rx={3} fill="var(--color-border)" opacity={0.3} />
                              <rect x={rcPadL} y={y} width={Math.max(2, barW)} height={rcBarH} rx={3} fill={color} opacity={0.6} />
                              <text x={rcPadL + Math.max(2, barW) + 4} y={y + rcBarH / 2 + 3} fontSize="8" fill={color} fontFamily="var(--font-mono)" fontWeight={500}>
                                {d.curvature.toFixed(4)}
                              </text>
                            </g>
                          );
                        })}
                        {/* X axis label */}
                        <text x={rcPadL + rcPlotW / 2} y={rcH - 2} textAnchor="middle" fontSize="7" fill="var(--color-text-muted)">|d²f/dx²| (binned finite difference)</text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "#8b5cf6", marginRight: 4, verticalAlign: "middle", borderRadius: 2, opacity: 0.6 }} />Nonlinear</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "#3b82f6", marginRight: 4, verticalAlign: "middle", borderRadius: 2, opacity: 0.6 }} />Moderate</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "var(--color-text-muted)", marginRight: 4, verticalAlign: "middle", borderRadius: 2, opacity: 0.6 }} />Linear</span>
                    </div>
                  </div>
                );
              })()}

              {/* Marginal Response Profiles */}
              {trials.length >= 8 && (() => {
                const mrSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (mrSpecs.length === 0) return null;
                const mrKpiKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!mrKpiKey) return null;
                const mrParams = mrSpecs.slice(0, 6); // Up to 6 parameters
                const mrNBins = 5;

                // For each parameter, bin trials and compute mean + stderr of KPI
                const mrProfiles = mrParams.map((spec: { name: string; lower?: number; upper?: number }) => {
                  const lo = spec.lower!;
                  const hi = spec.upper!;
                  const range = hi - lo || 1;
                  const bins: { center: number; mean: number; stderr: number; count: number }[] = [];
                  for (let b = 0; b < mrNBins; b++) {
                    const bLo = lo + (b / mrNBins) * range;
                    const bHi = lo + ((b + 1) / mrNBins) * range;
                    const bCenter = (bLo + bHi) / 2;
                    const inBin = trials.filter(t => {
                      const v = Number(t.parameters[spec.name]) ?? 0;
                      return v >= bLo && v < bHi;
                    }).map(t => t.kpis[mrKpiKey] ?? 0);
                    if (inBin.length > 0) {
                      const mean = inBin.reduce((a, b2) => a + b2, 0) / inBin.length;
                      const variance = inBin.length > 1 ? inBin.reduce((s, v) => s + (v - mean) ** 2, 0) / (inBin.length - 1) : 0;
                      bins.push({ center: bCenter, mean, stderr: Math.sqrt(variance / inBin.length), count: inBin.length });
                    }
                  }
                  // Compute monotonicity score
                  let mrMono = 0;
                  if (bins.length > 1) {
                    let ups = 0, downs = 0;
                    for (let i2 = 1; i2 < bins.length; i2++) {
                      if (bins[i2].mean > bins[i2 - 1].mean) ups++;
                      else if (bins[i2].mean < bins[i2 - 1].mean) downs++;
                    }
                    mrMono = Math.max(ups, downs) / (bins.length - 1);
                  }
                  return { name: spec.name, bins, lo, hi, monotonicity: mrMono };
                });

                // SVG layout: small multiples
                const mrColW = 130, mrColH = 80, mrPad = 20, mrPadB = 16;
                const mrCols = Math.min(mrProfiles.length, 3);
                const mrRows = Math.ceil(mrProfiles.length / mrCols);
                const mrW = mrCols * mrColW + mrPad;
                const mrH = mrRows * mrColH + mrPad;

                // Global KPI range for consistent y-axis
                const mrAllMeans = mrProfiles.flatMap(p => p.bins.map(b => b.mean));
                const mrAllErrs = mrProfiles.flatMap(p => p.bins.map(b => b.stderr));
                const mrYMin = Math.min(...mrAllMeans.map((m, i) => m - mrAllErrs[i]));
                const mrYMax = Math.max(...mrAllMeans.map((m, i) => m + mrAllErrs[i]));
                const mrYRange = mrYMax - mrYMin || 1;

                const mrMonotonic = mrProfiles.filter(p => p.monotonicity > 0.8).length;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <AlignVerticalJustifyStart size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Marginal Response Profiles</h2>
                        <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)" }}>1D binned response per parameter</div>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        {mrMonotonic} monotonic
                      </span>
                    </div>
                    <svg width={mrW} height={mrH} viewBox={`0 0 ${mrW} ${mrH}`} style={{ width: "100%", height: "auto" }}>
                      {mrProfiles.map((prof, pi) => {
                        const col = pi % mrCols;
                        const row = Math.floor(pi / mrCols);
                        const ox = col * mrColW + mrPad;
                        const oy = row * mrColH + 6;
                        const pw = mrColW - mrPad - 10;
                        const ph = mrColH - mrPadB - 12;
                        const xScale = (v: number) => ox + ((v - prof.lo) / (prof.hi - prof.lo || 1)) * pw;
                        const yScale = (v: number) => oy + ph - ((v - mrYMin) / mrYRange) * ph;

                        return (
                          <g key={`mr${pi}`}>
                            {/* Param name */}
                            <text x={ox + pw / 2} y={oy + 6} fontSize="6.5" fill="var(--color-text)" textAnchor="middle" fontWeight="600">{prof.name}</text>
                            {/* Baseline grid */}
                            <line x1={ox} y1={oy + ph} x2={ox + pw} y2={oy + ph} stroke="var(--color-border)" strokeWidth="0.5" />
                            <line x1={ox} y1={oy + 10} x2={ox} y2={oy + ph} stroke="var(--color-border)" strokeWidth="0.5" />
                            {/* Error band (confidence whiskers) */}
                            {prof.bins.map((b, bi) => {
                              const bx = xScale(b.center);
                              return (
                                <g key={`mre${bi}`}>
                                  <line x1={bx} y1={yScale(b.mean + b.stderr)} x2={bx} y2={yScale(b.mean - b.stderr)} stroke="var(--color-primary)" strokeWidth="1.5" opacity="0.3" />
                                  <line x1={bx - 2} y1={yScale(b.mean + b.stderr)} x2={bx + 2} y2={yScale(b.mean + b.stderr)} stroke="var(--color-primary)" strokeWidth="0.8" opacity="0.4" />
                                  <line x1={bx - 2} y1={yScale(b.mean - b.stderr)} x2={bx + 2} y2={yScale(b.mean - b.stderr)} stroke="var(--color-primary)" strokeWidth="0.8" opacity="0.4" />
                                </g>
                              );
                            })}
                            {/* Mean line */}
                            {prof.bins.length > 1 && (
                              <polyline
                                points={prof.bins.map(b => `${xScale(b.center)},${yScale(b.mean)}`).join(" ")}
                                fill="none"
                                stroke={prof.monotonicity > 0.8 ? "#22c55e" : "var(--color-primary)"}
                                strokeWidth="1.5"
                                strokeLinejoin="round"
                              />
                            )}
                            {/* Mean dots */}
                            {prof.bins.map((b, bi) => (
                              <circle
                                key={`mrd${bi}`}
                                cx={xScale(b.center)}
                                cy={yScale(b.mean)}
                                r="2"
                                fill={prof.monotonicity > 0.8 ? "#22c55e" : "var(--color-primary)"}
                              />
                            ))}
                            {/* Monotonicity indicator */}
                            <text x={ox + pw} y={oy + 6} fontSize="5" fill={prof.monotonicity > 0.8 ? "#22c55e" : "var(--color-text-muted)"} textAnchor="end">
                              ρ={prof.monotonicity.toFixed(2)}
                            </text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: 4, flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 2, background: "#22c55e", marginRight: 4, verticalAlign: "middle" }} />Monotonic (ρ&gt;0.8)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 2, background: "var(--color-primary)", marginRight: 4, verticalAlign: "middle" }} />Non-monotonic</span>
                      <span className="efficiency-legend-item" style={{ opacity: 0.5 }}>|: ±1 SE</span>
                    </div>
                  </div>
                );
              })()}

              {/* Gradient Consistency Heatmap */}
              {trials.length >= 12 && (() => {
                const gcSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (gcSpecs.length === 0) return null;
                const gcKpiKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!gcKpiKey) return null;
                const gcSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const gcN = gcSorted.length;
                const gcParams = gcSpecs.slice(0, 8);
                const gcNWin = Math.min(8, Math.floor(gcN / 4));
                if (gcNWin < 3) return null;
                const gcWinSize = Math.floor(gcN / gcNWin);

                // For each window and parameter, compute gradient sign consistency
                // via correlation between parameter values and KPI in that window
                const gcGrid: number[][] = []; // [param][window] → correlation
                for (let pi = 0; pi < gcParams.length; pi++) {
                  gcGrid[pi] = [];
                  const pName = (gcParams[pi] as { name: string }).name;
                  for (let wi = 0; wi < gcNWin; wi++) {
                    const start = wi * gcWinSize;
                    const end = wi === gcNWin - 1 ? gcN : (wi + 1) * gcWinSize;
                    const win = gcSorted.slice(start, end);
                    const xs = win.map(t => Number(t.parameters[pName]) || 0);
                    const ys = win.map(t => t.kpis[gcKpiKey] ?? 0);
                    const n2 = xs.length;
                    const mx = xs.reduce((a, b) => a + b, 0) / n2;
                    const my = ys.reduce((a, b) => a + b, 0) / n2;
                    let cov = 0, sx = 0, sy = 0;
                    for (let k = 0; k < n2; k++) {
                      cov += (xs[k] - mx) * (ys[k] - my);
                      sx += (xs[k] - mx) ** 2;
                      sy += (ys[k] - my) ** 2;
                    }
                    const denom = Math.sqrt(sx * sy);
                    gcGrid[pi][wi] = denom > 0 ? cov / denom : 0;
                  }
                }

                // Count consistent parameters (same sign gradient in >75% of windows)
                const gcConsistent = gcGrid.filter(row => {
                  const signs = row.map(v => Math.sign(v));
                  const posCount = signs.filter(s => s > 0).length;
                  const negCount = signs.filter(s => s < 0).length;
                  return Math.max(posCount, negCount) / row.length > 0.75;
                }).length;

                // SVG heatmap
                const gcCellW = Math.min(28, Math.floor(180 / gcNWin));
                const gcCellH = 18;
                const gcPadL = 70, gcPadT = 20;
                const gcW = gcPadL + gcNWin * gcCellW + 10;
                const gcH = gcPadT + gcParams.length * gcCellH + 16;

                const gcColor = (v: number) => {
                  // -1 (red) → 0 (white) → +1 (green)
                  if (v > 0) {
                    const t = Math.min(v, 1);
                    return `rgba(34,197,94,${(t * 0.7 + 0.1).toFixed(2)})`;
                  } else {
                    const t = Math.min(-v, 1);
                    return `rgba(239,68,68,${(t * 0.7 + 0.1).toFixed(2)})`;
                  }
                };

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Magnet size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Gradient Consistency</h2>
                        <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)" }}>Local correlation sign stability over time</div>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        {gcConsistent}/{gcParams.length} consistent
                      </span>
                    </div>
                    <svg width={gcW} height={gcH} viewBox={`0 0 ${gcW} ${gcH}`} style={{ width: "100%", maxWidth: gcW, height: "auto" }}>
                      {/* Column headers */}
                      {Array.from({ length: gcNWin }, (_, wi) => (
                        <text key={`gch${wi}`} x={gcPadL + wi * gcCellW + gcCellW / 2} y={gcPadT - 5} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">W{wi + 1}</text>
                      ))}
                      {/* Rows */}
                      {gcParams.map((spec: { name: string }, pi: number) => (
                        <g key={`gcr${pi}`}>
                          <text x={gcPadL - 4} y={gcPadT + pi * gcCellH + gcCellH / 2 + 3} fontSize="7" fill="var(--color-text)" textAnchor="end" style={{ fontFamily: "var(--font-mono)" }}>{spec.name.length > 10 ? spec.name.slice(0, 9) + "…" : spec.name}</text>
                          {gcGrid[pi].map((v, wi) => (
                            <g key={`gcc${pi}-${wi}`}>
                              <rect
                                x={gcPadL + wi * gcCellW}
                                y={gcPadT + pi * gcCellH}
                                width={gcCellW - 1}
                                height={gcCellH - 1}
                                rx={2}
                                fill={gcColor(v)}
                              />
                              {gcCellW >= 20 && (
                                <text
                                  x={gcPadL + wi * gcCellW + (gcCellW - 1) / 2}
                                  y={gcPadT + pi * gcCellH + (gcCellH - 1) / 2 + 3}
                                  fontSize="6"
                                  fill={Math.abs(v) > 0.5 ? "white" : "var(--color-text-muted)"}
                                  textAnchor="middle"
                                  fontWeight="500"
                                >
                                  {v > 0 ? "+" : ""}{v.toFixed(2)}
                                </text>
                              )}
                            </g>
                          ))}
                        </g>
                      ))}
                      {/* Legend */}
                      <rect x={gcPadL} y={gcPadT + gcParams.length * gcCellH + 4} width={20} height={6} rx={2} fill="rgba(239,68,68,0.6)" />
                      <text x={gcPadL + 24} y={gcPadT + gcParams.length * gcCellH + 10} fontSize="5.5" fill="var(--color-text-muted)">Negative</text>
                      <rect x={gcPadL + 60} y={gcPadT + gcParams.length * gcCellH + 4} width={20} height={6} rx={2} fill="rgba(34,197,94,0.6)" />
                      <text x={gcPadL + 84} y={gcPadT + gcParams.length * gcCellH + 10} fontSize="5.5" fill="var(--color-text-muted)">Positive</text>
                    </svg>
                  </div>
                );
              })()}

              {/* Prediction Residual Map */}
              {trials.length >= 8 && (() => {
                const prSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (prSpecs.length === 0) return null;
                const prK = Math.min(5, Math.floor(trials.length / 2));
                if (prK < 2) return null;
                const prObjKey = Object.keys(trials[0].kpis)[0];
                if (!prObjKey) return null;
                // LOO k-NN prediction residuals per trial
                const prNorm = (t: Record<string, number>) => prSpecs.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1;
                  return hi > lo ? (Number(t[sp.name]) - lo) / (hi - lo) : 0.5;
                });
                const prAll = trials.map(t => ({ norm: prNorm(t.parameters), actual: Number(t.kpis[prObjKey]) || 0, params: t.parameters }));
                const prResiduals = prAll.map((pt, idx) => {
                  const dists = prAll.map((o, j) => ({ j, d: j === idx ? Infinity : Math.sqrt(pt.norm.reduce((s, v, k) => s + (v - o.norm[k]) ** 2, 0)) }));
                  dists.sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, prK);
                  const predicted = neighbors.reduce((s, n) => s + prAll[n.j].actual, 0) / prK;
                  return { residual: pt.actual - predicted, actual: pt.actual, predicted, params: pt.params };
                });
                // Per-parameter: group residuals into 4 bins and compute mean residual per bin
                const prMaxParams = Math.min(prSpecs.length, 6);
                const prParamData = prSpecs.slice(0, prMaxParams).map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1;
                  const nBins = 4;
                  const bins = Array.from({ length: nBins }, (_, b) => {
                    const bLo = lo + (b / nBins) * (hi - lo);
                    const bHi = lo + ((b + 1) / nBins) * (hi - lo);
                    const inBin = prResiduals.filter(r => {
                      const v = Number(r.params[sp.name]);
                      return b === nBins - 1 ? v >= bLo && v <= bHi : v >= bLo && v < bHi;
                    });
                    const meanR = inBin.length > 0 ? inBin.reduce((s, r) => s + r.residual, 0) / inBin.length : 0;
                    return { binIdx: b, meanResidual: meanR, count: inBin.length, label: ((bLo + bHi) / 2).toPrecision(2) };
                  });
                  const maxBias = Math.max(...bins.map(b => Math.abs(b.meanResidual)), 0.001);
                  return { name: sp.name, bins, maxBias };
                });
                const prGlobalMaxBias = Math.max(...prParamData.map(p => p.maxBias), 0.001);
                const prMeanAbsResidual = prResiduals.reduce((s, r) => s + Math.abs(r.residual), 0) / prResiduals.length;
                const prBiasCount = prParamData.filter(p => p.bins.some(b => Math.abs(b.meanResidual) / prGlobalMaxBias > 0.6)).length;
                const prLabel = prBiasCount === 0 ? "Unbiased" : prBiasCount <= 2 ? "Mild Bias" : "Systematic Bias";
                const prColor = prBiasCount === 0 ? "#22c55e" : prBiasCount <= 2 ? "#eab308" : "#ef4444";
                // Small multiples
                const prCols = Math.min(3, prParamData.length);
                const prCellW = 110, prCellH = 70;
                const prSvgW = prCols * prCellW;
                const prRows = Math.ceil(prParamData.length / prCols);
                const prSvgH = prRows * prCellH;
                const prBarPad = 8;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <BarChartHorizontal size={15} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Prediction Residual Map</h2>
                      </div>
                      <div style={{ display: "flex", gap: 6, alignItems: "center" }}>
                        <span className="findings-badge" style={{ background: prColor, color: "#fff" }}>{prLabel}</span>
                        <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)" }}>MAE: {prMeanAbsResidual.toFixed(3)}</span>
                      </div>
                    </div>
                    <svg width={prSvgW} height={prSvgH} viewBox={`0 0 ${prSvgW} ${prSvgH}`} style={{ width: "100%", height: "auto" }}>
                      {prParamData.map((param, pi) => {
                        const col = pi % prCols;
                        const row = Math.floor(pi / prCols);
                        const ox = col * prCellW;
                        const oy = row * prCellH;
                        const midY = oy + prCellH / 2 + 4;
                        const maxBarH = prCellH / 2 - 12;
                        const barW = (prCellW - 2 * prBarPad) / param.bins.length * 0.7;
                        const barGap = (prCellW - 2 * prBarPad) / param.bins.length;
                        return (
                          <g key={pi}>
                            <text x={ox + prCellW / 2} y={oy + 10} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle" fontWeight="500">{param.name}</text>
                            {/* Zero line */}
                            <line x1={ox + prBarPad} y1={midY} x2={ox + prCellW - prBarPad} y2={midY} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="2,1" />
                            {param.bins.map((bin, bi) => {
                              const bx = ox + prBarPad + bi * barGap + barGap / 2;
                              const h = (Math.abs(bin.meanResidual) / prGlobalMaxBias) * maxBarH;
                              const isNeg = bin.meanResidual < 0;
                              const barColor = Math.abs(bin.meanResidual) / prGlobalMaxBias > 0.6 ? "#ef4444" : Math.abs(bin.meanResidual) / prGlobalMaxBias > 0.3 ? "#eab308" : "#22c55e";
                              return (
                                <g key={bi}>
                                  <rect
                                    x={bx - barW / 2}
                                    y={isNeg ? midY : midY - h}
                                    width={barW}
                                    height={Math.max(h, 1)}
                                    rx={1.5}
                                    fill={barColor}
                                    opacity={0.75}
                                  />
                                  <text x={bx} y={oy + prCellH - 2} fontSize="4.5" fill="var(--color-text-muted)" textAnchor="middle">{bin.label}</text>
                                </g>
                              );
                            })}
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>k={prK} LOO, 4 bins/param</span>
                      <span>{prBiasCount}/{prParamData.length} params with bias</span>
                      <span style={{ marginLeft: "auto" }}>Bars above/below = over/under-prediction</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Interaction Network */}
              {trials.length >= 10 && (() => {
                const piSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string }) => s.type === "continuous") || [];
                if (piSpecs.length < 3) return null;
                const piMaxP = Math.min(piSpecs.length, 8);
                const piParams = piSpecs.slice(0, piMaxP).map((s: { name: string }) => s.name);
                const piObjKey = Object.keys(trials[0].kpis)[0];
                if (!piObjKey) return null;
                const piObjVals = trials.map(t => Number(t.kpis[piObjKey]) || 0);
                // For each pair, compute interaction: |corr(p1*p2, kpi)| - proxy for synergy
                const piMean = (arr: number[]) => arr.reduce((a, b) => a + b, 0) / arr.length;
                const piCorr = (xs: number[], ys: number[]) => {
                  const n = xs.length; const mx = piMean(xs); const my = piMean(ys);
                  let num = 0, dx = 0, dy = 0;
                  for (let i = 0; i < n; i++) { num += (xs[i] - mx) * (ys[i] - my); dx += (xs[i] - mx) ** 2; dy += (ys[i] - my) ** 2; }
                  return dx > 0 && dy > 0 ? num / Math.sqrt(dx * dy) : 0;
                };
                const piEdges: { a: number; b: number; strength: number }[] = [];
                for (let i = 0; i < piParams.length; i++) {
                  for (let j = i + 1; j < piParams.length; j++) {
                    const v1 = trials.map(t => Number(t.parameters[piParams[i]]) || 0);
                    const v2 = trials.map(t => Number(t.parameters[piParams[j]]) || 0);
                    const product = v1.map((v, k) => v * v2[k]);
                    const interaction = Math.abs(piCorr(product, piObjVals));
                    piEdges.push({ a: i, b: j, strength: interaction });
                  }
                }
                piEdges.sort((a, b) => b.strength - a.strength);
                const piTopEdges = piEdges.slice(0, Math.min(10, piEdges.length));
                const piMaxStr = Math.max(...piTopEdges.map(e => e.strength), 0.01);
                const piStrongCount = piTopEdges.filter(e => e.strength > 0.3).length;
                const piLabel = piStrongCount === 0 ? "Independent" : piStrongCount <= 3 ? "Mild Coupling" : "Strong Coupling";
                const piColor = piStrongCount === 0 ? "#22c55e" : piStrongCount <= 3 ? "#eab308" : "#ef4444";
                // Layout: circular
                const piW = 240, piH = 180;
                const piCx = piW / 2, piCy = piH / 2 + 4, piRadius = 60;
                const piNodePos = piParams.map((_, i) => {
                  const angle = (Math.PI * 2 * i) / piParams.length - Math.PI / 2;
                  return { x: piCx + Math.cos(angle) * piRadius, y: piCy + Math.sin(angle) * piRadius };
                });
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <Share2 size={15} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Parameter Interactions</h2>
                      </div>
                      <span className="findings-badge" style={{ background: piColor, color: "#fff" }}>{piLabel}</span>
                    </div>
                    <svg width={piW} height={piH} viewBox={`0 0 ${piW} ${piH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Edges */}
                      {piTopEdges.map((e, i) => {
                        const pa = piNodePos[e.a], pb = piNodePos[e.b];
                        const norm = e.strength / piMaxStr;
                        const sw = 0.5 + norm * 3;
                        const opacity = 0.2 + norm * 0.6;
                        const col = norm > 0.6 ? "#ef4444" : norm > 0.3 ? "#eab308" : "#94a3b8";
                        return <line key={i} x1={pa.x} y1={pa.y} x2={pb.x} y2={pb.y} stroke={col} strokeWidth={sw} opacity={opacity} />;
                      })}
                      {/* Nodes */}
                      {piParams.map((name, i) => {
                        const p = piNodePos[i];
                        const myEdges = piTopEdges.filter(e => e.a === i || e.b === i);
                        const maxConn = Math.max(...myEdges.map(e => e.strength), 0);
                        const r = 8 + (maxConn / piMaxStr) * 6;
                        return (
                          <g key={i}>
                            <circle cx={p.x} cy={p.y} r={r} fill="var(--color-primary)" opacity={0.15} stroke="var(--color-primary)" strokeWidth="1" />
                            <circle cx={p.x} cy={p.y} r="3" fill="var(--color-primary)" />
                            <text x={p.x} y={p.y + r + 8} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle" fontWeight="500">
                              {name.length > 8 ? name.slice(0, 7) + "…" : name}
                            </text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 2, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>Top {piTopEdges.length} pairs, {piStrongCount} strong (&gt;0.3)</span>
                      <span style={{ marginLeft: "auto" }}>
                        <span style={{ display: "inline-block", width: 14, height: 2, background: "#ef4444", marginRight: 3, verticalAlign: "middle" }} />Strong
                        <span style={{ display: "inline-block", width: 14, height: 2, background: "#eab308", marginRight: 3, marginLeft: 8, verticalAlign: "middle" }} />Moderate
                        <span style={{ display: "inline-block", width: 14, height: 2, background: "#94a3b8", marginRight: 3, marginLeft: 8, verticalAlign: "middle" }} />Weak
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Local Sensitivity Map */}
              {trials.length >= 15 && (() => {
                const lsSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (lsSpecs.length < 2) return null;
                const lsKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!lsKey) return null;

                // Pick top 2 params by variance
                const lsVarScores = lsSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                  const vals = trials.map(t => Number(t.parameters[s.name]) || 0);
                  const mu = vals.reduce((a, b) => a + b, 0) / vals.length;
                  return { spec: s, variance: vals.reduce((a, v) => a + (v - mu) ** 2, 0) / vals.length };
                }).sort((a: { variance: number }, b: { variance: number }) => b.variance - a.variance);
                const lsP1 = lsVarScores[0].spec as { name: string; lower?: number; upper?: number };
                const lsP2 = lsVarScores[1].spec as { name: string; lower?: number; upper?: number };
                const lsGrid = 8;

                // Build grid: each cell stores KPI values
                const lsCells: number[][][] = Array.from({ length: lsGrid }, () => Array.from({ length: lsGrid }, () => []));
                const lsP1Min = lsP1.lower ?? 0, lsP1Max = lsP1.upper ?? 1;
                const lsP2Min = lsP2.lower ?? 0, lsP2Max = lsP2.upper ?? 1;
                const lsP1Range = lsP1Max - lsP1Min || 1, lsP2Range = lsP2Max - lsP2Min || 1;
                trials.forEach(t => {
                  const v1 = Number(t.parameters[lsP1.name]) || 0;
                  const v2 = Number(t.parameters[lsP2.name]) || 0;
                  const c = Math.min(lsGrid - 1, Math.max(0, Math.floor((v1 - lsP1Min) / lsP1Range * lsGrid)));
                  const r = Math.min(lsGrid - 1, Math.max(0, Math.floor((v2 - lsP2Min) / lsP2Range * lsGrid)));
                  lsCells[lsGrid - 1 - r][c].push(Number(t.kpis[lsKey]) || 0);
                });

                // Compute local std per cell (sensitivity)
                const lsStds: (number | null)[][] = lsCells.map(row => row.map(cell => {
                  if (cell.length < 2) return null;
                  const mu = cell.reduce((a, b) => a + b, 0) / cell.length;
                  return Math.sqrt(cell.reduce((a, v) => a + (v - mu) ** 2, 0) / cell.length);
                }));

                // Max std for normalization
                let lsMaxStd = 0;
                lsStds.forEach(row => row.forEach(v => { if (v !== null && v > lsMaxStd) lsMaxStd = v; }));
                if (lsMaxStd === 0) lsMaxStd = 1;

                // Count high-sensitivity cells (>60% of max)
                let lsHighCount = 0;
                lsStds.forEach(row => row.forEach(v => { if (v !== null && v / lsMaxStd > 0.6) lsHighCount++; }));
                const lsTotalPopulated = lsStds.flat().filter(v => v !== null).length;
                const lsStatus = lsHighCount === 0 ? "Uniform" : lsHighCount <= lsTotalPopulated * 0.3 ? "Localized" : "Widespread";
                const lsStatusColor = lsStatus === "Uniform" ? "var(--color-green, #22c55e)" : lsStatus === "Localized" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const lsCellSize = 28, lsGap = 2, lsPad = 30;
                const lsW = lsPad + lsGrid * (lsCellSize + lsGap) + 30;
                const lsH = lsPad + lsGrid * (lsCellSize + lsGap) + 16;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <Microscope size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Local Sensitivity</h2>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: lsStatusColor + "18", color: lsStatusColor }}>{lsStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Local KPI variance across {lsP1.name} × {lsP2.name}. Red = high sensitivity, blue = low.
                    </p>
                    <svg width={lsW} height={lsH} viewBox={`0 0 ${lsW} ${lsH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Y-axis label */}
                      <text x={4} y={lsPad + (lsGrid * (lsCellSize + lsGap)) / 2} textAnchor="middle" fill="var(--color-text-muted)" fontSize={8} fontFamily="var(--font-mono)" transform={`rotate(-90, 4, ${lsPad + (lsGrid * (lsCellSize + lsGap)) / 2})`}>{lsP2.name}</text>
                      {/* X-axis label */}
                      <text x={lsPad + (lsGrid * (lsCellSize + lsGap)) / 2} y={lsH - 2} textAnchor="middle" fill="var(--color-text-muted)" fontSize={8} fontFamily="var(--font-mono)">{lsP1.name}</text>
                      {/* Grid cells */}
                      {lsStds.map((row, ri) => row.map((val, ci) => {
                        const x = lsPad + ci * (lsCellSize + lsGap);
                        const y = lsPad + ri * (lsCellSize + lsGap);
                        const norm = val !== null ? val / lsMaxStd : -1;
                        let fill: string;
                        if (norm < 0) fill = "var(--color-border)";
                        else if (norm < 0.25) fill = "#3b82f6";
                        else if (norm < 0.5) fill = "#8b5cf6";
                        else if (norm < 0.75) fill = "#f59e0b";
                        else fill = "#ef4444";
                        const count = lsCells[ri][ci].length;
                        return (
                          <g key={`${ri}-${ci}`}>
                            <rect x={x} y={y} width={lsCellSize} height={lsCellSize} rx={3} fill={fill} opacity={norm < 0 ? 0.15 : 0.7} />
                            {count > 0 && <text x={x + lsCellSize / 2} y={y + lsCellSize / 2 + 3} textAnchor="middle" fill={norm > 0.5 ? "#fff" : "var(--color-text)"} fontSize={8} fontFamily="var(--font-mono)">{count}</text>}
                          </g>
                        );
                      }))}
                      {/* Color legend */}
                      {[
                        { label: "Low", color: "#3b82f6" },
                        { label: "Med", color: "#8b5cf6" },
                        { label: "High", color: "#f59e0b" },
                        { label: "V.High", color: "#ef4444" },
                      ].map((item, i) => (
                        <g key={i}>
                          <rect x={lsPad + lsGrid * (lsCellSize + lsGap) + 6} y={lsPad + i * 18} width={10} height={10} rx={2} fill={item.color} opacity={0.7} />
                          <text x={lsPad + lsGrid * (lsCellSize + lsGap) + 20} y={lsPad + i * 18 + 8} fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{item.label}</text>
                        </g>
                      ))}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>{lsHighCount} high-sensitivity cells of {lsTotalPopulated} populated</span>
                    </div>
                  </div>
                );
              })()}

              {/* Relationship Drift Heatmap */}
              {trials.length >= 20 && (() => {
                const rdSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rdSpecs.length < 2) return null;
                const rdSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const rdKey = Object.keys(rdSorted[0]?.kpis || {})[0];
                if (!rdKey) return null;
                const rdN = rdSorted.length;
                const rdPhases = 5;
                const rdPhaseSize = Math.floor(rdN / rdPhases);

                // Generate parameter pairs (top 8 params, up to 10 pairs)
                const rdParamNames = rdSpecs.slice(0, 8).map((s: { name: string }) => s.name);
                const rdPairs: [string, string][] = [];
                for (let i = 0; i < rdParamNames.length && rdPairs.length < 10; i++) {
                  for (let j = i + 1; j < rdParamNames.length && rdPairs.length < 10; j++) {
                    rdPairs.push([rdParamNames[i], rdParamNames[j]]);
                  }
                }

                // For each pair and phase, compute |correlation of product with KPI|
                const rdMatrix: number[][] = rdPairs.map(([p1, p2]) => {
                  const phases: number[] = [];
                  for (let ph = 0; ph < rdPhases; ph++) {
                    const start = ph * rdPhaseSize;
                    const end = ph === rdPhases - 1 ? rdN : (ph + 1) * rdPhaseSize;
                    const chunk = rdSorted.slice(start, end);
                    if (chunk.length < 5) { phases.push(0); continue; }
                    const products = chunk.map(t => (Number(t.parameters[p1]) || 0) * (Number(t.parameters[p2]) || 0));
                    const kpis = chunk.map(t => Number(t.kpis[rdKey]) || 0);
                    const pMu = products.reduce((a, b) => a + b, 0) / products.length;
                    const kMu = kpis.reduce((a, b) => a + b, 0) / kpis.length;
                    const cov = products.reduce((a, v, i) => a + (v - pMu) * (kpis[i] - kMu), 0) / products.length;
                    const pStd = Math.sqrt(products.reduce((a, v) => a + (v - pMu) ** 2, 0) / products.length) || 1;
                    const kStd = Math.sqrt(kpis.reduce((a, v) => a + (v - kMu) ** 2, 0) / kpis.length) || 1;
                    phases.push(Math.abs(cov / (pStd * kStd)));
                  }
                  return phases;
                });

                // Sort pairs by max strength
                const rdIndices = rdPairs.map((_, i) => i).sort((a, b) => Math.max(...rdMatrix[b]) - Math.max(...rdMatrix[a]));
                const rdSortedPairs = rdIndices.slice(0, 8).map(i => ({ pair: rdPairs[i], values: rdMatrix[i] }));

                // Detect drift: compare first vs last phase
                const rdDriftCounts = { emerging: 0, stable: 0, decaying: 0 };
                rdSortedPairs.forEach(({ values }) => {
                  const delta = values[values.length - 1] - values[0];
                  if (delta > 0.15) rdDriftCounts.emerging++;
                  else if (delta < -0.15) rdDriftCounts.decaying++;
                  else rdDriftCounts.stable++;
                });
                const rdStatus = rdDriftCounts.emerging > rdDriftCounts.stable ? "Emerging" : rdDriftCounts.decaying > rdDriftCounts.stable ? "Decaying" : "Stable";
                const rdStatusColor = rdStatus === "Emerging" ? "var(--color-yellow, #eab308)" : rdStatus === "Decaying" ? "var(--color-blue, #3b82f6)" : "var(--color-text-muted, #94a3b8)";

                const rdLabelW = 80, rdCellW = 36, rdCellH = 22, rdGap = 2, rdPadTop = 20;
                const rdW = rdLabelW + rdPhases * (rdCellW + rdGap) + 10;
                const rdH = rdPadTop + rdSortedPairs.length * (rdCellH + rdGap) + 4;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <GitMerge size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Relationship Drift</h2>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: rdStatusColor + "18", color: rdStatusColor }}>{rdStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      How parameter-pair interaction strength changes across {rdPhases} campaign phases.
                    </p>
                    <svg width={rdW} height={rdH} viewBox={`0 0 ${rdW} ${rdH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Phase headers */}
                      {Array.from({ length: rdPhases }, (_, p) => (
                        <text key={p} x={rdLabelW + p * (rdCellW + rdGap) + rdCellW / 2} y={12} textAnchor="middle" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">P{p + 1}</text>
                      ))}
                      {/* Rows */}
                      {rdSortedPairs.map(({ pair, values }, ri) => {
                        const y = rdPadTop + ri * (rdCellH + rdGap);
                        const label = pair[0].slice(0, 3) + "×" + pair[1].slice(0, 3);
                        return (
                          <g key={ri}>
                            <text x={rdLabelW - 4} y={y + rdCellH / 2 + 3} textAnchor="end" fill="var(--color-text)" fontSize={7.5} fontFamily="var(--font-mono)">{label}</text>
                            {values.map((v, ci) => {
                              const x = rdLabelW + ci * (rdCellW + rdGap);
                              const intensity = Math.min(1, v * 2); // scale for visibility
                              const r = Math.round(59 + intensity * 196);
                              const g = Math.round(130 - intensity * 100);
                              const b = Math.round(246 - intensity * 196);
                              return (
                                <g key={ci}>
                                  <rect x={x} y={y} width={rdCellW} height={rdCellH} rx={3} fill={`rgb(${r},${g},${b})`} opacity={0.7} />
                                  <text x={x + rdCellW / 2} y={y + rdCellH / 2 + 3} textAnchor="middle" fill={intensity > 0.5 ? "#fff" : "var(--color-text)"} fontSize={7} fontFamily="var(--font-mono)">{v.toFixed(2)}</text>
                                </g>
                              );
                            })}
                            {/* Trend arrow */}
                            {(() => {
                              const delta = values[values.length - 1] - values[0];
                              const arrow = delta > 0.15 ? "↑" : delta < -0.15 ? "↓" : "→";
                              const color = delta > 0.15 ? "#eab308" : delta < -0.15 ? "#3b82f6" : "var(--color-text-muted)";
                              return <text x={rdLabelW + rdPhases * (rdCellW + rdGap) + 2} y={y + rdCellH / 2 + 3} fill={color} fontSize={10} fontFamily="var(--font-mono)">{arrow}</text>;
                            })()}
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>↑ emerging ({rdDriftCounts.emerging})</span>
                      <span>→ stable ({rdDriftCounts.stable})</span>
                      <span>↓ decaying ({rdDriftCounts.decaying})</span>
                    </div>
                  </div>
                );
              })()}

              {/* Extrapolation Risk Atlas */}
              {trials.length >= 15 && (() => {
                const erParams = (campaign.spec?.parameters || []).filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (erParams.length < 2) return null;

                // Normalize trials
                const erNorm = trials.map((t: { parameters: Record<string, number> }) =>
                  erParams.map((p: { name: string; lower?: number; upper?: number }) => {
                    const lo = p.lower!, hi = p.upper!;
                    return (hi - lo) > 0 ? ((t.parameters[p.name] ?? lo) - lo) / (hi - lo) : 0.5;
                  })
                );

                // PCA-like: project onto top 2 variance axes
                const erMeans = erParams.map((_: unknown, pi: number) => erNorm.reduce((s: number, n: number[]) => s + n[pi], 0) / erNorm.length);
                const erVarByAxis = erParams.map((_: unknown, pi: number) => {
                  return erNorm.reduce((s: number, n: number[]) => s + (n[pi] - erMeans[pi]) ** 2, 0) / erNorm.length;
                });
                const erAxes = erVarByAxis.map((v: number, i: number) => ({ i, v })).sort((a: { v: number }, b: { v: number }) => b.v - a.v);
                const erA0 = erAxes[0].i, erA1 = erAxes[1].i;

                // Project each trial to 2D
                const erPts = erNorm.map((n: number[]) => ({ x: n[erA0], y: n[erA1] }));

                // Create 8×8 risk grid
                const erGridN = 8;
                const erCells: { gx: number; gy: number; risk: number; nearest: number }[] = [];
                for (let gy = 0; gy < erGridN; gy++) {
                  for (let gx = 0; gx < erGridN; gx++) {
                    const cx = (gx + 0.5) / erGridN, cy = (gy + 0.5) / erGridN;
                    // Min distance to any training point
                    let minDist = Infinity;
                    erPts.forEach((p: { x: number; y: number }) => {
                      const d = Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);
                      if (d < minDist) minDist = d;
                    });
                    // Risk = distance-based (farther from data = riskier)
                    const risk = Math.min(minDist / 0.4, 1); // normalize: 0.4 distance = max risk
                    erCells.push({ gx, gy, risk, nearest: minDist });
                  }
                }

                const erHighRisk = erCells.filter(c => c.risk > 0.6).length;
                const erPct = erHighRisk / erCells.length;
                const erStatus = erPct < 0.2 ? "Well Supported" : erPct < 0.4 ? "Some Gaps" : "High Risk";
                const erColor = erStatus === "Well Supported" ? "var(--color-green, #22c55e)" : erStatus === "Some Gaps" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const erCellW = 28, erCellH = 28;
                const erPadL = 40, erPadT = 8, erPadB = 24, erPadR = 8;
                const erW = erPadL + erGridN * erCellW + erPadR;
                const erH = erPadT + erGridN * erCellH + erPadB;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <ShieldAlert size={15} style={{ color: erColor }} />
                      <h2 style={{ margin: 0 }}>Extrapolation Risk</h2>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: 8, background: erColor + "18", color: erColor }}>{erStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Distance from observations in {erParams[erA0].name} vs {erParams[erA1].name}. Red = predictions unreliable.
                    </p>
                    <svg width={erW} height={erH} viewBox={`0 0 ${erW} ${erH}`} style={{ width: "100%", height: "auto", maxHeight: 260 }}>
                      {erCells.map((c, i) => {
                        const r = Math.round(40 + 200 * c.risk);
                        const g = Math.round(140 * (1 - c.risk));
                        const b = Math.round(200 * (1 - c.risk) + 40);
                        return (
                          <rect key={i} x={erPadL + c.gx * erCellW} y={erPadT + (erGridN - 1 - c.gy) * erCellH} width={erCellW - 1} height={erCellH - 1} rx={2} fill={`rgb(${r},${g},${b})`} opacity={0.8}>
                            <title>{`Risk: ${(c.risk * 100).toFixed(0)}%\nNearest trial: ${c.nearest.toFixed(3)}`}</title>
                          </rect>
                        );
                      })}
                      {/* Training points */}
                      {erPts.map((p: { x: number; y: number }, i: number) => (
                        <circle key={`t${i}`} cx={erPadL + p.x * erGridN * erCellW} cy={erPadT + (1 - p.y) * erGridN * erCellH} r={2.5} fill="white" stroke="var(--color-text)" strokeWidth={0.8} opacity={0.7} />
                      ))}
                      {/* Axes */}
                      <text x={erPadL - 4} y={erPadT + erGridN * erCellH / 2} textAnchor="end" fontSize={8} fill="var(--color-text-muted)" transform={`rotate(-90,${erPadL - 4},${erPadT + erGridN * erCellH / 2})`}>{erParams[erA1].name}</text>
                      <text x={erPadL + erGridN * erCellW / 2} y={erH - 4} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">{erParams[erA0].name}</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(40,140,240)" }} /> safe</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(240,40,40)" }} /> risky</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 6, height: 6, borderRadius: "50%", background: "white", border: "1px solid var(--color-text)" }} /> trials</span>
                      <span style={{ marginLeft: "auto" }}>{erHighRisk}/{erCells.length} high-risk</span>
                    </div>
                  </div>
                );
              })()}

              {/* Feasibility Landscape — Batch 21 */}
              {trials.length >= 6 && (() => {
                const flSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (flSpecs.length < 2) return null;
                const flSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const flParams = flSpecs.slice(0, 2);
                const flN = 8;
                // Each cell tracks success/failure counts
                const flSuccess: number[][] = Array.from({ length: flN }, () => Array(flN).fill(0));
                const flFail: number[][] = Array.from({ length: flN }, () => Array(flN).fill(0));
                flSorted.forEach(t => {
                  const xv = t.parameters[flParams[0].name];
                  const yv = t.parameters[flParams[1].name];
                  if (xv == null || yv == null) return;
                  const xi = Math.min(flN - 1, Math.max(0, Math.floor(((xv - flParams[0].lower!) / (flParams[0].upper! - flParams[0].lower!)) * flN)));
                  const yi = Math.min(flN - 1, Math.max(0, Math.floor(((yv - flParams[1].lower!) / (flParams[1].upper! - flParams[1].lower!)) * flN)));
                  const kpiVal = Object.values(t.kpis)[0];
                  if (kpiVal != null && !isNaN(kpiVal) && (t.status as string) !== "failed") {
                    flSuccess[yi][xi]++;
                  } else {
                    flFail[yi][xi]++;
                  }
                });
                // Feasibility score per cell = success / (success + fail), or -1 if no data
                const flScores = flSuccess.map((row, yi) => row.map((s, xi) => {
                  const total = s + flFail[yi][xi];
                  return total > 0 ? s / total : -1;
                }));
                // Overall feasibility
                const flCellsWithData = flScores.flat().filter(v => v >= 0);
                const flAvgFeasibility = flCellsWithData.length > 0 ? flCellsWithData.reduce((a, b) => a + b, 0) / flCellsWithData.length : 1;
                const flInfeasibleFrac = flCellsWithData.filter(v => v < 0.5).length / Math.max(1, flCellsWithData.length);
                const flBadge = flInfeasibleFrac < 0.1 ? "Mostly Feasible" : flInfeasibleFrac < 0.3 ? "Some Risks" : "Many Infeasible";
                const flBadgeColor = flInfeasibleFrac < 0.1 ? "var(--color-green, #22c55e)" : flInfeasibleFrac < 0.3 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const flCell = 22;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Mountain size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Feasibility Landscape</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: flBadgeColor + "18", color: flBadgeColor }}>{flBadge}</span>
                    </div>
                    <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
                      <svg width={flCell * flN + 2} height={flCell * flN + 2} style={{ flexShrink: 0 }}>
                        {flScores.map((row, yi) => row.map((score, xi) => {
                          let fill: string;
                          if (score < 0) {
                            fill = "var(--color-bg-secondary, #f1f5f9)";
                          } else {
                            // Green (feasible) to Red (infeasible)
                            const r = Math.round(34 + (1 - score) * 205);
                            const g = Math.round(197 - (1 - score) * 130);
                            const b = Math.round(94 - (1 - score) * 26);
                            fill = `rgb(${r},${g},${b})`;
                          }
                          const total = flSuccess[yi][xi] + flFail[yi][xi];
                          return (
                            <rect key={`fl-${yi}-${xi}`} x={xi * flCell + 1} y={yi * flCell + 1} width={flCell - 1} height={flCell - 1} rx={2} fill={fill} stroke="var(--color-border)" strokeWidth={0.3}>
                              <title>{flParams[0].name}[{xi}] × {flParams[1].name}[{yi}]: {score >= 0 ? `${(score * 100).toFixed(0)}% feasible (${total} trials)` : "No data"}</title>
                            </rect>
                          );
                        }))}
                      </svg>
                      <div style={{ flex: 1, fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                        <div style={{ marginBottom: "6px" }}>
                          <span style={{ fontWeight: 600, color: "var(--color-text)" }}>Avg Feasibility: {(flAvgFeasibility * 100).toFixed(0)}%</span>
                        </div>
                        <div style={{ marginBottom: "4px" }}>Risky cells: {(flInfeasibleFrac * 100).toFixed(0)}% with &lt;50% success</div>
                        <div style={{ marginBottom: "4px" }}>Coverage: {flCellsWithData.length}/{flN * flN} cells explored</div>
                        <div style={{ display: "flex", gap: "6px", marginTop: "8px", flexWrap: "wrap" }}>
                          {[["#22c55e", "Feasible"], ["#ef4444", "Infeasible"], ["var(--color-bg-secondary, #f1f5f9)", "No data"]].map(([c, l]) => (
                            <span key={l} style={{ display: "flex", alignItems: "center", gap: "3px", fontSize: "0.7rem" }}>
                              <span style={{ width: 8, height: 8, borderRadius: 2, background: c, display: "inline-block", border: "0.5px solid var(--color-border)" }} />
                              {l}
                            </span>
                          ))}
                        </div>
                        <div style={{ fontSize: "0.73rem", fontStyle: "italic", marginTop: "6px" }}>
                          {flInfeasibleFrac > 0.3 ? "Many infeasible regions detected — constraints may be active." : flInfeasibleFrac > 0.1 ? "Some risky zones — watch for constraint violations." : "Largely feasible space — good for aggressive exploration."}
                        </div>
                      </div>
                    </div>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.7rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      <span>{flParams[0].name} →</span>
                      <span>↓ {flParams[1].name}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Model Disagreement Map — Batch 22 */}
              {trials.length >= 10 && (() => {
                const mdSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (mdSpecs.length < 2) return null;
                const mdSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const mdParams = mdSpecs.slice(0, 2);
                const mdN = 8;
                const mdKpis = mdSorted.map(t => Object.values(t.kpis)[0] ?? 0);
                // For each grid cell, compute "disagreement" = variance of k-NN predictions from different subsets (bootstrap)
                const mdGrid: number[][] = Array.from({ length: mdN }, () => Array(mdN).fill(0));
                const mdK = Math.min(5, Math.floor(mdSorted.length / 3));
                for (let yi = 0; yi < mdN; yi++) {
                  for (let xi = 0; xi < mdN; xi++) {
                    const cx = mdParams[0].lower! + (xi + 0.5) / mdN * (mdParams[0].upper! - mdParams[0].lower!);
                    const cy = mdParams[1].lower! + (yi + 0.5) / mdN * (mdParams[1].upper! - mdParams[1].lower!);
                    // Get distances to all trials
                    const dists = mdSorted.map((t, idx) => {
                      const dx = (t.parameters[mdParams[0].name] - cx) / (mdParams[0].upper! - mdParams[0].lower!);
                      const dy = (t.parameters[mdParams[1].name] - cy) / (mdParams[1].upper! - mdParams[1].lower!);
                      return { dist: Math.sqrt(dx * dx + dy * dy), kpi: mdKpis[idx] };
                    }).sort((a, b) => a.dist - b.dist);
                    const neighbors = dists.slice(0, mdK);
                    // "Disagreement" = std of neighbor KPIs (proxy for model uncertainty)
                    const nMean = neighbors.reduce((s, n) => s + n.kpi, 0) / neighbors.length;
                    const nVar = neighbors.reduce((s, n) => s + (n.kpi - nMean) ** 2, 0) / neighbors.length;
                    mdGrid[yi][xi] = Math.sqrt(nVar);
                  }
                }
                const mdMax = Math.max(0.0001, ...mdGrid.flat());
                // Consensus score: fraction of cells with low disagreement
                const mdLowDisagree = mdGrid.flat().filter(v => v / mdMax < 0.4).length / (mdN * mdN);
                const mdBadge = mdLowDisagree > 0.7 ? "High Consensus" : mdLowDisagree > 0.4 ? "Moderate" : "High Disagreement";
                const mdBadgeColor = mdLowDisagree > 0.7 ? "var(--color-green, #22c55e)" : mdLowDisagree > 0.4 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const mdCell = 22;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Users size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Model Disagreement Map</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: mdBadgeColor + "18", color: mdBadgeColor }}>{mdBadge}</span>
                    </div>
                    <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
                      <svg width={mdCell * mdN + 2} height={mdCell * mdN + 2} style={{ flexShrink: 0 }}>
                        {mdGrid.map((row, yi) => row.map((disagree, xi) => {
                          const norm = disagree / mdMax;
                          // Green (consensus) → Red (disagreement)
                          const r = Math.round(34 + norm * 200);
                          const g = Math.round(197 - norm * 140);
                          const b = Math.round(94 - norm * 30);
                          return (
                            <rect key={`md-${yi}-${xi}`} x={xi * mdCell + 1} y={yi * mdCell + 1} width={mdCell - 1} height={mdCell - 1} rx={2} fill={`rgb(${r},${g},${b})`} stroke="var(--color-border)" strokeWidth={0.3}>
                              <title>{mdParams[0].name}[{xi}] × {mdParams[1].name}[{yi}]: σ={disagree.toFixed(4)} ({(norm * 100).toFixed(0)}%)</title>
                            </rect>
                          );
                        }))}
                      </svg>
                      <div style={{ flex: 1, fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                        <div style={{ marginBottom: "6px" }}>
                          <span style={{ fontWeight: 600, color: "var(--color-text)" }}>Consensus: {(mdLowDisagree * 100).toFixed(0)}%</span>
                          <span style={{ marginLeft: "6px" }}>of cells agree</span>
                        </div>
                        <div style={{ marginBottom: "4px" }}>Max σ: {mdMax.toFixed(4)}</div>
                        <div style={{ marginBottom: "4px" }}>k-NN: {mdK} neighbors per cell</div>
                        <div style={{ display: "flex", gap: "6px", marginTop: "6px", flexWrap: "wrap" }}>
                          {[["#22c55e", "Consensus"], ["#ef4444", "Disagreement"]].map(([c, l]) => (
                            <span key={l} style={{ display: "flex", alignItems: "center", gap: "3px", fontSize: "0.7rem" }}>
                              <span style={{ width: 8, height: 8, borderRadius: 2, background: c, display: "inline-block" }} />
                              {l}
                            </span>
                          ))}
                        </div>
                        <div style={{ fontSize: "0.73rem", fontStyle: "italic", marginTop: "6px" }}>
                          {mdLowDisagree < 0.4 ? "Red zones have high uncertainty — prioritize exploring these regions." : mdLowDisagree < 0.7 ? "Some uncertain regions remain — targeted exploration may help." : "Model is confident across most of the space."}
                        </div>
                      </div>
                    </div>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.7rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      <span>{mdParams[0].name} →</span>
                      <span>↓ {mdParams[1].name}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Knowledge Gain Per Cost */}
              {trials.length >= 12 && (() => {
                const kgSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (kgSpecs.length < 2) return null;
                const kgObjKey = Object.keys(trials[0].kpis)[0];
                const kgSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const kgNorm = (v: number, lo: number, hi: number) => hi > lo ? (v - lo) / (hi - lo) : 0;
                const kgRanges = kgSpecs.map((s: { name: string; lower?: number; upper?: number }) => ({
                  name: s.name, lo: s.lower!, hi: s.upper!
                }));
                const kgK = Math.min(5, Math.floor(kgSorted.length / 4));
                // Rolling window: measure epistemic uncertainty reduction per trial
                const kgWin = 5;
                const kgGains: number[] = [];
                for (let i = kgWin; i <= kgSorted.length; i++) {
                  const pool = kgSorted.slice(0, i);
                  const prevPool = kgSorted.slice(0, i - 1);
                  // Measure uncertainty as avg k-NN std for a grid of points
                  const kgGridN = 8;
                  let kgUncAfter = 0, kgUncBefore = 0;
                  const kgGridCount = kgGridN ** 2;
                  for (let gi = 0; gi < kgGridN; gi++) {
                    for (let gj = 0; gj < kgGridN; gj++) {
                      const pt: Record<string, number> = {};
                      kgRanges.forEach((r, idx) => {
                        pt[r.name] = idx === 0 ? (gi + 0.5) / kgGridN : idx === 1 ? (gj + 0.5) / kgGridN : 0.5;
                      });
                      const distAfter = pool.map(t => {
                        let d2 = 0;
                        for (const r of kgRanges) { const a = pt[r.name]; const b = kgNorm(t.parameters[r.name] ?? 0, r.lo, r.hi); d2 += (a - b) ** 2; }
                        return { dist: Math.sqrt(d2), val: t.kpis[kgObjKey] ?? 0 };
                      }).sort((a, b) => a.dist - b.dist);
                      const nn = distAfter.slice(0, kgK);
                      const mean = nn.reduce((s, d) => s + d.val, 0) / kgK;
                      kgUncAfter += Math.sqrt(nn.reduce((s, d) => s + (d.val - mean) ** 2, 0) / kgK);
                      if (prevPool.length >= kgK) {
                        const distBefore = prevPool.map(t => {
                          let d2 = 0;
                          for (const r of kgRanges) { const a = pt[r.name]; const b = kgNorm(t.parameters[r.name] ?? 0, r.lo, r.hi); d2 += (a - b) ** 2; }
                          return { dist: Math.sqrt(d2), val: t.kpis[kgObjKey] ?? 0 };
                        }).sort((a, b) => a.dist - b.dist);
                        const nnB = distBefore.slice(0, kgK);
                        const meanB = nnB.reduce((s, d) => s + d.val, 0) / kgK;
                        kgUncBefore += Math.sqrt(nnB.reduce((s, d) => s + (d.val - meanB) ** 2, 0) / kgK);
                      }
                    }
                  }
                  kgUncAfter /= kgGridCount;
                  kgUncBefore /= kgGridCount;
                  const reduction = Math.max(0, kgUncBefore - kgUncAfter);
                  kgGains.push(reduction);
                }
                if (kgGains.length < 3) return null;
                const kgMax = Math.max(...kgGains, 0.001);
                const kgAvgRecent = kgGains.slice(-5).reduce((s, v) => s + v, 0) / Math.min(5, kgGains.length);
                const kgAvgAll = kgGains.reduce((s, v) => s + v, 0) / kgGains.length;
                const kgRatio = kgAvgAll > 0 ? kgAvgRecent / kgAvgAll : 1;
                const kgBadge = kgRatio > 1.2 ? "Efficient" : kgRatio > 0.5 ? "Moderate" : "Diminishing";
                const kgBadgeColor = kgRatio > 1.2 ? "var(--color-green, #22c55e)" : kgRatio > 0.5 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const kgW = 280, kgH = 100, kgPad = 30;
                const kgPts = kgGains.map((v, i) => ({
                  x: kgPad + (i / (kgGains.length - 1)) * (kgW - 2 * kgPad),
                  y: 8 + (1 - v / kgMax) * (kgH - 20),
                }));
                const kgArea = kgPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ")
                  + ` L${kgPts[kgPts.length - 1].x.toFixed(1)},${kgH - 4} L${kgPts[0].x.toFixed(1)},${kgH - 4} Z`;
                const kgLine = kgPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                return (
                  <div className="card" style={{ padding: "20px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "10px", marginBottom: "12px" }}>
                      <Banknote size={18} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.95rem" }}>Knowledge Gain Per Cost</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: kgBadgeColor + "22", color: kgBadgeColor }}>{kgBadge}</span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: "8px" }}>
                      Uncertainty reduction per trial — are your experiments efficiently reducing model uncertainty?
                    </div>
                    <svg width={kgW} height={kgH} viewBox={`0 0 ${kgW} ${kgH}`} style={{ width: "100%", height: "auto" }}>
                      <defs>
                        <linearGradient id="kgGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor={kgBadgeColor} stopOpacity="0.3" />
                          <stop offset="100%" stopColor={kgBadgeColor} stopOpacity="0.02" />
                        </linearGradient>
                      </defs>
                      <path d={kgArea} fill="url(#kgGrad)" />
                      <path d={kgLine} fill="none" stroke={kgBadgeColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      {kgPts.map((p, i) => (
                        <circle key={i} cx={p.x} cy={p.y} r={i === kgPts.length - 1 ? 3.5 : 1.5} fill={kgBadgeColor} opacity={i === kgPts.length - 1 ? 1 : 0.5} />
                      ))}
                      {/* x-axis labels */}
                      <text x={kgPad} y={kgH} textAnchor="middle" style={{ fontSize: "0.55rem", fill: "var(--color-text-muted)" }}>#{kgWin + 1}</text>
                      <text x={kgW - kgPad} y={kgH} textAnchor="middle" style={{ fontSize: "0.55rem", fill: "var(--color-text-muted)" }}>#{kgSorted.length}</text>
                      <text x={(kgW) / 2} y={kgH} textAnchor="middle" style={{ fontSize: "0.55rem", fill: "var(--color-text-muted)" }}>Trial</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "6px", fontSize: "0.75rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>Avg gain: <span style={{ fontWeight: 600, fontFamily: "var(--font-mono)" }}>{kgAvgAll.toFixed(4)}</span></span>
                      <span style={{ color: kgBadgeColor, fontWeight: 600 }}>Recent: {kgAvgRecent.toFixed(4)} ({kgRatio > 1 ? "+" : ""}{((kgRatio - 1) * 100).toFixed(0)}%)</span>
                    </div>
                  </div>
                );
              })()}

              {/* Robustness Heatmap — parameter stability across bootstrap resamples */}
              {trials.length >= 10 && (() => {
                const rsSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rsSpecs.length < 2) return null;
                const rsSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const rsObjKey = Object.keys(rsSorted[0].kpis)[0];
                if (!rsObjKey) return null;
                const rsN = rsSorted.length;
                const rsParams = rsSpecs.slice(0, 6).map((s: { name: string }) => s.name); // max 6
                // Bootstrap resampling (20 bootstrap samples)
                const rsNBoot = 20;
                const rsTopK = Math.max(3, Math.floor(rsN * 0.25)); // top 25%
                // For each bootstrap: find top-K by KPI, compute mean of each param
                const rsBootMeans: number[][] = []; // [bootstrap][param]
                let rsSeed = 42;
                const rsRng = () => { rsSeed = (rsSeed * 1103515245 + 12345) & 0x7fffffff; return rsSeed / 0x7fffffff; };
                for (let b = 0; b < rsNBoot; b++) {
                  const rsSample = Array.from({ length: rsN }, () => rsSorted[Math.floor(rsRng() * rsN)]);
                  rsSample.sort((a, b2) => (Number(b2.kpis[rsObjKey]) || 0) - (Number(a.kpis[rsObjKey]) || 0));
                  const rsTop = rsSample.slice(0, rsTopK);
                  const rsMeans = rsParams.map(p => {
                    const vals = rsTop.map(t => Number(t.parameters[p]) || 0);
                    return vals.reduce((s, v) => s + v, 0) / vals.length;
                  });
                  rsBootMeans.push(rsMeans);
                }
                // Compute coefficient of variation for each param across bootstraps
                const rsCVs = rsParams.map((_p, pi) => {
                  const vals = rsBootMeans.map(bm => bm[pi]);
                  const mean = vals.reduce((s, v) => s + v, 0) / vals.length;
                  const std = Math.sqrt(vals.reduce((s, v) => s + (v - mean) ** 2, 0) / vals.length);
                  return mean !== 0 ? Math.abs(std / mean) : 0;
                });
                // Stability score: 1 - normalized CV (lower CV = more stable)
                const rsMaxCV = Math.max(...rsCVs, 0.01);
                const rsStability = rsCVs.map(cv => 1 - Math.min(cv / rsMaxCV, 1));
                // Compute per-bootstrap stability for heatmap rows
                const rsHeatData: number[][] = []; // [boot_group][param]
                const rsGroupSize = Math.ceil(rsNBoot / 5);
                for (let g = 0; g < 5; g++) {
                  const start = g * rsGroupSize;
                  const end = Math.min((g + 1) * rsGroupSize, rsNBoot);
                  const rsGroupMeans = rsParams.map((_p, pi) => {
                    const vals = rsBootMeans.slice(start, end).map(bm => bm[pi]);
                    const mean = vals.reduce((s, v) => s + v, 0) / vals.length;
                    const std = Math.sqrt(vals.reduce((s, v) => s + (v - mean) ** 2, 0) / vals.length);
                    return mean !== 0 ? 1 - Math.min(Math.abs(std / mean) / rsMaxCV, 1) : 0.5;
                  });
                  rsHeatData.push(rsGroupMeans);
                }
                const rsAvgStability = rsStability.reduce((s, v) => s + v, 0) / rsStability.length;
                const rsBadge = rsAvgStability > 0.7 ? "Robust" : rsAvgStability > 0.4 ? "Mixed" : "Fragile";
                const rsBadgeColor = rsAvgStability > 0.7 ? "var(--color-green, #22c55e)" : rsAvgStability > 0.4 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Heatmap dimensions
                const rsCols = rsParams.length;
                const rsRows = rsHeatData.length;
                const rsCellW = Math.min(40, 220 / rsCols);
                const rsCellH = 22;
                const rsLabelW = 70;
                const rsW = rsLabelW + rsCols * rsCellW + 10;
                const rsHdrH = 40;
                const rsTotalH = rsHdrH + rsRows * rsCellH + 5;
                const rsColor = (v: number) => {
                  if (v > 0.7) return "var(--color-green, #22c55e)";
                  if (v > 0.4) return "var(--color-yellow, #eab308)";
                  return "var(--color-red, #ef4444)";
                };
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Anchor size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Robustness Heatmap</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: rsBadgeColor + "18", color: rsBadgeColor }}>{rsBadge}</span>
                    </div>
                    <svg width={rsW} height={rsTotalH} viewBox={`0 0 ${rsW} ${rsTotalH}`} style={{ display: "block", margin: "0 auto" }}>
                      {/* Column headers */}
                      {rsParams.map((p, ci) => (
                        <text key={ci} x={rsLabelW + ci * rsCellW + rsCellW / 2} y={rsHdrH - 5} textAnchor="middle" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>
                          {p.length > 6 ? p.slice(0, 5) + "…" : p}
                        </text>
                      ))}
                      {/* Heatmap rows */}
                      {rsHeatData.map((row, ri) => (
                        <g key={ri}>
                          <text x={rsLabelW - 4} y={rsHdrH + ri * rsCellH + rsCellH / 2 + 4} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Boot {ri + 1}</text>
                          {row.map((v, ci) => (
                            <g key={ci}>
                              <rect x={rsLabelW + ci * rsCellW} y={rsHdrH + ri * rsCellH} width={rsCellW - 1} height={rsCellH - 1} rx={3} fill={rsColor(v)} opacity={0.2 + v * 0.6} />
                              <text x={rsLabelW + ci * rsCellW + rsCellW / 2} y={rsHdrH + ri * rsCellH + rsCellH / 2 + 3.5} textAnchor="middle" style={{ fontSize: "0.5rem", fontFamily: "var(--font-mono)", fontWeight: 600, fill: v > 0.5 ? rsColor(v) : "var(--color-text-muted)" }}>
                                {(v * 100).toFixed(0)}
                              </text>
                            </g>
                          ))}
                        </g>
                      ))}
                    </svg>
                    {/* Bottom stability bar */}
                    <div style={{ display: "flex", gap: "4px", marginTop: "10px", alignItems: "center" }}>
                      <span style={{ fontSize: "0.7rem", color: "var(--color-text-muted)", width: "65px", flexShrink: 0 }}>Stability:</span>
                      {rsParams.map((_p, i) => (
                        <div key={i} style={{ flex: 1, textAlign: "center" }}>
                          <div style={{ height: "6px", borderRadius: "3px", background: "var(--color-border)", overflow: "hidden" }}>
                            <div style={{ width: `${rsStability[i] * 100}%`, height: "100%", borderRadius: "3px", background: rsColor(rsStability[i]), transition: "width 0.3s ease" }} />
                          </div>
                          <div style={{ fontSize: "0.55rem", fontFamily: "var(--font-mono)", color: rsColor(rsStability[i]), marginTop: "2px" }}>{(rsStability[i] * 100).toFixed(0)}%</div>
                        </div>
                      ))}
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "8px", textAlign: "center" }}>
                      {rsBadge === "Robust" ? "Top-performing regions are stable across resamples — high confidence in optimal parameters." :
                       rsBadge === "Mixed" ? "Some parameters show instability — consider focusing exploration on fragile dimensions." :
                       "Parameter rankings shift significantly across resamples — more data needed for reliable conclusions."}
                    </div>
                  </div>
                );
              })()}

              {/* Local Sensitivity Map — finite-difference sensitivity at best point */}
              {trials.length >= 8 && (() => {
                const lsSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (lsSpecs.length < 2) return null;
                const lsObjKey = Object.keys(trials[0].kpis)[0];
                if (!lsObjKey) return null;
                const lsSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Find best trial
                const lsBest = lsSorted.reduce((best, t) => (Number(t.kpis[lsObjKey]) || 0) < (Number(best.kpis[lsObjKey]) || 0) ? t : best);
                const lsBestParams = lsSpecs.map((s: { name: string }) => Number(lsBest.parameters[s.name]) || 0);
                // For each parameter, compute local sensitivity via k-NN
                const lsParamNames = lsSpecs.map((s: { name: string }) => s.name);
                const lsRanges = lsSpecs.map((s: { lower?: number; upper?: number }) => (s.upper ?? 1) - (s.lower ?? 0));
                const lsSensitivities = lsParamNames.map((_p: string, pi: number) => {
                  // Find trials near best point but varying in this parameter
                  const lsEps = lsRanges[pi] * 0.15;
                  // Partition into "lower" and "upper" neighbors along this param
                  const bestVal = lsBestParams[pi];
                  const lsLower = lsSorted.filter(t => {
                    const v = Number(t.parameters[lsParamNames[pi]]) || 0;
                    if (v >= bestVal - lsEps && v < bestVal) {
                      // Check other params are close
                      return lsParamNames.every((p2: string, j: number) => j === pi || Math.abs((Number(t.parameters[p2]) || 0) - lsBestParams[j]) < lsRanges[j] * 0.3);
                    }
                    return false;
                  });
                  const lsUpper = lsSorted.filter(t => {
                    const v = Number(t.parameters[lsParamNames[pi]]) || 0;
                    if (v > bestVal && v <= bestVal + lsEps) {
                      return lsParamNames.every((p2: string, j: number) => j === pi || Math.abs((Number(t.parameters[p2]) || 0) - lsBestParams[j]) < lsRanges[j] * 0.3);
                    }
                    return false;
                  });
                  // If not enough neighbors, use broader k-NN approach
                  if (lsLower.length === 0 && lsUpper.length === 0) {
                    // Fall back: compute correlation between this param and objective in local neighborhood
                    const lsK = Math.min(15, Math.floor(lsSorted.length * 0.3));
                    const lsDists = lsSorted.map(t => ({
                      d: Math.sqrt(lsParamNames.reduce((s: number, p: string, j: number) => s + ((Number(t.parameters[p]) || 0) - lsBestParams[j]) ** 2 / (lsRanges[j] || 1) ** 2, 0)),
                      pv: Number(t.parameters[lsParamNames[pi]]) || 0,
                      ov: Number(t.kpis[lsObjKey]) || 0,
                    })).sort((a, b) => a.d - b.d).slice(0, lsK);
                    if (lsDists.length < 3) return 0;
                    const pmean = lsDists.reduce((s, d) => s + d.pv, 0) / lsDists.length;
                    const omean = lsDists.reduce((s, d) => s + d.ov, 0) / lsDists.length;
                    const pstd = Math.sqrt(lsDists.reduce((s, d) => s + (d.pv - pmean) ** 2, 0) / lsDists.length);
                    const ostd = Math.sqrt(lsDists.reduce((s, d) => s + (d.ov - omean) ** 2, 0) / lsDists.length);
                    if (pstd < 1e-10 || ostd < 1e-10) return 0;
                    const corr = lsDists.reduce((s, d) => s + (d.pv - pmean) * (d.ov - omean), 0) / (lsDists.length * pstd * ostd);
                    return Math.abs(corr);
                  }
                  const lsAvgLower = lsLower.length > 0 ? lsLower.reduce((s, t) => s + (Number(t.kpis[lsObjKey]) || 0), 0) / lsLower.length : Number(lsBest.kpis[lsObjKey]) || 0;
                  const lsAvgUpper = lsUpper.length > 0 ? lsUpper.reduce((s, t) => s + (Number(t.kpis[lsObjKey]) || 0), 0) / lsUpper.length : Number(lsBest.kpis[lsObjKey]) || 0;
                  const lsDeltaObj = Math.abs(lsAvgUpper - lsAvgLower);
                  const lsRange = lsRanges[pi] || 1;
                  return lsDeltaObj / lsRange;
                });
                const lsMaxSens = Math.max(...lsSensitivities, 0.001);
                const lsNormalized = lsSensitivities.map((s: number) => s / lsMaxSens);
                const lsHighCount = lsNormalized.filter((v: number) => v > 0.6).length;
                const lsBadge = lsHighCount > lsNormalized.length * 0.5 ? "Sensitive" : lsHighCount > 0 ? "Moderate" : "Robust";
                const lsBadgeColor = lsBadge === "Sensitive" ? "var(--color-red, #ef4444)" : lsBadge === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)";
                // Horizontal bar chart
                const lsBarH = 20;
                const lsLabelW = 70;
                const lsBarMaxW = 180;
                const lsTotalH = lsParamNames.length * (lsBarH + 4) + 10;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Diff size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Local Sensitivity Map</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: lsBadgeColor + "18", color: lsBadgeColor }}>{lsBadge}</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginBottom: "8px" }}>Sensitivity of objective to each parameter near the best point.</div>
                    <svg width={lsLabelW + lsBarMaxW + 50} height={lsTotalH} viewBox={`0 0 ${lsLabelW + lsBarMaxW + 50} ${lsTotalH}`} style={{ display: "block", margin: "0 auto" }}>
                      {lsParamNames.map((p: string, i: number) => {
                        const y = i * (lsBarH + 4) + 5;
                        const w = lsNormalized[i] * lsBarMaxW;
                        const barColor = lsNormalized[i] > 0.6 ? "var(--color-red, #ef4444)" : lsNormalized[i] > 0.3 ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)";
                        return (
                          <g key={i}>
                            <text x={lsLabelW - 4} y={y + lsBarH / 2 + 4} textAnchor="end" style={{ fontSize: "0.55rem", fontFamily: "var(--font-mono)", fill: "var(--color-text-muted)" }}>{p.length > 8 ? p.slice(0, 7) + "…" : p}</text>
                            <rect x={lsLabelW} y={y} width={lsBarMaxW} height={lsBarH} rx={4} fill="var(--color-border)" opacity={0.3} />
                            <rect x={lsLabelW} y={y} width={Math.max(w, 2)} height={lsBarH} rx={4} fill={barColor} opacity={0.7} />
                            <text x={lsLabelW + Math.max(w, 2) + 4} y={y + lsBarH / 2 + 4} style={{ fontSize: "0.55rem", fontFamily: "var(--font-mono)", fontWeight: 600, fill: barColor }}>{(lsNormalized[i] * 100).toFixed(0)}%</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "6px", textAlign: "center" }}>
                      {lsBadge === "Sensitive" ? "Objective changes sharply near optimum — precise parameter control is critical." :
                       lsBadge === "Moderate" ? "Some parameters strongly affect the objective near optimum — focus tuning there." :
                       "Objective is flat near optimum — robust to small parameter variations."}
                    </div>
                  </div>
                );
              })()}

              {/* Interaction Heatmap */}
              {trials.length >= 15 && (() => {
                const ihSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (ihSpecs.length < 2) return null;
                const ihTop = ihSpecs.slice(0, 5);
                const ihObjKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!ihObjKey) return null;
                // Normalize parameters to [0,1]
                const ihNorm = trials.map(t => {
                  const row: Record<string, number> = {};
                  ihTop.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const lo = s.lower ?? 0, hi = s.upper ?? 1;
                    row[s.name] = hi > lo ? ((Number(t.parameters[s.name]) || 0) - lo) / (hi - lo) : 0.5;
                  });
                  return { params: row, obj: Number(t.kpis[ihObjKey]) || 0 };
                });
                // Compute interaction strength: for each pair (i,j), compute
                // corr(xi*xj, residual after main effects)
                const ihN = ihNorm.length;
                const ihMean = (arr: number[]) => arr.reduce((s, v) => s + v, 0) / arr.length;
                const ihCorr = (a: number[], b: number[]) => {
                  const ma = ihMean(a), mb = ihMean(b);
                  let num = 0, da = 0, db = 0;
                  for (let k = 0; k < a.length; k++) {
                    const ai = a[k] - ma, bi = b[k] - mb;
                    num += ai * bi; da += ai * ai; db += bi * bi;
                  }
                  return da > 0 && db > 0 ? num / Math.sqrt(da * db) : 0;
                };
                const ihObjArr = ihNorm.map(r => r.obj);
                // Main effect residuals
                const ihMainEffects = ihTop.map((s: { name: string }) => {
                  const xs = ihNorm.map(r => r.params[s.name]);
                  const c = ihCorr(xs, ihObjArr);
                  return { name: s.name, corr: c };
                });
                // Predicted by main effects only
                const ihObjMean = ihMean(ihObjArr);
                const ihObjStd = Math.sqrt(ihObjArr.reduce((s, v) => s + (v - ihObjMean) ** 2, 0) / ihN);
                const ihResiduals = ihNorm.map((r, k) => {
                  let pred = ihObjMean;
                  ihMainEffects.forEach(me => {
                    pred += me.corr * (r.params[me.name] - 0.5) * ihObjStd;
                  });
                  return ihObjArr[k] - pred;
                });
                // Interaction matrix: corr(xi*xj, residuals)
                const ihMatrix: { i: number; j: number; strength: number }[] = [];
                let ihMaxStr = 0;
                for (let i = 0; i < ihTop.length; i++) {
                  for (let j = i + 1; j < ihTop.length; j++) {
                    const cross = ihNorm.map(r => r.params[ihTop[i].name] * r.params[ihTop[j].name]);
                    const str = Math.abs(ihCorr(cross, ihResiduals));
                    ihMatrix.push({ i, j, strength: str });
                    if (str > ihMaxStr) ihMaxStr = str;
                  }
                }
                const ihSignificant = ihMatrix.filter(m => m.strength > 0.3).length;
                const ihBadge = ihSignificant === 0 ? "Independent" : ihSignificant <= 2 ? "Mild Coupling" : "Interacting";
                const ihBadgeColor = ihSignificant === 0 ? "var(--color-green, #22c55e)" : ihSignificant <= 2 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Heatmap
                const ihCellSize = 36;
                const ihLabelW = 52;
                const ihN2 = ihTop.length;
                const ihW = ihLabelW + ihN2 * ihCellSize + 4;
                const ihH = ihLabelW + ihN2 * ihCellSize + 4;
                const ihGetColor = (str: number) => {
                  const t = Math.min(1, str / Math.max(0.5, ihMaxStr));
                  const r = Math.round(34 + t * 221);
                  const g = Math.round(197 - t * 153);
                  const b = Math.round(94 - t * 0);
                  return `rgb(${r},${g},${b})`;
                };
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Link2 size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Interaction Heatmap</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: ihBadgeColor + "18", color: ihBadgeColor }}>{ihBadge}</span>
                    </div>
                    <svg width={ihW} height={ihH} style={{ width: "100%", maxWidth: ihW }}>
                      {/* Column labels */}
                      {ihTop.map((s: { name: string }, ci: number) => (
                        <text key={`ih-col-${ci}`} x={ihLabelW + ci * ihCellSize + ihCellSize / 2} y={ihLabelW - 4} textAnchor="middle" fontSize={7} fill="var(--color-text-muted)" style={{ fontFamily: "var(--font-mono)" }}>
                          {s.name.length > 6 ? s.name.slice(0, 6) : s.name}
                        </text>
                      ))}
                      {/* Row labels + cells */}
                      {ihTop.map((_: { name: string }, ri: number) => (
                        <g key={`ih-row-${ri}`}>
                          <text x={ihLabelW - 4} y={ihLabelW + ri * ihCellSize + ihCellSize / 2 + 3} textAnchor="end" fontSize={7} fill="var(--color-text-muted)" style={{ fontFamily: "var(--font-mono)" }}>
                            {ihTop[ri].name.length > 6 ? ihTop[ri].name.slice(0, 6) : ihTop[ri].name}
                          </text>
                          {ihTop.map((_2: { name: string }, ci: number) => {
                            if (ri === ci) {
                              return (
                                <rect key={`ih-cell-${ri}-${ci}`} x={ihLabelW + ci * ihCellSize} y={ihLabelW + ri * ihCellSize} width={ihCellSize - 2} height={ihCellSize - 2} rx={3} fill="var(--color-border)" opacity={0.4} />
                              );
                            }
                            const entry = ihMatrix.find(m => (m.i === Math.min(ri, ci) && m.j === Math.max(ri, ci)));
                            const str = entry?.strength ?? 0;
                            return (
                              <g key={`ih-cell-${ri}-${ci}`}>
                                <rect x={ihLabelW + ci * ihCellSize} y={ihLabelW + ri * ihCellSize} width={ihCellSize - 2} height={ihCellSize - 2} rx={3} fill={ihGetColor(str)} opacity={0.7}>
                                  <title>{ihTop[ri].name} × {ihTop[ci].name}: {str.toFixed(3)}</title>
                                </rect>
                                <text x={ihLabelW + ci * ihCellSize + (ihCellSize - 2) / 2} y={ihLabelW + ri * ihCellSize + (ihCellSize - 2) / 2 + 3} textAnchor="middle" fontSize={7.5} fill={str > 0.4 ? "#fff" : "var(--color-text)"} fontWeight={str > 0.3 ? 600 : 400}>
                                  {str.toFixed(2)}
                                </text>
                              </g>
                            );
                          })}
                        </g>
                      ))}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "6px", fontSize: "0.73rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>{ihSignificant} significant interaction{ihSignificant !== 1 ? "s" : ""} (|ρ| &gt; 0.3)</span>
                      <span style={{ display: "flex", alignItems: "center", gap: "4px" }}>
                        <span style={{ width: "10px", height: "10px", borderRadius: "2px", background: ihGetColor(0), display: "inline-block" }} />
                        <span style={{ fontSize: "0.68rem", color: "var(--color-text-muted)" }}>weak</span>
                        <span style={{ width: "10px", height: "10px", borderRadius: "2px", background: ihGetColor(ihMaxStr), display: "inline-block" }} />
                        <span style={{ fontSize: "0.68rem", color: "var(--color-text-muted)" }}>strong</span>
                      </span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {ihBadge === "Independent" ? "Parameters act independently — main effects dominate the response." :
                       ihBadge === "Mild Coupling" ? "Some parameter pairs interact — joint tuning may improve results." :
                       "Strong interactions detected — parameter combinations matter more than individual values."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Effect Monotonicity (Batch 27) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 8) return null;
                const emSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (emSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const emObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (emObs.length < 8) return null;
                // for each parameter, sort obs by parameter value and check monotonicity
                const emResults: { name: string; score: number; direction: string }[] = [];
                emSpecs.forEach((spec: { name: string }) => {
                  const sorted = [...emObs].sort((a: { parameters: Record<string, number> }, b: { parameters: Record<string, number> }) =>
                    (a.parameters[spec.name] || 0) - (b.parameters[spec.name] || 0)
                  );
                  const vals = sorted.map((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey]);
                  // compute monotonicity score: fraction of consecutive pairs that go in the same direction
                  let emUp = 0, emDown = 0;
                  for (let i = 1; i < vals.length; i++) {
                    if (vals[i] > vals[i - 1]) emUp++;
                    else if (vals[i] < vals[i - 1]) emDown++;
                  }
                  const emTotal = vals.length - 1;
                  const emMonoScore = emTotal > 0 ? Math.max(emUp, emDown) / emTotal : 0;
                  const emDir = emUp >= emDown ? "increasing" : "decreasing";
                  emResults.push({ name: spec.name, score: emMonoScore, direction: emDir });
                });
                emResults.sort((a, b) => b.score - a.score);
                const emMonoCount = emResults.filter(r => r.score > 0.7).length;
                const emBadge = emMonoCount === emResults.length ? "Monotonic"
                  : emMonoCount >= emResults.length * 0.5 ? "Mixed" : "Complex";
                const emBadgeColor = emBadge === "Monotonic" ? "var(--color-green, #22c55e)"
                  : emBadge === "Mixed" ? "var(--color-yellow, #eab308)" : "var(--color-purple, #a855f7)";
                const emBarW = 200, emBarH = emResults.length * 28 + 4;
                const emMaxLabel = Math.max(...emResults.map(r => r.name.length));
                const emLabelW = Math.min(emMaxLabel * 7 + 10, 90);
                const emChartW = emBarW - emLabelW - 35;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <MoveUpRight size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Effect Monotonicity</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: emBadgeColor, color: "#fff" }}>{emBadge}</span>
                    </div>
                    <svg width={emBarW} height={emBarH} viewBox={`0 0 ${emBarW} ${emBarH}`} style={{ display: "block", width: "100%" }}>
                      {emResults.map((r, i) => {
                        const y = i * 28 + 2;
                        const barLen = r.score * emChartW;
                        const color = r.score > 0.7 ? "var(--color-green, #22c55e)" : r.score > 0.5 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        const arrow = r.direction === "increasing" ? "↑" : "↓";
                        return (
                          <g key={r.name}>
                            <text x={emLabelW - 4} y={y + 16} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{r.name.length > 12 ? r.name.slice(0, 11) + "…" : r.name}</text>
                            <rect x={emLabelW} y={y + 4} width={emChartW} height="16" rx="3" fill="var(--color-border, #e2e8f0)" />
                            <rect x={emLabelW} y={y + 4} width={Math.max(barLen, 2)} height="16" rx="3" fill={color} opacity="0.8" />
                            <text x={emLabelW + emChartW + 3} y={y + 16} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">{arrow}{(r.score * 100).toFixed(0)}%</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {emMonoCount}/{emResults.length} parameters show monotonic effects — {emBadge === "Monotonic" ? "simple response surface." : emBadge === "Mixed" ? "some non-linear patterns." : "highly non-linear landscape."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Response Roughness (Batch 28) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 8) return null;
                const rrSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (rrSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const rrObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (rrObs.length < 8) return null;
                // compute per-parameter roughness: average |diff| of kpi between consecutive obs sorted by parameter
                const rrKpiRange = (() => {
                  const vals = rrObs.map((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey]);
                  return Math.max(...vals) - Math.min(...vals) || 1;
                })();
                const rrResults: { name: string; roughness: number }[] = [];
                rrSpecs.forEach((spec: { name: string }) => {
                  const sorted = [...rrObs].sort((a: { parameters: Record<string, number> }, b: { parameters: Record<string, number> }) =>
                    (a.parameters[spec.name] || 0) - (b.parameters[spec.name] || 0)
                  );
                  let sumDiff = 0;
                  for (let i = 1; i < sorted.length; i++) {
                    sumDiff += Math.abs(sorted[i].kpi_values[kpiKey] - sorted[i - 1].kpi_values[kpiKey]);
                  }
                  const avgDiff = sumDiff / (sorted.length - 1);
                  // normalize by kpi range
                  rrResults.push({ name: spec.name, roughness: avgDiff / rrKpiRange });
                });
                rrResults.sort((a, b) => b.roughness - a.roughness);
                const rrAvg = rrResults.reduce((s, r) => s + r.roughness, 0) / rrResults.length;
                const rrBadge = rrAvg < 0.15 ? "Smooth" : rrAvg < 0.35 ? "Moderate" : "Rough";
                const rrBadgeColor = rrBadge === "Smooth" ? "var(--color-green, #22c55e)" : rrBadge === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const rrBarW = 200, rrBarH = rrResults.length * 28 + 4;
                const rrMaxLabel = Math.min(Math.max(...rrResults.map(r => r.name.length)) * 7 + 10, 90);
                const rrChartW = rrBarW - rrMaxLabel - 35;
                const rrMaxVal = Math.max(...rrResults.map(r => r.roughness), 0.01);
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Waves size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Response Roughness</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: rrBadgeColor, color: "#fff" }}>{rrBadge}</span>
                    </div>
                    <svg width={rrBarW} height={rrBarH} viewBox={`0 0 ${rrBarW} ${rrBarH}`} style={{ display: "block", width: "100%" }}>
                      {rrResults.map((r, i) => {
                        const y = i * 28 + 2;
                        const barLen = (r.roughness / rrMaxVal) * rrChartW;
                        const color = r.roughness < 0.15 ? "var(--color-green, #22c55e)" : r.roughness < 0.35 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={r.name}>
                            <text x={rrMaxLabel - 4} y={y + 16} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{r.name.length > 12 ? r.name.slice(0, 11) + "…" : r.name}</text>
                            <rect x={rrMaxLabel} y={y + 4} width={rrChartW} height="16" rx="3" fill="var(--color-border, #e2e8f0)" />
                            <rect x={rrMaxLabel} y={y + 4} width={Math.max(barLen, 2)} height="16" rx="3" fill={color} opacity="0.8" />
                            <text x={rrMaxLabel + rrChartW + 3} y={y + 16} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">{(r.roughness * 100).toFixed(0)}%</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {rrBadge === "Smooth" ? "Response surface is smooth — surrogate models should fit well." : rrBadge === "Moderate" ? "Some roughness — consider noise-tolerant models." : "High roughness — the response is noisy or highly non-linear."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Parameter Efficiency Rank (Batch 29) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 8) return null;
                const peSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (peSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const peObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (peObs.length < 8) return null;
                // for each parameter, compute "efficiency" = |correlation with kpi| / fraction_of_range_explored
                const peResults: { name: string; efficiency: number; corr: number; coverage: number }[] = [];
                const peKpiVals = peObs.map((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey]);
                const peKpiMean = peKpiVals.reduce((s: number, v: number) => s + v, 0) / peKpiVals.length;
                const peKpiStd = Math.sqrt(peKpiVals.reduce((s: number, v: number) => s + (v - peKpiMean) ** 2, 0) / peKpiVals.length) || 1;
                peSpecs.forEach((spec: { name: string; lower?: number; upper?: number }) => {
                  const range = (spec.upper || 1) - (spec.lower || 0);
                  if (range <= 0) return;
                  const pVals = peObs.map((o: { parameters: Record<string, number> }) => o.parameters[spec.name]);
                  const pMean = pVals.reduce((s: number, v: number) => s + v, 0) / pVals.length;
                  const pStd = Math.sqrt(pVals.reduce((s: number, v: number) => s + (v - pMean) ** 2, 0) / pVals.length) || 1;
                  // Pearson correlation
                  let peSum = 0;
                  for (let i = 0; i < peObs.length; i++) {
                    peSum += (pVals[i] - pMean) * (peKpiVals[i] - peKpiMean);
                  }
                  const corr = peSum / (peObs.length * pStd * peKpiStd);
                  // coverage
                  const coverage = (Math.max(...pVals) - Math.min(...pVals)) / range;
                  // efficiency: high |correlation| per unit coverage (more info per range used)
                  const efficiency = coverage > 0.05 ? Math.abs(corr) / coverage : 0;
                  peResults.push({ name: spec.name, efficiency, corr, coverage });
                });
                peResults.sort((a, b) => b.efficiency - a.efficiency);
                const peMaxEff = Math.max(...peResults.map(r => r.efficiency), 0.01);
                const peTopEff = peResults[0]?.efficiency || 0;
                const peSecondEff = peResults[1]?.efficiency || 0;
                const peBadge = peTopEff > peSecondEff * 2 ? "Clear Leaders" : peResults.filter(r => r.efficiency > peMaxEff * 0.5).length >= peResults.length * 0.7 ? "Even" : "No Signal";
                const peBadgeColor = peBadge === "Clear Leaders" ? "var(--color-green, #22c55e)" : peBadge === "Even" ? "var(--color-blue, #3b82f6)" : "var(--color-text-muted, #94a3b8)";
                const peBarW = 200, peBarH = peResults.length * 28 + 4;
                const peLabelW = Math.min(Math.max(...peResults.map(r => r.name.length)) * 7 + 10, 90);
                const peChartW = peBarW - peLabelW - 35;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Award size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Parameter Efficiency Rank</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: peBadgeColor, color: "#fff" }}>{peBadge}</span>
                    </div>
                    <svg width={peBarW} height={peBarH} viewBox={`0 0 ${peBarW} ${peBarH}`} style={{ display: "block", width: "100%" }}>
                      {peResults.map((r, i) => {
                        const y = i * 28 + 2;
                        const barLen = (r.efficiency / peMaxEff) * peChartW;
                        const color = i === 0 ? "var(--color-green, #22c55e)" : i < 3 ? "var(--color-primary, #6366f1)" : "var(--color-text-muted, #94a3b8)";
                        return (
                          <g key={r.name}>
                            <text x={peLabelW - 4} y={y + 16} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{r.name.length > 12 ? r.name.slice(0, 11) + "…" : r.name}</text>
                            <rect x={peLabelW} y={y + 4} width={peChartW} height="16" rx="3" fill="var(--color-border, #e2e8f0)" />
                            <rect x={peLabelW} y={y + 4} width={Math.max(barLen, 2)} height="16" rx="3" fill={color} opacity="0.8" />
                            <text x={peLabelW + peChartW + 3} y={y + 16} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">{r.efficiency.toFixed(2)}</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      KPI correlation per unit range explored — higher = more informative parameter.
                    </div>
                  </div>
                );
              })()}

              {/* ── Embedding Fidelity (Batch 30) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const efSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (efSpecs.length < 3) return null; // need ≥3 dims for projection to matter
                const efObs = campaign.observations;
                const efN = Math.min(efObs.length, 50); // cap for performance
                const efSample = efObs.slice(-efN);
                // normalize to [0,1] per parameter
                const efNorm = efSample.map((o: { parameters: Record<string, number> }) =>
                  efSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    return range > 0 ? ((o.parameters[s.name] || 0) - (s.lower || 0)) / range : 0;
                  })
                );
                // simple PCA: use first 2 principal components via power iteration on covariance
                const efD = efSpecs.length;
                const efMeans = Array(efD).fill(0);
                efNorm.forEach(row => row.forEach((v: number, j: number) => { efMeans[j] += v / efN; }));
                const efCentered = efNorm.map((row: number[]) => row.map((v: number, j: number) => v - efMeans[j]));
                // compute 2D projection via simplified SVD: project onto top-2 variance directions
                // for k-NN preservation, we just need the pairwise distances in original and projected space
                // Use random projection (fast, good enough for fidelity check)
                const efSeed = 42;
                const efRandVec = (seed: number) => {
                  const v: number[] = [];
                  let s = seed;
                  for (let i = 0; i < efD; i++) { s = (s * 1103515245 + 12345) & 0x7fffffff; v.push((s / 0x7fffffff) * 2 - 1); }
                  const norm = Math.sqrt(v.reduce((a, x) => a + x * x, 0)) || 1;
                  return v.map(x => x / norm);
                };
                const efV1 = efRandVec(efSeed);
                const efV2 = efRandVec(efSeed + 1);
                // project
                const efProj = efCentered.map((row: number[]) => [
                  row.reduce((s: number, v: number, j: number) => s + v * efV1[j], 0),
                  row.reduce((s: number, v: number, j: number) => s + v * efV2[j], 0),
                ]);
                // compute k-NN preservation (k=5)
                const efK = Math.min(5, efN - 1);
                const efDist = (a: number[], b: number[]) => Math.sqrt(a.reduce((s, v, i) => s + (v - b[i]) ** 2, 0));
                let efPreserved = 0;
                for (let i = 0; i < efN; i++) {
                  // high-D neighbors
                  const efHdDists = efCentered.map((r: number[], j: number) => ({ j, d: j === i ? Infinity : efDist(efCentered[i], r) })).sort((a: { d: number }, b: { d: number }) => a.d - b.d);
                  const efHdNeighbors = new Set(efHdDists.slice(0, efK).map((x: { j: number }) => x.j));
                  // low-D neighbors
                  const efLdDists = efProj.map((r: number[], j: number) => ({ j, d: j === i ? Infinity : efDist(efProj[i], r) })).sort((a: { d: number }, b: { d: number }) => a.d - b.d);
                  const efLdNeighbors = new Set(efLdDists.slice(0, efK).map((x: { j: number }) => x.j));
                  // count intersection
                  let efIntersect = 0;
                  efHdNeighbors.forEach(j => { if (efLdNeighbors.has(j)) efIntersect++; });
                  efPreserved += efIntersect / efK;
                }
                const efScore = efPreserved / efN;
                const efBadge = efScore > 0.7 ? "High Fidelity" : efScore > 0.45 ? "Moderate" : "Low Fidelity";
                const efBadgeColor = efBadge === "High Fidelity" ? "var(--color-green, #22c55e)" : efBadge === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // gauge arc
                const efW = 180, efH2 = 100;
                const efCx = efW / 2, efCy = 85, efR = 65;
                const efValAngle = Math.PI - efScore * Math.PI;
                const efArc = (sA: number, eA: number) => {
                  const x1 = efCx + efR * Math.cos(sA), y1 = efCy - efR * Math.sin(sA);
                  const x2 = efCx + efR * Math.cos(eA), y2 = efCy - efR * Math.sin(eA);
                  return `M${x1.toFixed(1)},${y1.toFixed(1)} A${efR},${efR} 0 ${Math.abs(sA - eA) > Math.PI ? 1 : 0} 0 ${x2.toFixed(1)},${y2.toFixed(1)}`;
                };
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Fingerprint size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Embedding Fidelity</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: efBadgeColor, color: "#fff" }}>{efBadge}</span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={efW} height={efH2} viewBox={`0 0 ${efW} ${efH2}`}>
                        <path d={efArc(Math.PI, 0)} fill="none" stroke="var(--color-border, #e2e8f0)" strokeWidth="10" strokeLinecap="round" />
                        <path d={efArc(Math.PI, efValAngle)} fill="none" stroke={efBadgeColor} strokeWidth="10" strokeLinecap="round" opacity="0.85" />
                        <line x1={efCx} y1={efCy} x2={efCx + (efR - 10) * Math.cos(efValAngle)} y2={efCy - (efR - 10) * Math.sin(efValAngle)} stroke="var(--color-text, #1e293b)" strokeWidth="1.5" strokeLinecap="round" />
                        <circle cx={efCx} cy={efCy} r="3" fill="var(--color-text, #1e293b)" />
                        <text x={efCx} y={efCy - 18} textAnchor="middle" fontSize="18" fontWeight="700" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{(efScore * 100).toFixed(0)}%</text>
                        <text x={efCx} y={efCy - 4} textAnchor="middle" fontSize="9" fill="var(--color-text-muted, #64748b)">k-NN preserved</text>
                      </svg>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", textAlign: "center", marginTop: "2px" }}>
                      {efBadge === "High Fidelity" ? "2D projections reliably represent high-D structure." : efBadge === "Moderate" ? "Some distortion — interpret visual clusters cautiously." : "Low preservation — 2D views may be misleading."}
                    </div>
                  </div>
                );
              })()}

              {/* Noise Floor Map */}
              {trials.length >= 15 && (() => {
                const nfParams = (campaign.spec?.parameters ?? []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (nfParams.length === 0) return null;
                const nfKey = Object.keys(trials[0]?.kpis ?? {})[0];
                if (!nfKey) return null;
                const nfObs = trials.filter((t: { kpis: Record<string, number> }) => t.kpis[nfKey] != null);
                if (nfObs.length < 15) return null;
                const nfResults: { name: string; noise: number }[] = [];
                for (const param of nfParams) {
                  const sorted = [...nfObs].sort((a: { parameters: Record<string, number> }, b: { parameters: Record<string, number> }) => (a.parameters[param.name] ?? 0) - (b.parameters[param.name] ?? 0));
                  const nfBinSize = Math.max(3, Math.floor(sorted.length / 5));
                  const variances: number[] = [];
                  for (let i = 0; i <= sorted.length - nfBinSize; i += Math.max(1, Math.floor(nfBinSize / 2))) {
                    const bin = sorted.slice(i, i + nfBinSize);
                    const vals = bin.map((t: { kpis: Record<string, number> }) => t.kpis[nfKey]);
                    const mean = vals.reduce((a: number, b: number) => a + b, 0) / vals.length;
                    const v = vals.reduce((a: number, b: number) => a + (b - mean) ** 2, 0) / vals.length;
                    variances.push(v);
                  }
                  const medianVar = [...variances].sort((a, b) => a - b)[Math.floor(variances.length / 2)] ?? 0;
                  nfResults.push({ name: param.name, noise: Math.sqrt(medianVar) });
                }
                const nfMax = Math.max(...nfResults.map(r => r.noise)) || 1;
                const nfAvg = nfResults.reduce((a, b) => a + b.noise, 0) / nfResults.length;
                const nfBadge = nfAvg / nfMax < 0.3 ? "Clean" : nfAvg / nfMax < 0.6 ? "Moderate" : "Noisy";
                const nfColor = nfBadge === "Clean" ? "var(--color-primary)" : nfBadge === "Moderate" ? "#eab308" : "#ef4444";
                const nfBarH = 18, nfGap = 4;
                const nfSvgH = nfResults.length * (nfBarH + nfGap) - nfGap + 4;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Radio size={16} style={{ color: "var(--color-primary)" }} />
                      <strong style={{ fontSize: "0.88rem" }}>Noise Floor Map</strong>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "6px", background: nfBadge === "Clean" ? "var(--color-success-bg)" : nfBadge === "Moderate" ? "rgba(234,179,8,0.12)" : "rgba(239,68,68,0.1)", color: nfColor }}>{nfBadge}</span>
                    </div>
                    <svg width="100%" height={nfSvgH} viewBox={`0 0 260 ${nfSvgH}`} style={{ display: "block", overflow: "visible" }}>
                      {nfResults.map((r, i) => {
                        const y = i * (nfBarH + nfGap) + 2;
                        const pct = nfMax > 0 ? (r.noise / nfMax) * 100 : 0;
                        const barCol = pct > 70 ? "#ef4444" : pct > 40 ? "#eab308" : "var(--color-primary)";
                        return (
                          <g key={r.name}>
                            <text x="0" y={y + nfBarH / 2 + 4} fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">{r.name.length > 8 ? r.name.slice(0, 7) + "…" : r.name}</text>
                            <rect x="70" y={y} width="140" height={nfBarH} rx="3" fill="var(--color-border)" />
                            <rect x="70" y={y} width={Math.max(2, 140 * pct / 100)} height={nfBarH} rx="3" fill={barCol} opacity="0.8" />
                            <text x="215" y={y + nfBarH / 2 + 4} fontSize="10" fontWeight="600" fill={barCol} fontFamily="var(--font-mono)">{(r.noise).toFixed(4)}</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {nfBadge === "Clean" ? "Low measurement noise — optimization can resolve fine differences." : nfBadge === "Moderate" ? "Moderate noise — consider replicates for noisy parameters." : "High noise floor — improvements near noise level may be statistical artifacts."}
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Correlation Summary */}
              {trials.length >= 5 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                const objValues = trials.map((t) => Object.values(t.kpis)[0] ?? 0);
                const correlations = paramNames.map((p) => {
                  const paramValues = trials.map((t) => Number(t.parameters[p]) || 0);
                  const n = paramValues.length;
                  const meanP = paramValues.reduce((a, b) => a + b, 0) / n;
                  const meanO = objValues.reduce((a, b) => a + b, 0) / n;
                  const stdP = Math.sqrt(paramValues.reduce((a, v) => a + (v - meanP) ** 2, 0) / n);
                  const stdO = Math.sqrt(objValues.reduce((a, v) => a + (v - meanO) ** 2, 0) / n);
                  if (stdP === 0 || stdO === 0) return { name: p, corr: 0 };
                  const cov = paramValues.reduce((a, v, i) => a + (v - meanP) * (objValues[i] - meanO), 0) / n;
                  return { name: p, corr: cov / (stdP * stdO) };
                }).sort((a, b) => Math.abs(b.corr) - Math.abs(a.corr));

                return (
                  <div className="card">
                    <h2>Parameter–Objective Correlation</h2>
                    <p style={{ fontSize: "0.82rem", color: "var(--color-text-muted)", marginBottom: "16px" }}>
                      Pearson correlation between each parameter and the primary objective.
                      Stronger values suggest higher influence.
                    </p>
                    <div className="correlation-list">
                      {correlations.map((c) => {
                        const absCorr = Math.abs(c.corr);
                        const color = absCorr > 0.5 ? "var(--color-primary)" : absCorr > 0.3 ? "var(--color-yellow)" : "var(--color-gray)";
                        const strength = absCorr > 0.5 ? "Strong" : absCorr > 0.3 ? "Moderate" : "Weak";
                        return (
                          <div key={c.name} className="correlation-row">
                            <span className="correlation-name mono">{c.name}</span>
                            <div className="correlation-bar-bg">
                              <div
                                className="correlation-bar-fill"
                                style={{
                                  width: `${absCorr * 100}%`,
                                  background: color,
                                  marginLeft: c.corr < 0 ? `${(1 - absCorr) * 50}%` : "50%",
                                }}
                              />
                            </div>
                            <span className="correlation-value mono" style={{ color }}>
                              {c.corr > 0 ? "+" : ""}{c.corr.toFixed(3)}
                            </span>
                            <span className="correlation-strength" style={{ color }}>{strength}</span>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })()}

              {/* What-If Analysis */}
              {trials.length >= 5 && campaign.spec?.parameters && (() => {
                const specs = campaign.spec.parameters.filter(s => s.type === "continuous" && s.lower != null && s.upper != null);
                if (specs.length === 0) return null;
                const paramNames = specs.map(s => s.name);
                const activeParam = whatIfParam ?? paramNames[0];
                const activeSpec = specs.find(s => s.name === activeParam);
                if (!activeSpec) return null;
                const lower = activeSpec.lower!;
                const upper = activeSpec.upper!;
                const range = upper - lower;
                const currentVal = lower + whatIfValue * range;

                // Find nearby trials and compute local weighted average
                const trialDistances = trials.map(t => {
                  const pVal = Number(t.parameters[activeParam]) || 0;
                  const normDist = Math.abs(pVal - currentVal) / range;
                  const weight = Math.exp(-normDist * normDist * 50); // Gaussian kernel
                  const objVal = Number(Object.values(t.kpis)[0]) || 0;
                  return { objVal, weight, pVal, iteration: t.iteration, normDist };
                });
                const nearbyTrials = trialDistances.filter(t => t.normDist < 0.15).sort((a, b) => a.normDist - b.normDist);
                const totalWeight = trialDistances.reduce((a, t) => a + t.weight, 0);
                const predictedObj = totalWeight > 0 ? trialDistances.reduce((a, t) => a + t.objVal * t.weight, 0) / totalWeight : 0;
                // Weighted std for confidence band
                const weightedVariance = totalWeight > 0
                  ? trialDistances.reduce((a, t) => a + t.weight * (t.objVal - predictedObj) ** 2, 0) / totalWeight
                  : 0;
                const confidence = Math.sqrt(weightedVariance);

                // Mini scatter data — parameter vs objective
                const objVals = trials.map(t => Number(Object.values(t.kpis)[0]) || 0);
                const minObj = Math.min(...objVals);
                const maxObj = Math.max(...objVals);
                const objRange = maxObj - minObj || 1;
                const scatterW = 300, scatterH = 100, pad = 4;

                return (
                  <div className="card whatif-card">
                    <div className="whatif-header">
                      <Sliders size={16} />
                      <h2 style={{ margin: 0 }}>What-If Analysis</h2>
                    </div>
                    <p style={{ fontSize: "0.82rem", color: "var(--color-text-muted)", marginBottom: "16px" }}>
                      Explore how changing a single parameter affects the predicted objective value, based on nearby trial data.
                    </p>
                    <div className="whatif-controls">
                      <label className="whatif-label">
                        Parameter
                        <select
                          className="suggestions-batch-select"
                          value={activeParam}
                          onChange={(e) => { setWhatIfParam(e.target.value); setWhatIfValue(0.5); }}
                        >
                          {paramNames.map(p => <option key={p} value={p}>{p}</option>)}
                        </select>
                      </label>
                      <div className="whatif-slider-group">
                        <div className="whatif-slider-labels">
                          <span className="mono">{lower.toFixed(3)}</span>
                          <span className="mono whatif-current-val">{currentVal.toFixed(4)}</span>
                          <span className="mono">{upper.toFixed(3)}</span>
                        </div>
                        <input
                          type="range"
                          min="0"
                          max="1"
                          step="0.005"
                          value={whatIfValue}
                          onChange={(e) => setWhatIfValue(Number(e.target.value))}
                          className="whatif-slider"
                        />
                      </div>
                    </div>
                    <div className="whatif-results">
                      <div className="whatif-result-box">
                        <div className="whatif-result-label">Predicted Objective</div>
                        <div className="whatif-result-value mono">{predictedObj.toFixed(4)}</div>
                        <div className="whatif-result-ci mono">&plusmn; {confidence.toFixed(4)}</div>
                      </div>
                      <div className="whatif-result-box">
                        <div className="whatif-result-label">Nearby Trials</div>
                        <div className="whatif-result-value">{nearbyTrials.length}</div>
                        <div className="whatif-result-ci">within 15% of slider</div>
                      </div>
                      {bestResult && (
                        <div className="whatif-result-box">
                          <div className="whatif-result-label">vs Current Best</div>
                          <div className={`whatif-result-value mono ${predictedObj < (Number(Object.values(bestResult.kpis)[0]) || 0) ? "whatif-better" : "whatif-worse"}`}>
                            {(predictedObj - (Number(Object.values(bestResult.kpis)[0]) || 0)).toFixed(4)}
                          </div>
                          <div className="whatif-result-ci">{predictedObj < (Number(Object.values(bestResult.kpis)[0]) || 0) ? "improvement" : "worse"}</div>
                        </div>
                      )}
                    </div>
                    {/* Mini scatter */}
                    <svg width={scatterW} height={scatterH} viewBox={`0 0 ${scatterW} ${scatterH}`} className="whatif-scatter">
                      {trials.map((t, i) => {
                        const px = pad + ((Number(t.parameters[activeParam]) || 0) - lower) / range * (scatterW - 2 * pad);
                        const py = pad + (1 - ((Number(Object.values(t.kpis)[0]) || 0) - minObj) / objRange) * (scatterH - 2 * pad);
                        const dist = trialDistances[i].normDist;
                        return (
                          <circle
                            key={i}
                            cx={px}
                            cy={py}
                            r={dist < 0.15 ? 3.5 : 2}
                            fill={dist < 0.15 ? "var(--color-primary)" : "var(--color-text-muted)"}
                            opacity={dist < 0.15 ? 0.8 : 0.2}
                          />
                        );
                      })}
                      {/* Slider position line */}
                      <line
                        x1={pad + whatIfValue * (scatterW - 2 * pad)}
                        y1={pad}
                        x2={pad + whatIfValue * (scatterW - 2 * pad)}
                        y2={scatterH - pad}
                        stroke="var(--color-primary)"
                        strokeWidth="1.5"
                        strokeDasharray="4,3"
                        opacity="0.6"
                      />
                      {/* Predicted point */}
                      <circle
                        cx={pad + whatIfValue * (scatterW - 2 * pad)}
                        cy={pad + (1 - (predictedObj - minObj) / objRange) * (scatterH - 2 * pad)}
                        r="5"
                        fill="var(--color-primary)"
                        stroke="white"
                        strokeWidth="2"
                      />
                    </svg>
                  </div>
                );
              })()}

              {/* Parameter Sensitivity Radar Chart */}
              {trials.length >= 5 && importance && importance.importances.length >= 3 && (() => {
                const items = [...importance.importances].sort((a, b) => b.importance - a.importance);
                const n = items.length;
                const cx = 130, cy = 130, R = 100;
                const angleStep = (2 * Math.PI) / n;
                const maxImp = Math.max(...items.map(i => i.importance), 0.01);
                // Compute objective correlation per parameter
                const objVals = trials.map(t => Number(Object.values(t.kpis)[0]) || 0);
                const meanObj = objVals.reduce((a, b) => a + b, 0) / objVals.length;
                const corrMap: Record<string, number> = {};
                items.forEach(item => {
                  const pVals = trials.map(t => Number(t.parameters[item.name]) || 0);
                  const meanP = pVals.reduce((a, b) => a + b, 0) / pVals.length;
                  let num = 0, denP = 0, denO = 0;
                  pVals.forEach((p, i) => { const dp = p - meanP; const dobj = objVals[i] - meanObj; num += dp * dobj; denP += dp * dp; denO += dobj * dobj; });
                  corrMap[item.name] = denP > 0 && denO > 0 ? num / Math.sqrt(denP * denO) : 0;
                });
                // Build radar polygon
                const points = items.map((item, i) => {
                  const angle = -Math.PI / 2 + i * angleStep;
                  const r = (item.importance / maxImp) * R;
                  return { x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle), name: item.name, imp: item.importance, corr: corrMap[item.name] || 0, angle };
                });
                const polyStr = points.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // Grid rings
                const rings = [0.25, 0.5, 0.75, 1.0];
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Hexagon size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Parameter Sensitivity</h2>
                    </div>
                    <p className="range-desc">Radar view of parameter importance. Larger radius = higher importance. Color indicates objective correlation direction.</p>
                    <div style={{ display: "flex", justifyContent: "center" }}>
                      <svg width={260} height={260} viewBox="0 0 260 260" style={{ overflow: "visible" }}>
                        {/* Grid rings */}
                        {rings.map(r => (
                          <circle key={r} cx={cx} cy={cy} r={R * r} fill="none" stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray={r < 1 ? "3,3" : "none"} />
                        ))}
                        {/* Axis lines */}
                        {points.map((p, i) => (
                          <line key={i} x1={cx} y1={cy} x2={cx + R * Math.cos(p.angle)} y2={cy + R * Math.sin(p.angle)} stroke="var(--color-border)" strokeWidth="0.5" />
                        ))}
                        {/* Filled polygon */}
                        <polygon points={polyStr} fill="var(--color-primary)" fillOpacity={0.15} stroke="var(--color-primary)" strokeWidth="1.5" />
                        {/* Data points */}
                        {points.map((p, i) => (
                          <g key={i}>
                            <circle cx={p.x} cy={p.y} r={5} fill={p.corr < -0.2 ? "#22c55e" : p.corr > 0.2 ? "#ef4444" : "var(--color-text-muted)"} stroke="var(--color-surface)" strokeWidth="1.5" />
                            <title>{p.name}: importance {(p.imp * 100).toFixed(1)}%, correlation {p.corr.toFixed(3)}</title>
                          </g>
                        ))}
                        {/* Labels */}
                        {points.map((p, i) => {
                          const labelR = R + 20;
                          const lx = cx + labelR * Math.cos(p.angle);
                          const ly = cy + labelR * Math.sin(p.angle);
                          const anchor = Math.abs(p.angle) < 0.1 || Math.abs(p.angle - Math.PI) < 0.1 ? "middle" : p.angle > -Math.PI / 2 && p.angle < Math.PI / 2 ? "start" : "end";
                          return (
                            <text key={i} x={lx} y={ly} textAnchor={anchor} dominantBaseline="central" fontSize="11" fontFamily="var(--font-mono)" fill="var(--color-text)" fontWeight={p.imp === maxImp ? 600 : 400}>
                              {p.name}
                            </text>
                          );
                        })}
                      </svg>
                    </div>
                    <div className="radar-legend">
                      <span className="radar-legend-item"><span className="radar-dot" style={{ background: "#22c55e" }} /> Negative corr (better)</span>
                      <span className="radar-legend-item"><span className="radar-dot" style={{ background: "#ef4444" }} /> Positive corr (worse)</span>
                      <span className="radar-legend-item"><span className="radar-dot" style={{ background: "var(--color-text-muted)" }} /> Neutral</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter-to-Parameter Correlation Heatmap */}
              {trials.length >= 5 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                // Compute full correlation matrix
                const n = trials.length;
                const means: Record<string, number> = {};
                const stds: Record<string, number> = {};
                for (const p of paramNames) {
                  const vals = trials.map((t) => Number(t.parameters[p]) || 0);
                  means[p] = vals.reduce((a, b) => a + b, 0) / n;
                  stds[p] = Math.sqrt(vals.reduce((a, v) => a + (v - means[p]) ** 2, 0) / n);
                }
                const corrMatrix: number[][] = paramNames.map((pi) =>
                  paramNames.map((pj) => {
                    if (pi === pj) return 1;
                    if (stds[pi] === 0 || stds[pj] === 0) return 0;
                    const cov = trials.reduce((a, t) =>
                      a + (Number(t.parameters[pi]) - means[pi]) * (Number(t.parameters[pj]) - means[pj]), 0) / n;
                    return cov / (stds[pi] * stds[pj]);
                  })
                );
                const cellSize = Math.min(44, Math.max(28, 300 / paramNames.length));
                const labelW = 70;
                const svgW = labelW + paramNames.length * cellSize;
                const svgH = labelW + paramNames.length * cellSize;
                const corrColor = (v: number) => {
                  const abs = Math.abs(v);
                  if (v > 0) return `rgba(37, 99, 235, ${abs * 0.8})`;
                  if (v < 0) return `rgba(220, 38, 38, ${abs * 0.8})`;
                  return "transparent";
                };
                return (
                  <div className="card">
                    <h2>Parameter Correlation Heatmap</h2>
                    <p style={{ fontSize: "0.82rem", color: "var(--color-text-muted)", marginBottom: "16px" }}>
                      Pearson correlation between parameter pairs. Blue = positive, Red = negative. Strong inter-parameter correlations may indicate redundancy.
                    </p>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={svgW} height={svgH} style={{ display: "block" }}>
                        {/* Column labels (top) */}
                        {paramNames.map((p, j) => (
                          <text
                            key={`cl-${j}`}
                            x={labelW + j * cellSize + cellSize / 2}
                            y={labelW - 6}
                            textAnchor="end"
                            fontSize="10"
                            fontFamily="var(--font-mono)"
                            fill="var(--color-text-muted)"
                            transform={`rotate(-45 ${labelW + j * cellSize + cellSize / 2} ${labelW - 6})`}
                          >
                            {p.length > 8 ? p.slice(0, 7) + "…" : p}
                          </text>
                        ))}
                        {/* Row labels + cells */}
                        {paramNames.map((pi, i) => (
                          <g key={`row-${i}`}>
                            <text
                              x={labelW - 6}
                              y={labelW + i * cellSize + cellSize / 2 + 3}
                              textAnchor="end"
                              fontSize="10"
                              fontFamily="var(--font-mono)"
                              fill="var(--color-text-muted)"
                            >
                              {pi.length > 8 ? pi.slice(0, 7) + "…" : pi}
                            </text>
                            {paramNames.map((_pj, j) => {
                              const v = corrMatrix[i][j];
                              return (
                                <g key={`cell-${i}-${j}`}>
                                  <rect
                                    x={labelW + j * cellSize}
                                    y={labelW + i * cellSize}
                                    width={cellSize - 1}
                                    height={cellSize - 1}
                                    rx="3"
                                    fill={corrColor(v)}
                                    stroke="var(--color-border)"
                                    strokeWidth="0.5"
                                  >
                                    <title>{`${paramNames[i]} vs ${paramNames[j]}: ${v.toFixed(3)}`}</title>
                                  </rect>
                                  {cellSize >= 32 && (
                                    <text
                                      x={labelW + j * cellSize + (cellSize - 1) / 2}
                                      y={labelW + i * cellSize + (cellSize - 1) / 2 + 3}
                                      textAnchor="middle"
                                      fontSize="9"
                                      fontFamily="var(--font-mono)"
                                      fontWeight="600"
                                      fill={Math.abs(v) > 0.4 ? "white" : "var(--color-text-muted)"}
                                    >
                                      {i === j ? "1" : v.toFixed(2)}
                                    </text>
                                  )}
                                </g>
                              );
                            })}
                          </g>
                        ))}
                      </svg>
                    </div>
                    {/* Legend */}
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginTop: "12px", fontSize: "0.75rem", color: "var(--color-text-muted)" }}>
                      <span style={{ display: "inline-block", width: "14px", height: "14px", borderRadius: "3px", background: "rgba(220, 38, 38, 0.7)" }} />
                      <span>Negative</span>
                      <span style={{ display: "inline-block", width: "14px", height: "14px", borderRadius: "3px", background: "var(--color-border)" }} />
                      <span>Zero</span>
                      <span style={{ display: "inline-block", width: "14px", height: "14px", borderRadius: "3px", background: "rgba(37, 99, 235, 0.7)" }} />
                      <span>Positive</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Interaction Network */}
              {trials.length >= 15 && (() => {
                const pNames = Object.keys(trials[0].parameters);
                if (pNames.length < 3) return null;
                const oKey = Object.keys(trials[0].kpis)[0];
                const oVals = trials.map(t => Number(t.kpis[oKey]) || 0);
                const oMean = oVals.reduce((a, b) => a + b, 0) / oVals.length;

                // Compute pairwise interaction scores
                const edges: Array<{ a: number; b: number; strength: number; synergy: boolean }> = [];
                for (let i = 0; i < pNames.length; i++) {
                  for (let j = i + 1; j < pNames.length; j++) {
                    const aVals = trials.map(t => Number(t.parameters[pNames[i]]) || 0);
                    const bVals = trials.map(t => Number(t.parameters[pNames[j]]) || 0);
                    const aMean = aVals.reduce((s, v) => s + v, 0) / aVals.length;
                    const bMean = bVals.reduce((s, v) => s + v, 0) / bVals.length;

                    // Interaction: correlation of (a*b) with objective residual
                    const abProduct = aVals.map((a, k) => (a - aMean) * (bVals[k] - bMean));
                    const oResidual = oVals.map(v => v - oMean);
                    const prodMean = abProduct.reduce((s, v) => s + v, 0) / abProduct.length;
                    const resMean = oResidual.reduce((s, v) => s + v, 0) / oResidual.length;
                    let num = 0, denA = 0, denB = 0;
                    for (let k = 0; k < abProduct.length; k++) {
                      const da = abProduct[k] - prodMean;
                      const db = oResidual[k] - resMean;
                      num += da * db;
                      denA += da * da;
                      denB += db * db;
                    }
                    const corr = denA > 0 && denB > 0 ? num / Math.sqrt(denA * denB) : 0;
                    const strength = Math.abs(corr);
                    if (strength > 0.1) {
                      edges.push({ a: i, b: j, strength, synergy: corr < 0 }); // negative corr with minimize = synergistic
                    }
                  }
                }

                // Layout: circular node placement
                const W = 350, H = 280;
                const cx = W / 2, cy = H / 2;
                const radius = Math.min(W, H) / 2 - 40;
                const nodePositions = pNames.map((_, i) => {
                  const angle = (2 * Math.PI * i) / pNames.length - Math.PI / 2;
                  return { x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) };
                });

                const maxStrength = edges.length > 0 ? Math.max(...edges.map(e => e.strength)) : 1;
                const strongEdges = edges.filter(e => e.strength > 0.15);

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <GitCompare size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Interaction Network</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        {strongEdges.length} interactions
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Parameter interactions detected from joint effects on {oKey}. Thick edges = strong interaction. Green = synergistic, red = antagonistic.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Edges */}
                      {strongEdges.map((e, i) => {
                        const pa = nodePositions[e.a];
                        const pb = nodePositions[e.b];
                        const thickness = 1 + (e.strength / maxStrength) * 4;
                        const color = e.synergy ? "rgba(34,197,94,0.6)" : "rgba(239,68,68,0.5)";
                        return (
                          <line key={i} x1={pa.x} y1={pa.y} x2={pb.x} y2={pb.y}
                            stroke={color} strokeWidth={thickness} strokeLinecap="round">
                            <title>{pNames[e.a]} × {pNames[e.b]}: {e.synergy ? "synergistic" : "antagonistic"} ({e.strength.toFixed(3)})</title>
                          </line>
                        );
                      })}
                      {/* Nodes */}
                      {pNames.map((name, i) => {
                        const pos = nodePositions[i];
                        const nodeEdges = strongEdges.filter(e => e.a === i || e.b === i);
                        const totalStr = nodeEdges.reduce((s, e) => s + e.strength, 0);
                        const nodeRadius = 16 + Math.min(totalStr * 8, 8);
                        return (
                          <g key={i}>
                            <circle cx={pos.x} cy={pos.y} r={nodeRadius} fill="var(--color-card-bg)" stroke="var(--color-primary)" strokeWidth="2">
                              <title>{name}: {nodeEdges.length} interaction(s), total strength={totalStr.toFixed(3)}</title>
                            </circle>
                            <text x={pos.x} y={pos.y + 3} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fontWeight="600" fill="var(--color-text-primary)">
                              {name.length > 6 ? name.slice(0, 5) + "…" : name}
                            </text>
                          </g>
                        );
                      })}
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: "rgba(34,197,94,0.8)", borderRadius: 1, marginRight: 4, verticalAlign: "middle" }} />Synergistic</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: "rgba(239,68,68,0.7)", borderRadius: 1, marginRight: 4, verticalAlign: "middle" }} />Antagonistic</span>
                      <span className="efficiency-legend-item" style={{ color: "var(--color-text-muted)", fontSize: "0.72rem" }}>Edge width ∝ effect size</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parallel Coordinates Plot */}
              {trials.length >= 3 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const objKey = Object.keys(trials[0].kpis)[0];
                const objVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const objMin = Math.min(...objVals);
                const objMax = Math.max(...objVals);
                const objRange = objMax - objMin || 1;
                // Compute min/max for each param
                const paramBounds = paramNames.map(p => {
                  const vals = trials.map(t => Number(t.parameters[p]) || 0);
                  const min = Math.min(...vals);
                  const max = Math.max(...vals);
                  return { name: p, min, max, range: max - min || 1 };
                });
                const W = Math.max(500, paramNames.length * 100);
                const H = 260;
                const padL = 50, padR = 30, padT = 30, padB = 40;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const axisSpacing = plotW / (paramNames.length - 1);
                // Color function: green(good) → yellow → red(bad) for minimization
                const trialColor = (objVal: number) => {
                  const t = (objVal - objMin) / objRange;
                  if (t < 0.33) return `rgba(34, 197, 94, ${0.35 + t * 0.5})`;
                  if (t < 0.67) return `rgba(234, 179, 8, ${0.35 + (t - 0.33) * 0.5})`;
                  return `rgba(239, 68, 68, ${0.35 + (t - 0.67) * 0.5})`;
                };
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Layers size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Parallel Coordinates</h2>
                    </div>
                    <p className="range-desc">Each line represents a trial. Lines are colored by objective value (green = best, red = worst). Hover for details.</p>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={W} height={H} style={{ display: "block" }}>
                        {/* Axis lines + labels */}
                        {paramBounds.map((pb, i) => {
                          const x = padL + i * axisSpacing;
                          return (
                            <g key={pb.name}>
                              <line x1={x} y1={padT} x2={x} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                              <text x={x} y={padT + plotH + 16} textAnchor="middle" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                                {pb.name.length > 10 ? pb.name.slice(0, 9) + "…" : pb.name}
                              </text>
                              <text x={x} y={padT - 6} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                                {pb.max.toPrecision(3)}
                              </text>
                              <text x={x} y={padT + plotH + 30} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                                {pb.min.toPrecision(3)}
                              </text>
                            </g>
                          );
                        })}
                        {/* Trial polylines */}
                        {trials.map((trial, ti) => {
                          const objVal = Number(trial.kpis[objKey]) || 0;
                          const pts = paramBounds.map((pb, i) => {
                            const val = Number(trial.parameters[pb.name]) || 0;
                            const y = padT + plotH - ((val - pb.min) / pb.range) * plotH;
                            const x = padL + i * axisSpacing;
                            return `${x.toFixed(1)},${y.toFixed(1)}`;
                          });
                          return (
                            <polyline
                              key={ti}
                              points={pts.join(" ")}
                              fill="none"
                              stroke={trialColor(objVal)}
                              strokeWidth="1.2"
                              strokeLinejoin="round"
                              className="pcoord-line"
                            >
                              <title>Trial #{trial.iteration} — {objKey}: {objVal.toFixed(4)}</title>
                            </polyline>
                          );
                        })}
                      </svg>
                    </div>
                    <div className="pcoord-legend">
                      <span className="pcoord-legend-item"><span className="pcoord-dot" style={{ background: "rgba(34,197,94,0.8)" }} /> Best</span>
                      <span className="pcoord-legend-item"><span className="pcoord-dot" style={{ background: "rgba(234,179,8,0.8)" }} /> Mid</span>
                      <span className="pcoord-legend-item"><span className="pcoord-dot" style={{ background: "rgba(239,68,68,0.8)" }} /> Worst</span>
                    </div>
                  </div>
                );
              })()}

              {/* Optimization Efficiency Curve */}
              {trials.length >= 10 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Actual cumulative best
                const actualBest: number[] = [];
                let runBest = Infinity;
                chrono.forEach(t => {
                  const v = Number(t.kpis[objKey]) || 0;
                  runBest = Math.min(runBest, v);
                  actualBest.push(runBest);
                });
                // Random baseline: sort values ascending (best possible random schedule)
                const randBest: number[] = [];
                // Actually random = shuffled, use sorted descending for WORST case, ascending for best
                // Realistic: assume random sees values in original order but shuffled. Use median expectation.
                // Simplification: sort all values and compute expected min after k draws (order statistics)
                // Just use: random line = average of 100 random shuffles? Too heavy. Use: random[k] = min of first k+1 sorted values
                // Actually the simplest useful comparison: the actual values re-randomized
                // Use deterministic "median random": sort values, running min of every N-th percentile
                const allVals = chrono.map(t => Number(t.kpis[objKey]) || 0);
                // Seed a pseudo-random shuffle deterministically
                const shuffled = [...allVals];
                let seed = 42;
                for (let i = shuffled.length - 1; i > 0; i--) {
                  seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                  const j = seed % (i + 1);
                  [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                let rMin = Infinity;
                shuffled.forEach(v => {
                  rMin = Math.min(rMin, v);
                  randBest.push(rMin);
                });

                const allBestVals = [...actualBest, ...randBest];
                const yMin = Math.min(...allBestVals);
                const yMax = Math.max(...allBestVals);
                const yRange = yMax - yMin || 1;
                const n = chrono.length;
                const W = 460, H = 200, padL = 55, padR = 10, padT = 10, padB = 30;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const px = (i: number) => padL + (i / (n - 1)) * plotW;
                const py = (v: number) => padT + (1 - (v - yMin) / yRange) * plotH;

                // Acceleration factor: at which iteration does random reach the final BO best?
                const finalBOBest = actualBest[actualBest.length - 1];
                const randReachIdx = randBest.findIndex(v => v <= finalBOBest);
                const actualPath = actualBest.map((v, i) => `${i === 0 ? "M" : "L"}${px(i).toFixed(1)},${py(v).toFixed(1)}`).join(" ");
                const randPath = randBest.map((v, i) => `${i === 0 ? "M" : "L"}${px(i).toFixed(1)},${py(v).toFixed(1)}`).join(" ");

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <TrendingUp size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Sample Efficiency</h2>
                      {randReachIdx > 0 && (
                        <span className="efficiency-badge">
                          {((n / randReachIdx) || 1).toFixed(1)}x faster than random
                        </span>
                      )}
                    </div>
                    <p className="range-desc">Cumulative best objective value vs iteration number. Compares actual optimization (blue) with a random baseline (gray).</p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Grid */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => {
                        const y = padT + (1 - f) * plotH;
                        const val = yMin + f * yRange;
                        return (
                          <g key={f}>
                            <line x1={padL} y1={y} x2={padL + plotW} y2={y} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                            <text x={padL - 6} y={y + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                              {val.toFixed(3)}
                            </text>
                          </g>
                        );
                      })}
                      {/* Random baseline */}
                      <path d={randPath} fill="none" stroke="var(--color-text-muted)" strokeWidth="1.2" strokeDasharray="4,3" opacity={0.5} />
                      {/* Actual optimization */}
                      <path d={actualPath} fill="none" stroke="var(--color-primary)" strokeWidth="2" />
                      {/* Final markers */}
                      <circle cx={px(n - 1)} cy={py(actualBest[n - 1])} r="3.5" fill="var(--color-primary)" />
                      <circle cx={px(n - 1)} cy={py(randBest[n - 1])} r="2.5" fill="var(--color-text-muted)" />
                      {/* X-axis labels */}
                      <text x={padL} y={H - 4} textAnchor="start" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">0</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{n}</text>
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)">Iteration</text>
                    </svg>
                    <div className="efficiency-legend">
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: "16px", height: "2px", background: "var(--color-primary)", verticalAlign: "middle", marginRight: "4px" }} /> Optimization</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: "16px", height: "2px", background: "var(--color-text-muted)", verticalAlign: "middle", marginRight: "4px", borderTop: "1px dashed var(--color-text-muted)" }} /> Random Baseline</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Impact Waterfall */}
              {trials.length >= 10 && importance && importance.importances.length >= 2 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const allVals = trials.map(t => Number(t.kpis[objKey]) || 0).sort((a, b) => a - b);
                const q25 = Math.floor(allVals.length * 0.25);
                const q75 = Math.ceil(allVals.length * 0.75);
                const bestTrials = trials.filter(t => Number(t.kpis[objKey]) <= allVals[q25]);
                const worstTrials = trials.filter(t => Number(t.kpis[objKey]) >= allVals[q75]);
                if (bestTrials.length === 0 || worstTrials.length === 0) return null;

                const paramNames = Object.keys(trials[0].parameters);
                const impacts = paramNames.map(p => {
                  const bestMean = bestTrials.reduce((a, t) => a + (Number(t.parameters[p]) || 0), 0) / bestTrials.length;
                  const worstMean = worstTrials.reduce((a, t) => a + (Number(t.parameters[p]) || 0), 0) / worstTrials.length;
                  const diff = bestMean - worstMean;
                  const imp = importance.importances.find(i => i.name === p);
                  return { name: p, diff, importance: imp?.importance ?? 0, bestMean, worstMean };
                }).sort((a, b) => Math.abs(b.diff * b.importance) - Math.abs(a.diff * a.importance));

                const maxAbsDiff = Math.max(...impacts.map(i => Math.abs(i.diff * i.importance)));
                if (maxAbsDiff === 0) return null;

                const W = 460, barH = 24, gap = 4;
                const padL = 80, padR = 60;
                const plotW = W - padL - padR;
                const H = impacts.length * (barH + gap) + 30;
                const centerX = padL + plotW / 2;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <BarChart2 size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Parameter Impact</h2>
                    </div>
                    <p className="range-desc">How parameter values differ between best and worst 25% of trials, weighted by importance. Positive = higher in best trials.</p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Center line */}
                      <line x1={centerX} y1={8} x2={centerX} y2={H - 20} stroke="var(--color-border)" strokeWidth="1" />
                      {impacts.map((item, i) => {
                        const y = 8 + i * (barH + gap);
                        const weighted = item.diff * item.importance;
                        const w = (weighted / maxAbsDiff) * (plotW / 2);
                        const isPos = w >= 0;
                        const barX = isPos ? centerX : centerX + w;
                        const barWidth = Math.abs(w);
                        const color = isPos ? "rgba(34,197,94,0.6)" : "rgba(239,68,68,0.5)";
                        return (
                          <g key={item.name}>
                            <text x={padL - 4} y={y + barH / 2 + 3} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text)">
                              {item.name.length > 10 ? item.name.slice(0, 9) + "…" : item.name}
                            </text>
                            <rect x={barX} y={y} width={Math.max(barWidth, 1)} height={barH} rx="3" fill={color}>
                              <title>{item.name}: best avg {item.bestMean.toFixed(3)} vs worst avg {item.worstMean.toFixed(3)} (diff: {item.diff > 0 ? "+" : ""}{item.diff.toFixed(3)})</title>
                            </rect>
                            <text x={isPos ? centerX + Math.abs(w) + 4 : centerX + w - 4} y={y + barH / 2 + 3} textAnchor={isPos ? "start" : "end"} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                              {weighted > 0 ? "+" : ""}{weighted.toFixed(3)}
                            </text>
                          </g>
                        );
                      })}
                      {/* Labels */}
                      <text x={padL} y={H - 4} fontSize="9" fill="var(--color-text-muted)">Lower in best</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fill="var(--color-text-muted)">Higher in best</text>
                    </svg>
                  </div>
                );
              })()}

              {/* Acquisition Function Proxy */}
              {trials.length >= 12 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const objKey = Object.keys(trials[0].kpis)[0];
                const afXParam = paramNames[0];
                const afYParam = paramNames[1];
                const afXVals = trials.map(t => Number(t.parameters[afXParam]) || 0);
                const afYVals = trials.map(t => Number(t.parameters[afYParam]) || 0);
                const afObjVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const afXMin = Math.min(...afXVals), afXMax = Math.max(...afXVals);
                const afYMin = Math.min(...afYVals), afYMax = Math.max(...afYVals);
                const afXRange = afXMax - afXMin || 1;
                const afYRange = afYMax - afYMin || 1;
                const afObjMin = Math.min(...afObjVals);
                const afObjMax = Math.max(...afObjVals);
                const afObjRange = afObjMax - afObjMin || 1;

                const res = 16;
                const afGrid: Array<Array<{ exploit: number; explore: number; acq: number }>> = [];
                for (let gy = 0; gy < res; gy++) {
                  const row: Array<{ exploit: number; explore: number; acq: number }> = [];
                  for (let gx = 0; gx < res; gx++) {
                    const cx = afXMin + (gx + 0.5) * afXRange / res;
                    const cy = afYMin + (gy + 0.5) * afYRange / res;

                    // Exploitation: IDW-interpolated objective value (normalized, lower=better)
                    let wSum = 0, vSum = 0;
                    for (let i = 0; i < trials.length; i++) {
                      const dx = (afXVals[i] - cx) / afXRange;
                      const dy = (afYVals[i] - cy) / afYRange;
                      const d = Math.sqrt(dx * dx + dy * dy) + 0.001;
                      const w = 1 / (d * d);
                      wSum += w;
                      vSum += w * afObjVals[i];
                    }
                    const predicted = vSum / wSum;
                    const exploit = 1 - (predicted - afObjMin) / afObjRange; // Higher = better predicted value

                    // Exploration: inverse of local density (sparse = high exploration value)
                    let nearCount = 0;
                    const radius = 0.15;
                    for (let i = 0; i < trials.length; i++) {
                      const dx = (afXVals[i] - cx) / afXRange;
                      const dy = (afYVals[i] - cy) / afYRange;
                      if (Math.sqrt(dx * dx + dy * dy) < radius) nearCount++;
                    }
                    const explore = 1 - Math.min(nearCount / 5, 1); // fewer nearby = higher exploration

                    // Acquisition score: balanced combination
                    const acq = 0.4 * exploit + 0.6 * explore;
                    row.push({ exploit, explore, acq });
                  }
                  afGrid.push(row);
                }

                const maxAcq = Math.max(...afGrid.flat().map(c => c.acq));
                const minAcq = Math.min(...afGrid.flat().map(c => c.acq));
                const acqRange = maxAcq - minAcq || 1;

                // Find top suggested cell
                let topGx = 0, topGy = 0, topAcq = -Infinity;
                for (let gy = 0; gy < res; gy++) {
                  for (let gx = 0; gx < res; gx++) {
                    if (afGrid[gy][gx].acq > topAcq) {
                      topAcq = afGrid[gy][gx].acq;
                      topGx = gx;
                      topGy = gy;
                    }
                  }
                }

                const W = 420, H = 280, padL = 50, padR = 20, padT = 10, padB = 36;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const cellW = plotW / res;
                const cellH = plotH / res;

                const acqColor = (v: number) => {
                  const t = (v - minAcq) / acqRange;
                  // Purple (low) → blue (mid) → cyan (high)
                  if (t < 0.5) {
                    const p = t / 0.5;
                    return `rgb(${Math.round(88 - p * 30)}, ${Math.round(28 + p * 72)}, ${Math.round(135 + p * 70)})`;
                  }
                  const p = (t - 0.5) / 0.5;
                  return `rgb(${Math.round(58 - p * 50)}, ${Math.round(100 + p * 155)}, ${Math.round(205 + p * 50)})`;
                };

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Crosshair size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Acquisition Landscape</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        {afXParam} × {afYParam}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Estimated acquisition score combining predicted value (40%) and exploration need (60%). Bright = high-priority regions for next experiments.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {afGrid.map((row, gy) =>
                        row.map((cell, gx) => (
                          <rect
                            key={`${gy}-${gx}`}
                            x={padL + gx * cellW}
                            y={padT + gy * cellH}
                            width={cellW + 0.5}
                            height={cellH + 0.5}
                            fill={acqColor(cell.acq)}
                            opacity={0.85}
                          >
                            <title>{afXParam}≈{(afXMin + (gx + 0.5) * afXRange / res).toFixed(2)}, {afYParam}≈{(afYMin + (gy + 0.5) * afYRange / res).toFixed(2)} | Acq={cell.acq.toFixed(3)} (exploit={cell.exploit.toFixed(2)}, explore={cell.explore.toFixed(2)})</title>
                          </rect>
                        ))
                      )}
                      {/* Best acquisition cell marker */}
                      <rect
                        x={padL + topGx * cellW + 1}
                        y={padT + topGy * cellH + 1}
                        width={cellW - 2}
                        height={cellH - 2}
                        fill="none"
                        stroke="white"
                        strokeWidth="2"
                        strokeDasharray="3,2"
                      />
                      <text
                        x={padL + (topGx + 0.5) * cellW}
                        y={padT + (topGy + 0.5) * cellH + 3}
                        textAnchor="middle"
                        fontSize="9"
                        fill="white"
                        fontWeight="bold"
                      >★</text>
                      {/* Trial positions */}
                      {trials.map((t, i) => {
                        const px = padL + ((afXVals[i] - afXMin) / afXRange) * plotW;
                        const py = padT + ((afYVals[i] - afYMin) / afYRange) * plotH;
                        return (
                          <circle key={i} cx={px} cy={py} r="2" fill="rgba(255,255,255,0.5)" stroke="rgba(0,0,0,0.3)" strokeWidth="0.5">
                            <title>Trial #{t.iteration}: {objKey}={afObjVals[i].toFixed(4)}</title>
                          </circle>
                        );
                      })}
                      {/* Axes */}
                      <line x1={padL} y1={padT} x2={padL} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      <line x1={padL} y1={padT + plotH} x2={padL + plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={`af${f}`}>
                          <text x={padL + f * plotW} y={H - 12} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(afXMin + f * afXRange).toFixed(2)}
                          </text>
                          <text x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(afYMin + f * afYRange).toFixed(2)}
                          </text>
                        </Fragment>
                      ))}
                      <text x={padL + plotW / 2} y={H - 0} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">{afXParam}</text>
                      <text x={10} y={padT + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" transform={`rotate(-90, 10, ${padT + plotH / 2})`}>{afYParam}</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(88,28,135)", marginRight: 4, verticalAlign: "middle" }} />Low priority</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(8,255,255)", marginRight: 4, verticalAlign: "middle" }} />High priority</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 8, height: 8, border: "1.5px dashed white", background: "transparent", marginRight: 4, verticalAlign: "middle" }} />★ Next suggestion</span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Space Sampling Density */}
              {trials.length >= 10 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const xParam = paramNames[0];
                const yParam = paramNames[1];
                const xVals = trials.map(t => Number(t.parameters[xParam]) || 0);
                const yVals = trials.map(t => Number(t.parameters[yParam]) || 0);
                const xMin = Math.min(...xVals), xMax = Math.max(...xVals);
                const yMin = Math.min(...yVals), yMax = Math.max(...yVals);
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                const res = 12;
                const W = 380, H = 320, padL = 48, padR = 14, padT = 10, padB = 36;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const cellW = plotW / res;
                const cellH = plotH / res;

                // Count trials per cell
                const density: number[][] = Array.from({ length: res }, () => Array(res).fill(0));
                for (let i = 0; i < trials.length; i++) {
                  const gx = Math.min(Math.floor(((xVals[i] - xMin) / xRange) * res), res - 1);
                  const gy = Math.min(Math.floor(((yVals[i] - yMin) / yRange) * res), res - 1);
                  density[gy][gx]++;
                }
                const maxDensity = Math.max(...density.flat());
                const emptyCells = density.flat().filter(d => d === 0).length;
                const totalCells = res * res;
                const coveragePct = ((1 - emptyCells / totalCells) * 100).toFixed(0);

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Radar size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Sampling Density</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        {coveragePct}% cells sampled
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Trial density across the {xParam} × {yParam} space. Dark cells = well-sampled, light/white = gaps to explore.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {density.map((row, gy) =>
                        row.map((count, gx) => {
                          const opacity = count > 0 ? 0.15 + (count / maxDensity) * 0.75 : 0;
                          return (
                            <rect
                              key={`${gy}-${gx}`}
                              x={padL + gx * cellW}
                              y={padT + gy * cellH}
                              width={cellW - 0.5}
                              height={cellH - 0.5}
                              rx="2"
                              fill={count > 0 ? "var(--color-primary)" : "var(--color-border)"}
                              opacity={count > 0 ? opacity : 0.3}
                              stroke="var(--color-bg)"
                              strokeWidth="0.5"
                            >
                              <title>{xParam}:[{(xMin + gx * xRange / res).toFixed(2)},{(xMin + (gx + 1) * xRange / res).toFixed(2)}] × {yParam}:[{(yMin + gy * yRange / res).toFixed(2)},{(yMin + (gy + 1) * yRange / res).toFixed(2)}] — {count} trial{count !== 1 ? "s" : ""}</title>
                            </rect>
                          );
                        })
                      )}
                      {/* Gap markers for empty cells */}
                      {density.flatMap((row, gy) =>
                        row.map((count, gx) =>
                          count === 0 ? (
                            <text key={`gap-${gy}-${gx}`} x={padL + (gx + 0.5) * cellW} y={padT + (gy + 0.5) * cellH + 3} textAnchor="middle" fontSize="7" fill="var(--color-text-muted)" opacity="0.4">?</text>
                          ) : null
                        )
                      )}
                      {/* Axes */}
                      <line x1={padL} y1={padT + plotH} x2={padL + plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      <line x1={padL} y1={padT} x2={padL} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={`xl-${f}`}>
                          <text x={padL + f * plotW} y={H - 18} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{(xMin + f * xRange).toFixed(2)}</text>
                          <text x={padL - 4} y={padT + f * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{(yMin + f * yRange).toFixed(2)}</text>
                        </Fragment>
                      ))}
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">{xParam}</text>
                      <text x={12} y={padT + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" transform={`rotate(-90, 12, ${padT + plotH / 2})`}>{yParam}</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", maxWidth: `${W}px`, padding: "2px 0" }}>
                      <span>{emptyCells} empty cells (gaps)</span>
                      <span>Max density: {maxDensity} trials/cell</span>
                    </div>
                  </div>
                );
              })()}

              {/* Surrogate Landscape Heatmap */}
              {trials.length >= 10 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const objKey = Object.keys(trials[0].kpis)[0];
                const xParam = paramNames[0];
                const yParam = paramNames[1];
                const xVals = trials.map(t => Number(t.parameters[xParam]) || 0);
                const yVals = trials.map(t => Number(t.parameters[yParam]) || 0);
                const objVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const xMin = Math.min(...xVals), xMax = Math.max(...xVals);
                const yMin = Math.min(...yVals), yMax = Math.max(...yVals);
                const oMin = Math.min(...objVals), oMax = Math.max(...objVals);
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                const oRange = oMax - oMin || 1;
                const res = 20; // grid resolution
                const W = 400, H = 340, padL = 52, padR = 16, padT = 12, padB = 38;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const cellW = plotW / res;
                const cellH = plotH / res;

                // Inverse-distance-weighted interpolation
                const grid: number[][] = [];
                const countGrid: number[][] = [];
                for (let gy = 0; gy < res; gy++) {
                  grid[gy] = [];
                  countGrid[gy] = [];
                  for (let gx = 0; gx < res; gx++) {
                    const cx = xMin + (gx + 0.5) * xRange / res;
                    const cy = yMin + (gy + 0.5) * yRange / res;
                    let wSum = 0, vSum = 0;
                    for (let i = 0; i < trials.length; i++) {
                      const dx = (xVals[i] - cx) / xRange;
                      const dy = (yVals[i] - cy) / yRange;
                      const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
                      const w = 1 / (dist * dist);
                      wSum += w;
                      vSum += w * objVals[i];
                    }
                    grid[gy][gx] = wSum > 0 ? vSum / wSum : 0;
                    countGrid[gy][gx] = trials.filter((_t, i) => {
                      const dx = Math.abs(xVals[i] - cx) / xRange;
                      const dy = Math.abs(yVals[i] - cy) / yRange;
                      return dx < 0.5 / res * 3 && dy < 0.5 / res * 3;
                    }).length;
                  }
                }

                // Color: green (best/low) → yellow → red (worst/high) for minimize
                const cellColor = (val: number) => {
                  const t = (val - oMin) / oRange;
                  if (t < 0.33) {
                    const p = t / 0.33;
                    return `rgb(${Math.round(34 + p * (234 - 34))}, ${Math.round(197 - p * (197 - 179))}, ${Math.round(94 - p * (94 - 8))})`;
                  }
                  const p = (t - 0.33) / 0.67;
                  return `rgb(${Math.round(234 + p * (239 - 234))}, ${Math.round(179 - p * (179 - 68))}, ${Math.round(8 + p * (68 - 8))})`;
                };

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Grid size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Surrogate Landscape</h2>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 10px" }}>
                      Estimated objective surface using inverse-distance interpolation. Green = better regions. White dots = actual trials.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Heatmap cells */}
                      {grid.map((row, gy) =>
                        row.map((val, gx) => (
                          <rect
                            key={`${gy}-${gx}`}
                            x={padL + gx * cellW}
                            y={padT + gy * cellH}
                            width={cellW + 0.5}
                            height={cellH + 0.5}
                            fill={cellColor(val)}
                            opacity={countGrid[gy][gx] > 0 ? 0.85 : 0.4}
                          >
                            <title>{xParam}≈{(xMin + (gx + 0.5) * xRange / res).toFixed(2)}, {yParam}≈{(yMin + (gy + 0.5) * yRange / res).toFixed(2)} → {val.toFixed(4)}</title>
                          </rect>
                        ))
                      )}
                      {/* Trial points */}
                      {trials.map((t, i) => {
                        const px = padL + ((xVals[i] - xMin) / xRange) * plotW;
                        const py = padT + ((yVals[i] - yMin) / yRange) * plotH;
                        return (
                          <circle key={i} cx={px} cy={py} r="2.5" fill="white" stroke="rgba(0,0,0,0.4)" strokeWidth="0.5">
                            <title>Trial #{t.iteration}: {objKey}={objVals[i].toFixed(4)}</title>
                          </circle>
                        );
                      })}
                      {/* Axes */}
                      <line x1={padL} y1={padT} x2={padL} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      <line x1={padL} y1={padT + plotH} x2={padL + plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      {/* X-axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL + f * plotW} y={H - 18} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(xMin + f * xRange).toFixed(2)}
                        </text>
                      ))}
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">{xParam}</text>
                      {/* Y-axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <text key={f} x={padL - 4} y={padT + f * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                          {(yMin + f * yRange).toFixed(2)}
                        </text>
                      ))}
                      <text x={12} y={padT + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" transform={`rotate(-90, 12, ${padT + plotH / 2})`}>{yParam}</text>
                      {/* Color legend */}
                      <defs>
                        <linearGradient id="hm-legend" x1="0" x2="1" y1="0" y2="0">
                          <stop offset="0%" stopColor="rgb(34,197,94)" />
                          <stop offset="33%" stopColor="rgb(234,179,8)" />
                          <stop offset="100%" stopColor="rgb(239,68,68)" />
                        </linearGradient>
                      </defs>
                      <rect x={padL + plotW + 4} y={padT} width={8} height={plotH} fill="url(#hm-legend)" rx="2" transform={`rotate(180, ${padL + plotW + 8}, ${padT + plotH / 2})`} />
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", fontFamily: "var(--font-mono)", maxWidth: `${W}px`, padding: "2px 0" }}>
                      <span>Better ({oMin.toFixed(3)})</span>
                      <span>Worse ({oMax.toFixed(3)})</span>
                    </div>
                  </div>
                );
              })()}

              {/* Surrogate Confidence Map */}
              {trials.length >= 12 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const objKey = Object.keys(trials[0].kpis)[0];
                const scXParam = paramNames[0];
                const scYParam = paramNames[1];
                const scXVals = trials.map(t => Number(t.parameters[scXParam]) || 0);
                const scYVals = trials.map(t => Number(t.parameters[scYParam]) || 0);
                const scObjVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const scXMin = Math.min(...scXVals), scXMax = Math.max(...scXVals);
                const scYMin = Math.min(...scYVals), scYMax = Math.max(...scYVals);
                const scXRange = scXMax - scXMin || 1;
                const scYRange = scYMax - scYMin || 1;

                const res = 16;
                const confGrid: number[][] = [];
                for (let gy = 0; gy < res; gy++) {
                  const row: number[] = [];
                  for (let gx = 0; gx < res; gx++) {
                    const cx = scXMin + (gx + 0.5) * scXRange / res;
                    const cy = scYMin + (gy + 0.5) * scYRange / res;

                    // Find nearby trials within radius
                    const nearbyVals: number[] = [];
                    const nearbyDists: number[] = [];
                    for (let i = 0; i < trials.length; i++) {
                      const dx = (scXVals[i] - cx) / scXRange;
                      const dy = (scYVals[i] - cy) / scYRange;
                      const dist = Math.sqrt(dx * dx + dy * dy);
                      if (dist < 0.25) {
                        nearbyVals.push(scObjVals[i]);
                        nearbyDists.push(dist);
                      }
                    }

                    // Confidence: combination of density (more nearby = confident) and local consistency (low variance = confident)
                    const density = Math.min(nearbyVals.length / 8, 1); // saturates at 8 nearby trials
                    let consistency = 1;
                    if (nearbyVals.length >= 2) {
                      const mean = nearbyVals.reduce((a, b) => a + b, 0) / nearbyVals.length;
                      const variance = nearbyVals.reduce((a, v) => a + (v - mean) ** 2, 0) / nearbyVals.length;
                      const globalMean = scObjVals.reduce((a, b) => a + b, 0) / scObjVals.length;
                      const globalVar = scObjVals.reduce((a, v) => a + (v - globalMean) ** 2, 0) / scObjVals.length;
                      consistency = globalVar > 0 ? Math.max(0, 1 - variance / globalVar) : 1;
                    } else {
                      consistency = 0;
                    }

                    const confidence = 0.6 * density + 0.4 * consistency;
                    row.push(confidence);
                  }
                  confGrid.push(row);
                }

                const maxConf = Math.max(...confGrid.flat());
                const minConf = Math.min(...confGrid.flat());
                const confRange = maxConf - minConf || 1;
                const highConfPct = (confGrid.flat().filter(c => c > 0.5).length / (res * res) * 100).toFixed(0);

                const W = 420, H = 280, padL = 50, padR = 20, padT = 10, padB = 36;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const cellW = plotW / res;
                const cellH = plotH / res;

                const confColor = (v: number) => {
                  const t = (v - minConf) / confRange;
                  // Red (uncertain) → yellow → blue (confident)
                  if (t < 0.5) {
                    const p = t / 0.5;
                    return `rgb(${Math.round(239 - p * 5)}, ${Math.round(68 + p * 111)}, ${Math.round(68 - p * 60)})`;
                  }
                  const p = (t - 0.5) / 0.5;
                  return `rgb(${Math.round(234 - p * 175)}, ${Math.round(179 - p * 49)}, ${Math.round(8 + p * 227)})`;
                };

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Radar size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Model Confidence</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        {highConfPct}% confident
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Surrogate model confidence based on local trial density and prediction consistency. Blue = reliable predictions, red = uncertain.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {confGrid.map((row, gy) =>
                        row.map((conf, gx) => (
                          <rect
                            key={`${gy}-${gx}`}
                            x={padL + gx * cellW}
                            y={padT + gy * cellH}
                            width={cellW + 0.5}
                            height={cellH + 0.5}
                            fill={confColor(conf)}
                            opacity={0.75}
                          >
                            <title>{scXParam}≈{(scXMin + (gx + 0.5) * scXRange / res).toFixed(2)}, {scYParam}≈{(scYMin + (gy + 0.5) * scYRange / res).toFixed(2)} | Confidence={conf.toFixed(3)}</title>
                          </rect>
                        ))
                      )}
                      {/* Trial positions */}
                      {trials.map((t, i) => {
                        const px = padL + ((scXVals[i] - scXMin) / scXRange) * plotW;
                        const py = padT + ((scYVals[i] - scYMin) / scYRange) * plotH;
                        return (
                          <circle key={i} cx={px} cy={py} r="2.5" fill="white" stroke="rgba(0,0,0,0.4)" strokeWidth="0.5">
                            <title>Trial #{t.iteration}: {objKey}={scObjVals[i].toFixed(4)}</title>
                          </circle>
                        );
                      })}
                      {/* Axes */}
                      <line x1={padL} y1={padT} x2={padL} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      <line x1={padL} y1={padT + plotH} x2={padL + plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={`sc${f}`}>
                          <text x={padL + f * plotW} y={H - 12} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(scXMin + f * scXRange).toFixed(2)}
                          </text>
                          <text x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(scYMin + f * scYRange).toFixed(2)}
                          </text>
                        </Fragment>
                      ))}
                      <text x={padL + plotW / 2} y={H - 0} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">{scXParam}</text>
                      <text x={10} y={padT + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" transform={`rotate(-90, 10, ${padT + plotH / 2})`}>{scYParam}</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(239,68,68)", marginRight: 4, verticalAlign: "middle" }} />Uncertain</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(234,179,8)", marginRight: 4, verticalAlign: "middle" }} />Moderate</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgb(59,130,235)", marginRight: 4, verticalAlign: "middle" }} />Confident</span>
                    </div>
                  </div>
                );
              })()}

              {/* Pareto Front — shown when 2+ objectives are configured */}
              {(() => {
                const objNames = campaign.objective_names ?? [];
                const objDirs = campaign.objective_directions ?? {};
                const obs = campaign.observations ?? [];
                if (objNames.length >= 2) {
                  return (
                    <div className="card">
                      <h2>Pareto Front</h2>
                      {obs.length > 0 ? (
                        <ParetoPlot
                          observations={obs}
                          objectiveNames={objNames}
                          objectiveDirections={objNames.map(
                            (n) => objDirs[n] ?? "minimize"
                          )}
                        />
                      ) : (
                        <p className="empty-state">
                          No observation data yet. Run some experiments to see the Pareto front.
                        </p>
                      )}
                    </div>
                  );
                }
                return null;
              })()}
            </div>
          )}

          {activeTab === "suggestions" && (
            <div className="tab-panel">
              {/* Suggestions Controls */}
              <div className="suggestions-controls">
                <div className="suggestions-controls-left">
                  <button
                    className="btn btn-primary suggestions-generate-btn"
                    onClick={handleGenerateSuggestions}
                    disabled={loadingSuggestions}
                  >
                    {loadingSuggestions ? (
                      <>
                        <span className="suggestions-spinner" />
                        Generating...
                      </>
                    ) : (
                      <>
                        <Sparkles size={16} />
                        Generate Next Experiments
                      </>
                    )}
                  </button>
                  <label className="suggestions-batch-label">
                    Batch size
                    <select
                      className="suggestions-batch-select"
                      value={batchSize}
                      onChange={(e) => setBatchSize(Number(e.target.value))}
                    >
                      <option value="3">3</option>
                      <option value="5">5</option>
                      <option value="8">8</option>
                      <option value="10">10</option>
                    </select>
                  </label>
                </div>
                {suggestions && (
                  <div className="suggestions-meta">
                    <span className="suggestions-meta-pill">
                      <FlaskConical size={12} /> {suggestions.backend_used}
                    </span>
                    <span className="suggestions-meta-pill">
                      Phase: {suggestions.phase}
                    </span>
                    <button
                      className="btn btn-secondary btn-sm suggestions-export-btn"
                      onClick={handleExportSuggestionsCSV}
                      title="Download suggestions as CSV"
                    >
                      <FileDown size={14} /> Export CSV
                    </button>
                  </div>
                )}
              </div>

              {/* Suggestion Context Cards */}
              {trials.length >= 3 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const objVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const bestVal = Math.min(...objVals);
                const meanVal = objVals.reduce((a, b) => a + b, 0) / objVals.length;
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const recentN = Math.min(10, chrono.length);
                const recentTrials = chrono.slice(-recentN);
                const recentBest = Math.min(...recentTrials.map(t => Number(t.kpis[objKey]) || 0));
                const recentImproving = recentBest < meanVal;

                // Parameter diversity: coefficient of variation across parameters
                const paramNames = Object.keys(trials[0].parameters);
                const paramDiversity = paramNames.length > 0 ? (() => {
                  let totalCv = 0;
                  for (const p of paramNames) {
                    const pVals = recentTrials.map(t => Number(t.parameters[p]) || 0);
                    const pMean = pVals.reduce((a, b) => a + b, 0) / pVals.length;
                    const pStd = Math.sqrt(pVals.reduce((a, v) => a + (v - pMean) ** 2, 0) / pVals.length);
                    totalCv += pMean !== 0 ? Math.abs(pStd / pMean) : 0;
                  }
                  return Math.min((totalCv / paramNames.length) * 100, 100);
                })() : 0;

                const phase = suggestions?.phase ?? campaign.phases[campaign.phases.length - 1]?.name ?? "Unknown";
                const contextItems = [
                  { icon: <Trophy size={14} />, label: "Best Found", value: bestVal.toFixed(4), sub: objKey },
                  { icon: <Target size={14} />, label: "Recent Trend", value: recentImproving ? "Improving" : "Plateaued", sub: `Last ${recentN} trials` },
                  { icon: <Compass size={14} />, label: "Param Diversity", value: `${paramDiversity.toFixed(0)}%`, sub: "Recent spread" },
                  { icon: <Rocket size={14} />, label: "Phase", value: String(phase).charAt(0).toUpperCase() + String(phase).slice(1), sub: `${trials.length} trials total` },
                ];

                return (
                  <div style={{
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(140px, 1fr))",
                    gap: "10px",
                    marginBottom: "16px",
                  }}>
                    {contextItems.map((item, i) => (
                      <div key={i} style={{
                        background: "var(--color-card-bg)",
                        border: "1px solid var(--color-border)",
                        borderRadius: "8px",
                        padding: "10px 12px",
                        display: "flex",
                        flexDirection: "column",
                        gap: "4px",
                      }}>
                        <div style={{ display: "flex", alignItems: "center", gap: "6px", color: "var(--color-text-muted)" }}>
                          {item.icon}
                          <span style={{ fontSize: "0.72rem", fontWeight: 500, textTransform: "uppercase", letterSpacing: "0.04em" }}>
                            {item.label}
                          </span>
                        </div>
                        <div style={{ fontSize: "1.1rem", fontWeight: 600, fontFamily: "var(--font-mono)", color: "var(--color-text-primary)" }}>
                          {item.value}
                        </div>
                        <div style={{ fontSize: "0.7rem", color: "var(--color-text-muted)" }}>
                          {item.sub}
                        </div>
                      </div>
                    ))}
                  </div>
                );
              })()}

              {/* EI Decomposition View */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const objVals = trials.map(t => Number(t.kpis[objKey]) || 0);
                const bestSoFar = Math.min(...objVals);
                const meanObj = objVals.reduce((a, b) => a + b, 0) / objVals.length;
                const stdObj = Math.sqrt(objVals.reduce((a, v) => a + (v - meanObj) ** 2, 0) / objVals.length) || 1;

                // For each suggestion, estimate exploitation (predicted improvement) and exploration (novelty/uncertainty)
                const eiData = suggestions.suggestions.map((sug, idx) => {
                  const params = Object.values(sug).map(Number);
                  // Exploitation: predicted improvement based on nearest neighbor interpolation
                  let minDist = Infinity;
                  let nearestVal = meanObj;
                  for (const t of trials) {
                    const tParams = Object.values(t.parameters).map(Number);
                    const dist = Math.sqrt(tParams.reduce((sum, v, i) => sum + (v - (params[i] || 0)) ** 2, 0));
                    if (dist < minDist) { minDist = dist; nearestVal = Number(t.kpis[objKey]) || 0; }
                  }
                  const exploitation = Math.max(0, bestSoFar - nearestVal + stdObj * 0.3) / (stdObj * 2);
                  // Exploration: average distance to all trials (normalized)
                  const avgDist = trials.reduce((sum, t) => {
                    const tParams = Object.values(t.parameters).map(Number);
                    return sum + Math.sqrt(tParams.reduce((s, v, i) => s + (v - (params[i] || 0)) ** 2, 0));
                  }, 0) / trials.length;
                  const maxPossibleDist = stdObj * Math.sqrt(params.length) * 3;
                  const exploration = Math.min(avgDist / (maxPossibleDist || 1), 1);
                  return { idx: idx + 1, exploitation: Math.min(exploitation, 1), exploration: Math.min(exploration, 1), total: exploitation + exploration };
                });

                const maxTotal = Math.max(...eiData.map(d => d.total), 0.01);
                const barH = 18, gap = 6;
                const W = 380, padL = 42, padR = 16;
                const barW = W - padL - padR;
                const H = eiData.length * (barH + gap) + 40;

                return (
                  <div className="card" style={{ marginBottom: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "4px" }}>
                      <BarChart2 size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Acquisition Decomposition</h2>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Each suggestion's acquisition value split into exploitation (predicted improvement) and exploration (uncertainty/novelty).
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {eiData.map((d, i) => {
                        const y = 24 + i * (barH + gap);
                        const exploitW = (d.exploitation / maxTotal) * barW;
                        const exploreW = (d.exploration / maxTotal) * barW;
                        return (
                          <Fragment key={i}>
                            <text x={padL - 6} y={y + barH / 2 + 3} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                              #{d.idx}
                            </text>
                            {/* Exploitation bar */}
                            <rect x={padL} y={y} width={Math.max(exploitW, 1)} height={barH} rx="3" fill="rgba(34,197,94,0.55)" />
                            {/* Exploration bar */}
                            <rect x={padL + exploitW} y={y} width={Math.max(exploreW, 1)} height={barH} rx="3" fill="rgba(59,130,246,0.5)" />
                            {/* Value label */}
                            <text x={padL + exploitW + exploreW + 4} y={y + barH / 2 + 3} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                              {d.total.toFixed(2)}
                            </text>
                          </Fragment>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(34,197,94,0.55)", marginRight: 4, verticalAlign: "middle" }} />Exploitation</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(59,130,246,0.5)", marginRight: 4, verticalAlign: "middle" }} />Exploration</span>
                    </div>
                  </div>
                );
              })()}

              {/* Surrogate Calibration Scatter */}
              {suggestions && suggestions.predicted_values && trials.length >= 8 && (() => {
                // Compare predicted vs actual for past trials via leave-one-out style
                // Use last N trials as "test" points: compare actual to nearest-neighbor predicted
                const scObjKey = Object.keys(trials[0].kpis)[0];
                const scN = Math.min(trials.length, 40);
                const scTrials = trials.slice(-scN);
                const scActual = scTrials.map(t => Number(t.kpis[scObjKey]) || 0);
                // Approximate predictions using LOO nearest-neighbor from remaining trials
                const scPredicted = scTrials.map((t, idx) => {
                  const others = trials.filter((_, j) => j !== trials.length - scN + idx);
                  if (others.length === 0) return scActual[idx];
                  const pKeys = Object.keys(t.parameters);
                  let bestDist = Infinity, bestVal = scActual[idx];
                  for (const o of others) {
                    let dist = 0;
                    for (const k of pKeys) {
                      const diff = (Number(t.parameters[k]) || 0) - (Number(o.parameters[k]) || 0);
                      dist += diff * diff;
                    }
                    if (dist < bestDist) {
                      bestDist = dist;
                      bestVal = Number(o.kpis[scObjKey]) || 0;
                    }
                  }
                  return bestVal;
                });

                const allVals = [...scActual, ...scPredicted];
                const scMin = Math.min(...allVals);
                const scMax = Math.max(...allVals);
                const scRange = scMax - scMin || 1;
                const scW = 280, scH = 260, scPadL = 48, scPadR = 16, scPadT = 16, scPadB = 36;
                const scPlotW = scW - scPadL - scPadR;
                const scPlotH = scH - scPadT - scPadB;
                const toSX = (v: number) => scPadL + ((v - scMin) / scRange) * scPlotW;
                const toSY = (v: number) => scPadT + scPlotH - ((v - scMin) / scRange) * scPlotH;

                // R² calculation
                const meanActual = scActual.reduce((a, b) => a + b, 0) / scActual.length;
                const ssTot = scActual.reduce((s, v) => s + (v - meanActual) ** 2, 0);
                const ssRes = scActual.reduce((s, v, i) => s + (v - scPredicted[i]) ** 2, 0);
                const r2 = ssTot > 0 ? 1 - ssRes / ssTot : 0;

                // RMSE
                const rmse = Math.sqrt(ssRes / scActual.length);

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <BarChart2 size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Surrogate Calibration</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Predicted vs actual comparison for last {scN} trials (LOO nearest-neighbor).
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        R² = {r2.toFixed(3)}
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={scW} height={scH} viewBox={`0 0 ${scW} ${scH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Grid lines */}
                        {[0, 0.25, 0.5, 0.75, 1].map(f => {
                          const v = scMin + f * scRange;
                          return (
                            <g key={f}>
                              <line x1={toSX(v)} y1={scPadT} x2={toSX(v)} y2={scPadT + scPlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                              <line x1={scPadL} y1={toSY(v)} x2={scPadL + scPlotW} y2={toSY(v)} stroke="var(--color-border)" strokeWidth={0.5} />
                            </g>
                          );
                        })}
                        {/* Perfect calibration line */}
                        <line
                          x1={toSX(scMin)} y1={toSY(scMin)}
                          x2={toSX(scMax)} y2={toSY(scMax)}
                          stroke="var(--color-text-muted)"
                          strokeWidth={1.5}
                          strokeDasharray="6,3"
                          opacity={0.5}
                        />
                        {/* Data points */}
                        {scActual.map((actual, i) => {
                          const pred = scPredicted[i];
                          const error = Math.abs(actual - pred) / scRange;
                          const pointColor = error < 0.1 ? "rgba(34,197,94,0.7)" : error < 0.25 ? "rgba(234,179,8,0.7)" : "rgba(239,68,68,0.7)";
                          return (
                            <circle
                              key={i}
                              cx={toSX(pred)}
                              cy={toSY(actual)}
                              r={4}
                              fill={pointColor}
                              stroke="rgba(255,255,255,0.4)"
                              strokeWidth={0.5}
                            >
                              <title>Trial {scN - scActual.length + i + 1}: pred={pred.toPrecision(4)}, actual={actual.toPrecision(4)}</title>
                            </circle>
                          );
                        })}
                        {/* Axes */}
                        <text x={scPadL + scPlotW / 2} y={scH - 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          Predicted
                        </text>
                        <text x={10} y={scPadT + scPlotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" transform={`rotate(-90,10,${scPadT + scPlotH / 2})`}>
                          Actual
                        </text>
                        {/* Axis tick labels */}
                        {[0, 0.5, 1].map(f => {
                          const v = scMin + f * scRange;
                          return (
                            <g key={f}>
                              <text x={toSX(v)} y={scPadT + scPlotH + 14} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                                {v.toPrecision(3)}
                              </text>
                              <text x={scPadL - 4} y={toSY(v) + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                                {v.toPrecision(3)}
                              </text>
                            </g>
                          );
                        })}
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(34,197,94,0.7)", marginRight: 4, verticalAlign: "middle" }} />&lt;10% error</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(234,179,8,0.7)", marginRight: 4, verticalAlign: "middle" }} />10-25% error</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(239,68,68,0.7)", marginRight: 4, verticalAlign: "middle" }} />&gt;25% error</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.78rem", color: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>
                        RMSE: {rmse.toPrecision(3)}
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Suggestion Stability Scores */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 8 && (() => {
                // Bootstrap stability: resample trials N times, re-rank by nearest-neighbor predicted obj
                const ssObjKey = Object.keys(trials[0].kpis)[0];
                const ssPKeys = Object.keys(trials[0].parameters);
                const nBoot = 20;

                const ssScores = suggestions.suggestions.map((sug) => {
                  const sugParams = ssPKeys.map(k => Number(sug[k]) || 0);
                  // For each bootstrap, find NN prediction and rank this suggestion
                  const predictions: number[] = [];
                  for (let b = 0; b < nBoot; b++) {
                    // Resample trials with replacement
                    const bootTrials: typeof trials = [];
                    for (let i = 0; i < trials.length; i++) {
                      bootTrials.push(trials[Math.floor(Math.random() * trials.length)]);
                    }
                    // NN prediction
                    let bestDist = Infinity, pred = 0;
                    for (const bt of bootTrials) {
                      let dist = 0;
                      for (let k = 0; k < ssPKeys.length; k++) {
                        const diff = sugParams[k] - (Number(bt.parameters[ssPKeys[k]]) || 0);
                        dist += diff * diff;
                      }
                      if (dist < bestDist) {
                        bestDist = dist;
                        pred = Number(bt.kpis[ssObjKey]) || 0;
                      }
                    }
                    predictions.push(pred);
                  }
                  // Stability = 1 - (std / range)
                  const meanPred = predictions.reduce((a, b) => a + b, 0) / nBoot;
                  const stdPred = Math.sqrt(predictions.reduce((s, p) => s + (p - meanPred) ** 2, 0) / nBoot);
                  const allObjVals = trials.map(t => Number(t.kpis[ssObjKey]) || 0);
                  const objRange = Math.max(...allObjVals) - Math.min(...allObjVals) || 1;
                  const stability = Math.max(0, Math.min(1, 1 - stdPred / (objRange * 0.5)));
                  return { stability: Math.round(stability * 100), meanPred, stdPred };
                });

                const avgStability = ssScores.reduce((s, sc) => s + sc.stability, 0) / ssScores.length;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Flag size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Suggestion Stability</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Bootstrap reliability of each suggestion ({nBoot} resamples). Higher = more robust.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        avg {avgStability.toFixed(0)}%
                      </span>
                    </div>
                    <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                      {ssScores.map((sc, i) => {
                        const color = sc.stability >= 80 ? "rgba(34,197,94,0.7)" : sc.stability >= 50 ? "rgba(234,179,8,0.7)" : "rgba(239,68,68,0.7)";
                        const label = sc.stability >= 80 ? "Stable" : sc.stability >= 50 ? "Moderate" : "Unstable";
                        return (
                          <div key={i} style={{ display: "flex", alignItems: "center", gap: 10, padding: "4px 0" }}>
                            <span style={{ width: 32, fontSize: "0.82rem", fontWeight: 600, color: "var(--color-text-muted)", textAlign: "right", fontFamily: "var(--font-mono)", flexShrink: 0 }}>
                              #{i + 1}
                            </span>
                            <div style={{ flex: 1, height: 14, background: "var(--color-border)", borderRadius: 4, overflow: "hidden", position: "relative" }}>
                              <div style={{ width: `${sc.stability}%`, height: "100%", background: color, borderRadius: 4, transition: "width 0.3s ease", minWidth: 2 }} />
                            </div>
                            <span style={{ width: 42, fontSize: "0.78rem", fontFamily: "var(--font-mono)", fontWeight: 600, color, textAlign: "right", flexShrink: 0 }}>
                              {sc.stability}%
                            </span>
                            <span style={{ width: 60, fontSize: "0.72rem", color: "var(--color-text-muted)", flexShrink: 0 }}>
                              {label}
                            </span>
                          </div>
                        );
                      })}
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "8px", flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(34,197,94,0.7)", marginRight: 4, verticalAlign: "middle" }} />Stable (&ge;80%)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(234,179,8,0.7)", marginRight: 4, verticalAlign: "middle" }} />Moderate (50-80%)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(239,68,68,0.7)", marginRight: 4, verticalAlign: "middle" }} />Unstable (&lt;50%)</span>
                    </div>
                  </div>
                );
              })()}

              {/* Suggestion Novelty Scores */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 3 && (() => {
                const snPKeys = Object.keys(trials[0].parameters);
                const snSpecs = campaign.spec?.parameters || [];
                const snRanges = snPKeys.map(k => {
                  const sp = snSpecs.find((s: { name: string }) => s.name === k);
                  const lo = sp && (sp as { lower?: number }).lower != null ? (sp as { lower: number }).lower : Math.min(...trials.map(t => Number(t.parameters[k]) || 0));
                  const hi = sp && (sp as { upper?: number }).upper != null ? (sp as { upper: number }).upper : Math.max(...trials.map(t => Number(t.parameters[k]) || 0));
                  return hi - lo || 1;
                });
                // Normalize trial coords
                const snTrialCoords = trials.map(t => snPKeys.map((k, d) => (Number(t.parameters[k]) || 0) / snRanges[d]));
                const snScores = suggestions.suggestions.map((sug) => {
                  const sugCoords = snPKeys.map((k, d) => (Number(sug[k]) || 0) / snRanges[d]);
                  let minDist = Infinity;
                  for (const tc of snTrialCoords) {
                    const dist = Math.sqrt(tc.reduce((s, v, d) => s + (v - sugCoords[d]) ** 2, 0));
                    if (dist < minDist) minDist = dist;
                  }
                  return minDist;
                });
                // Normalize to 0-1 (max possible dist in unit cube = sqrt(dims))
                const snMaxDist = Math.sqrt(snPKeys.length);
                const snNorm = snScores.map(d => Math.min(d / (snMaxDist * 0.5), 1));
                const snAvg = snNorm.reduce((a, b) => a + b, 0) / snNorm.length;
                const snW = 320, snH = 80, snPad = 16;
                const snCircleR = 18;
                const snSpacing = Math.min((snW - 2 * snPad) / snNorm.length, snCircleR * 2.8);
                const snStartX = snPad + (snW - 2 * snPad - (snNorm.length - 1) * snSpacing) / 2;
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "flex-start", gap: "10px", marginBottom: "8px" }}>
                      <Circle size={16} style={{ color: "var(--color-primary)", marginTop: 2 }} />
                      <div style={{ flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Suggestion Novelty</h2>
                        <p style={{ margin: "2px 0 0", fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                          Min distance from each suggestion to historical trials. Higher = more novel.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ background: snAvg > 0.5 ? "rgba(59,130,246,0.12)" : snAvg > 0.25 ? "rgba(234,179,8,0.12)" : "rgba(239,68,68,0.12)", color: snAvg > 0.5 ? "#3b82f6" : snAvg > 0.25 ? "#eab308" : "#ef4444", border: `1px solid ${snAvg > 0.5 ? "#3b82f644" : snAvg > 0.25 ? "#eab30844" : "#ef444444"}` }}>
                        avg {(snAvg * 100).toFixed(0)}% novel
                      </span>
                    </div>
                    <svg width={snW} height={snH} viewBox={`0 0 ${snW} ${snH}`} role="img" aria-label="Suggestion novelty scores" style={{ display: "block", margin: "0 auto" }}>
                      {snNorm.map((nov, i) => {
                        const cx = snStartX + i * snSpacing;
                        const cy = snH / 2;
                        const fillColor = nov > 0.5 ? "#3b82f6" : nov > 0.25 ? "#eab308" : "#ef4444";
                        const fillH = snCircleR * 2 * nov;
                        const clipId = `sn-clip-${i}`;
                        return (
                          <g key={i}>
                            <defs>
                              <clipPath id={clipId}>
                                <circle cx={cx} cy={cy} r={snCircleR - 1} />
                              </clipPath>
                            </defs>
                            {/* Background circle */}
                            <circle cx={cx} cy={cy} r={snCircleR} fill="none" stroke="var(--color-border)" strokeWidth={1.5} />
                            {/* Fill from bottom */}
                            <rect x={cx - snCircleR} y={cy + snCircleR - fillH} width={snCircleR * 2} height={fillH} fill={fillColor} opacity={0.6} clipPath={`url(#${clipId})`} />
                            {/* Label */}
                            <text x={cx} y={cy + 4} textAnchor="middle" fontSize="9" fontWeight="600" fill="var(--color-text-primary)" fontFamily="var(--font-mono)">
                              {(nov * 100).toFixed(0)}%
                            </text>
                            {/* Rank below */}
                            <text x={cx} y={cy + snCircleR + 12} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)">
                              #{i + 1}
                            </text>
                            <title>Suggestion #{i + 1}: {(nov * 100).toFixed(1)}% novelty (min distance: {snScores[i].toPrecision(3)})</title>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "#3b82f6", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />High (&gt;50%)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "#eab308", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />Moderate (25-50%)</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "#ef4444", opacity: 0.6, marginRight: 4, verticalAlign: "middle" }} />Low (&lt;25%)</span>
                    </div>
                  </div>
                );
              })()}

              {/* Trust Region Membership */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 3 && (() => {
                const trSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (trSpecs.length === 0) return null;
                // Normalize observations
                const trNorm = (val: number, sp: { lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0, hi = sp.upper ?? 1;
                  return hi > lo ? (val - lo) / (hi - lo) : 0.5;
                };
                const trObsNormed = trials.map(t => trSpecs.map((s: { name: string; lower?: number; upper?: number }) => trNorm(t.parameters[s.name] ?? 0, s)));
                const trDist = (a: number[], b: number[]) => Math.sqrt(a.reduce((s, v, i) => s + (v - (b[i] ?? 0)) ** 2, 0));
                // Get objective values
                const trObjKey = campaign.objective_names?.[0] || Object.keys(trials[0].kpis)[0];
                const trObjDir = (campaign.objective_directions?.[trObjKey] || "minimize") === "minimize" ? -1 : 1;
                const trScored = trObsNormed.map((n, i) => ({ normed: n, score: (trials[i].kpis[trObjKey] ?? 0) * trObjDir }));
                trScored.sort((a, b) => b.score - a.score);
                // Greedy select local optima
                const trOptima: { normed: number[]; radius: number }[] = [];
                const trMaxK = 3;
                for (const obs of trScored) {
                  if (trOptima.length >= trMaxK) break;
                  const tooClose = trOptima.some(o => trDist(o.normed, obs.normed) < 0.25);
                  if (!tooClose) {
                    trOptima.push({ normed: obs.normed, radius: 0.15 + 0.1 * (1 - trOptima.length / trMaxK) });
                  }
                }
                if (trOptima.length === 0) return null;
                // PCA-like 1D projection: use first continuous parameter dimension
                const trProject = (normed: number[]) => normed[0] ?? 0.5;
                // Classify suggestions
                const trSugs = suggestions.suggestions.map((sug: Record<string, number>, idx: number) => {
                  const normed = trSpecs.map((s: { name: string; lower?: number; upper?: number }) => trNorm(sug[s.name] ?? 0, s));
                  const minDist = Math.min(...trOptima.map(o => trDist(o.normed, normed) - o.radius));
                  return { idx: idx + 1, normed, proj: trProject(normed), exploit: minDist < 0 };
                });
                const trExploitCount = trSugs.filter((s: { exploit: boolean }) => s.exploit).length;
                const trExploreCount = trSugs.length - trExploitCount;
                const trStripW = 200, trStripH = 44;
                const trPadX = 10;
                const trMapX = (v: number) => trPadX + v * (trStripW - 2 * trPadX);
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Scan size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Trust Region Membership</h3>
                      <span className="findings-badge" style={{ background: trExploitCount > trExploreCount ? "#3b82f618" : "#f9731618", color: trExploitCount > trExploreCount ? "#3b82f6" : "#f97316", marginLeft: "auto" }}>
                        {trExploitCount} exploit / {trExploreCount} explore
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${trStripW} ${trStripH}`} style={{ display: "block" }}>
                      {/* Strip background */}
                      <rect x={trPadX} y={12} width={trStripW - 2 * trPadX} height={16} rx={8} fill="var(--color-border)" opacity={0.5} />
                      {/* Trust regions */}
                      {trOptima.map((o, i) => {
                        const cx = trMapX(trProject(o.normed));
                        const rw = o.radius * (trStripW - 2 * trPadX);
                        return (
                          <Fragment key={`trr${i}`}>
                            <rect x={Math.max(trPadX, cx - rw)} y={12} width={Math.min(rw * 2, trStripW - 2 * trPadX)} height={16} rx={8} fill="#3b82f6" opacity={0.12} />
                            <polygon points={`${cx - 3},12 ${cx + 3},12 ${cx},8`} fill="#eab308" />
                          </Fragment>
                        );
                      })}
                      {/* Suggestion dots */}
                      {trSugs.map((s: { idx: number; proj: number; exploit: boolean }) => (
                        <circle key={`trs${s.idx}`} cx={trMapX(s.proj)} cy={20} r={4.5} fill={s.exploit ? "#3b82f6" : "#f97316"} stroke="white" strokeWidth="1" />
                      ))}
                      {/* Labels */}
                      <text x={trPadX} y={trStripH - 1} fontSize="6" fill="var(--color-text-muted)">0</text>
                      <text x={trStripW - trPadX} y={trStripH - 1} fontSize="6" fill="var(--color-text-muted)" textAnchor="end">1</text>
                      <text x={trStripW / 2} y={trStripH - 1} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle">{trSpecs[0]?.name || "dim 1"} (normalized)</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6" }} /> Exploit
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#f97316" }} /> Explore
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        <span style={{ display: "inline-block", width: 0, height: 0, borderLeft: "4px solid transparent", borderRight: "4px solid transparent", borderBottom: "6px solid #eab308" }} /> Local optima
                      </span>
                      <span style={{ marginLeft: "auto" }}>
                        <span style={{ display: "inline-block", width: 16, height: 8, background: "#3b82f6", opacity: 0.12, borderRadius: 3, marginRight: 3, verticalAlign: "middle" }} /> Trust regions
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* D-Optimality Scores */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const doSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (doSpecs.length === 0) return null;
                const doD = doSpecs.length;
                const doNorm = (val: number, sp: { lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0, hi = sp.upper ?? 1;
                  return hi > lo ? (val - lo) / (hi - lo) : 0.5;
                };
                // Existing design matrix (normalized)
                const doX = trials.map(t => doSpecs.map((s: { name: string; lower?: number; upper?: number }) => doNorm(t.parameters[s.name] ?? 0, s)));
                // Compute min distance to existing points for each suggestion (space-filling score)
                const doScores = suggestions.suggestions.map((sug: Record<string, number>, idx: number) => {
                  const sugNorm = doSpecs.map((s: { name: string; lower?: number; upper?: number }) => doNorm(sug[s.name] ?? 0, s));
                  // D-optimality proxy: min distance to existing points (space-filling)
                  const minDist = Math.min(...doX.map((obs: number[]) => Math.sqrt(obs.reduce((a: number, v: number, i: number) => a + (v - sugNorm[i]) ** 2, 0))));
                  // A-optimality proxy: average distance to k nearest
                  const allDists = doX.map((obs: number[]) => Math.sqrt(obs.reduce((a: number, v: number, i: number) => a + (v - sugNorm[i]) ** 2, 0))).sort((a: number, b: number) => a - b);
                  const kNearest = allDists.slice(0, 5);
                  const avgKDist = kNearest.reduce((a: number, b: number) => a + b, 0) / kNearest.length;
                  // E-optimality proxy: distance from centroid
                  const centroid = doSpecs.map((_: unknown, di: number) => doX.reduce((a: number, obs: number[]) => a + obs[di], 0) / doX.length);
                  const centDist = Math.sqrt(centroid.reduce((a: number, c: number, i: number) => a + (c - sugNorm[i]) ** 2, 0));
                  return { idx: idx + 1, dScore: minDist, aScore: avgKDist, eScore: centDist };
                });
                // Normalize scores to 0-100
                const doMaxD = Math.max(...doScores.map((s: { dScore: number }) => s.dScore), 0.01);
                const doMaxA = Math.max(...doScores.map((s: { aScore: number }) => s.aScore), 0.01);
                const doMaxE = Math.max(...doScores.map((s: { eScore: number }) => s.eScore), 0.01);
                const doNormed = doScores.map((s: { idx: number; dScore: number; aScore: number; eScore: number }) => ({
                  idx: s.idx,
                  d: (s.dScore / doMaxD) * 100,
                  a: (s.aScore / doMaxA) * 100,
                  e: (s.eScore / doMaxE) * 100,
                }));
                const doBarW = 14, doGap = 6, doGroupW = doBarW * 3 + doGap;
                const doSvgW = doNormed.length * (doGroupW + 12) + 30;
                const doSvgH = 60;
                const doPadY = 10, doPadX = 20;
                const doChartH = doSvgH - 2 * doPadY;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Diamond size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Design Optimality</h3>
                      <span className="findings-badge" style={{ background: "#3b82f618", color: "#3b82f6", marginLeft: "auto" }}>
                        {doD}D space-filling
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${doSvgW} ${doSvgH}`} style={{ display: "block" }}>
                      {/* 50% reference line */}
                      <line x1={doPadX} y1={doPadY + doChartH * 0.5} x2={doSvgW - 5} y2={doPadY + doChartH * 0.5} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3 2" />
                      <text x={doPadX - 2} y={doPadY + doChartH * 0.5 + 2} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">50</text>
                      {/* Bars for each suggestion */}
                      {doNormed.map((s: { idx: number; d: number; a: number; e: number }, i: number) => {
                        const gx = doPadX + i * (doGroupW + 12);
                        const barH = (v: number) => (v / 100) * doChartH;
                        return (
                          <Fragment key={`do${i}`}>
                            <rect x={gx} y={doPadY + doChartH - barH(s.d)} width={doBarW} height={barH(s.d)} rx={2} fill="#3b82f6" opacity={0.8} />
                            <rect x={gx + doBarW} y={doPadY + doChartH - barH(s.a)} width={doBarW} height={barH(s.a)} rx={2} fill="#22c55e" opacity={0.8} />
                            <rect x={gx + doBarW * 2} y={doPadY + doChartH - barH(s.e)} width={doBarW} height={barH(s.e)} rx={2} fill="#8b5cf6" opacity={0.8} />
                            <text x={gx + doGroupW / 2} y={doSvgH - 1} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">#{s.idx}</text>
                          </Fragment>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 10, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, background: "#3b82f6" }} /> D-opt (min dist)
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, background: "#22c55e" }} /> A-opt (k-NN avg)
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, background: "#8b5cf6" }} /> E-opt (centroid)
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Boundary Proximity Radar */}
              {suggestions && suggestions.suggestions.length > 0 && (() => {
                const bpSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (bpSpecs.length < 3) return null;
                const bpParams = bpSpecs.slice(0, 8);
                const bpN = bpParams.length;
                const bpSugs = suggestions.suggestions.slice(0, 5);

                // For each suggestion, compute normalized boundary proximity per param
                // proximity = how close to nearest bound (0=center, 1=at boundary)
                const bpData = bpSugs.map((sug: Record<string, number>) => {
                  return bpParams.map((s: { name: string; lower?: number; upper?: number }) => {
                    const lo = s.lower ?? 0, hi = s.upper ?? 1;
                    const norm = hi > lo ? (Number(sug[s.name] ?? 0) - lo) / (hi - lo) : 0.5;
                    return Math.abs(norm - 0.5) * 2; // 0=center, 1=boundary
                  });
                });

                const bpW = 200, bpH = 200, bpCx = bpW / 2, bpCy = bpH / 2, bpR = 72;
                const bpColors = ["rgba(59,130,246,0.6)", "rgba(34,197,94,0.6)", "rgba(234,179,8,0.6)", "rgba(239,68,68,0.5)", "rgba(168,85,247,0.5)"];

                // Polygon points helper
                const bpPoly = (values: number[]) => {
                  return values.map((v, i) => {
                    const angle = (2 * Math.PI * i) / bpN - Math.PI / 2;
                    const r = v * bpR;
                    return `${(bpCx + r * Math.cos(angle)).toFixed(1)},${(bpCy + r * Math.sin(angle)).toFixed(1)}`;
                  }).join(" ");
                };

                const bpAvgProx = bpData.flat().reduce((a: number, b: number) => a + b, 0) / (bpData.flat().length || 1);
                const bpLabel = bpAvgProx > 0.6 ? "Boundary-seeking" : bpAvgProx > 0.3 ? "Balanced" : "Interior-focused";

                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Orbit size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Boundary Proximity</h3>
                      <span className="findings-badge" style={{ marginLeft: "auto", color: bpAvgProx > 0.6 ? "#f59e0b" : "#22c55e", borderColor: bpAvgProx > 0.6 ? "rgba(245,158,11,0.3)" : "rgba(34,197,94,0.3)" }}>
                        {bpLabel}
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${bpW} ${bpH}`} style={{ display: "block" }}>
                      {/* Grid circles */}
                      {[0.25, 0.5, 0.75, 1].map(f => (
                        <circle key={f} cx={bpCx} cy={bpCy} r={f * bpR} fill="none" stroke="var(--color-border)" strokeWidth="0.5" opacity={0.5} />
                      ))}
                      {/* Axis lines and labels */}
                      {bpParams.map((s: { name: string }, i: number) => {
                        const angle = (2 * Math.PI * i) / bpN - Math.PI / 2;
                        const lx = bpCx + (bpR + 16) * Math.cos(angle);
                        const ly = bpCy + (bpR + 16) * Math.sin(angle);
                        return (
                          <g key={i}>
                            <line x1={bpCx} y1={bpCy} x2={bpCx + bpR * Math.cos(angle)} y2={bpCy + bpR * Math.sin(angle)} stroke="var(--color-border)" strokeWidth="0.5" opacity={0.4} />
                            <text x={lx} y={ly + 3} textAnchor="middle" fontSize="6.5" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                              {s.name.length > 6 ? s.name.slice(0, 5) + "…" : s.name}
                            </text>
                          </g>
                        );
                      })}
                      {/* Suggestion polygons */}
                      {bpData.map((vals: number[], si: number) => (
                        <polygon key={si} points={bpPoly(vals)} fill={bpColors[si % bpColors.length]} fillOpacity={0.12} stroke={bpColors[si % bpColors.length]} strokeWidth="1.5" />
                      ))}
                      {/* Center dot */}
                      <circle cx={bpCx} cy={bpCy} r="2" fill="var(--color-text-muted)" opacity={0.4} />
                      {/* Scale labels */}
                      <text x={bpCx + 3} y={bpCy - bpR + 3} fontSize="5.5" fill="var(--color-text-muted)">edge</text>
                      <text x={bpCx + 3} y={bpCy - 3} fontSize="5.5" fill="var(--color-text-muted)">center</text>
                    </svg>
                    <div style={{ display: "flex", gap: "10px", marginTop: "2px", flexWrap: "wrap", alignItems: "center", justifyContent: "center" }}>
                      {bpSugs.map((_: Record<string, number>, i: number) => (
                        <span key={i} className="efficiency-legend-item">
                          <span style={{ display: "inline-block", width: 10, height: 3, background: bpColors[i % bpColors.length], marginRight: 3, verticalAlign: "middle", borderRadius: 1 }} />
                          #{i + 1}
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Batch Diversity Matrix */}
              {suggestions && suggestions.suggestions.length >= 2 && (() => {
                const bdSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (bdSpecs.length === 0) return null;
                const bdSugs = suggestions.suggestions;
                const bdN = bdSugs.length;

                // Normalize each suggestion parameter to [0,1]
                const bdNormalized = bdSugs.map(sug => {
                  const norm: number[] = [];
                  for (const sp of bdSpecs) {
                    const lo = (sp as { lower: number }).lower;
                    const hi = (sp as { upper: number }).upper;
                    const range = hi - lo || 1;
                    norm.push(((Number(sug[(sp as { name: string }).name]) || 0) - lo) / range);
                  }
                  return norm;
                });

                // Compute pairwise Euclidean distance matrix
                const bdDistMatrix: number[][] = [];
                let bdMaxDist = 0;
                for (let i = 0; i < bdN; i++) {
                  bdDistMatrix[i] = [];
                  for (let j = 0; j < bdN; j++) {
                    if (i === j) { bdDistMatrix[i][j] = 0; continue; }
                    let dist = 0;
                    for (let k = 0; k < bdNormalized[i].length; k++) {
                      dist += (bdNormalized[i][k] - bdNormalized[j][k]) ** 2;
                    }
                    dist = Math.sqrt(dist);
                    bdDistMatrix[i][j] = dist;
                    if (dist > bdMaxDist) bdMaxDist = dist;
                  }
                }

                // Average pairwise distance
                let bdSumDist = 0, bdCount = 0;
                for (let i = 0; i < bdN; i++) {
                  for (let j = i + 1; j < bdN; j++) {
                    bdSumDist += bdDistMatrix[i][j];
                    bdCount++;
                  }
                }
                const bdAvgDist = bdCount > 0 ? bdSumDist / bdCount : 0;
                const bdMaxPossible = Math.sqrt(bdSpecs.length); // max dist in normalized space
                const bdDiversityPct = bdMaxPossible > 0 ? (bdAvgDist / bdMaxPossible) * 100 : 0;
                const bdLabel = bdDiversityPct > 60 ? "Diverse" : bdDiversityPct > 30 ? "Moderate" : "Clustered";
                const bdLabelColor = bdDiversityPct > 60 ? "#22c55e" : bdDiversityPct > 30 ? "#f59e0b" : "#ef4444";

                // SVG heatmap
                const bdCellSize = Math.min(32, Math.floor(200 / bdN));
                const bdPadL = 28, bdPadT = 28;
                const bdW = bdPadL + bdN * bdCellSize + 10;
                const bdH = bdPadT + bdN * bdCellSize + 10;

                const bdColor = (d: number) => {
                  const t = bdMaxDist > 0 ? d / bdMaxDist : 0;
                  // Interpolate from blue (close) to green (far)
                  const r = Math.round(34 * (1 - t) + 34 * t);
                  const g = Math.round(130 * (1 - t) + 197 * t);
                  const b2 = Math.round(246 * (1 - t) + 94 * t);
                  return `rgb(${r},${g},${b2})`;
                };

                return (
                  <div className="card" style={{ marginBottom: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <LayoutGrid size={16} style={{ color: "var(--color-primary)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Batch Diversity Matrix</h3>
                      <span className="findings-badge" style={{ background: bdLabelColor + "18", color: bdLabelColor, marginLeft: "auto" }}>
                        {bdLabel}
                      </span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: 8 }}>
                      Pairwise Euclidean distance (normalized) — avg {bdAvgDist.toFixed(3)}
                    </div>
                    <svg width={bdW} height={bdH} viewBox={`0 0 ${bdW} ${bdH}`} style={{ width: "100%", maxWidth: bdW, height: "auto" }}>
                      {/* Column headers */}
                      {bdSugs.map((_, i) => (
                        <text key={`bdch${i}`} x={bdPadL + i * bdCellSize + bdCellSize / 2} y={bdPadT - 6} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">#{i + 1}</text>
                      ))}
                      {/* Row headers */}
                      {bdSugs.map((_, i) => (
                        <text key={`bdrh${i}`} x={bdPadL - 4} y={bdPadT + i * bdCellSize + bdCellSize / 2 + 3} fontSize="7" fill="var(--color-text-muted)" textAnchor="end">#{i + 1}</text>
                      ))}
                      {/* Cells */}
                      {bdDistMatrix.map((row, i) =>
                        row.map((d, j) => (
                          <g key={`bdc${i}-${j}`}>
                            <rect
                              x={bdPadL + j * bdCellSize}
                              y={bdPadT + i * bdCellSize}
                              width={bdCellSize - 1}
                              height={bdCellSize - 1}
                              rx={2}
                              fill={i === j ? "var(--color-bg-secondary)" : bdColor(d)}
                              opacity={i === j ? 0.3 : 0.7 + 0.3 * (d / (bdMaxDist || 1))}
                            />
                            {bdCellSize >= 20 && (
                              <text
                                x={bdPadL + j * bdCellSize + (bdCellSize - 1) / 2}
                                y={bdPadT + i * bdCellSize + (bdCellSize - 1) / 2 + 3}
                                fontSize="6"
                                fill={i === j ? "var(--color-text-muted)" : "white"}
                                textAnchor="middle"
                                fontWeight="500"
                              >
                                {i === j ? "—" : d.toFixed(2)}
                              </text>
                            )}
                          </g>
                        ))
                      )}
                      {/* Color legend */}
                      <defs>
                        <linearGradient id="bdGrad" x1="0" y1="0" x2="1" y2="0">
                          <stop offset="0%" stopColor="rgb(34,130,246)" />
                          <stop offset="100%" stopColor="rgb(34,197,94)" />
                        </linearGradient>
                      </defs>
                      <rect x={bdPadL} y={bdPadT + bdN * bdCellSize + 2} width={bdN * bdCellSize - 1} height={4} rx={2} fill="url(#bdGrad)" opacity="0.6" />
                      <text x={bdPadL} y={bdPadT + bdN * bdCellSize + 12} fontSize="5" fill="var(--color-text-muted)">Close</text>
                      <text x={bdPadL + bdN * bdCellSize - 1} y={bdPadT + bdN * bdCellSize + 12} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">Far</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span>{bdSpecs.length}D space, {bdN} suggestions</span>
                      <span>diversity: {bdDiversityPct.toFixed(1)}%</span>
                    </div>
                  </div>
                );
              })()}

              {/* Novelty-Proximity Scatter */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const npSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (npSpecs.length === 0) return null;
                const npKpiKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!npKpiKey) return null;
                const npK = Math.min(5, trials.length - 1);

                // Normalize all trial parameters
                const npNormTrial = (params: Record<string, number>) => {
                  return npSpecs.map((sp: { name: string; type: string; lower?: number; upper?: number }) => {
                    const lo = sp.lower ?? 0;
                    const hi = sp.upper ?? 1;
                    const range = hi - lo || 1;
                    return ((Number(params[sp.name]) || 0) - lo) / range;
                  });
                };
                const npTrialNorms = trials.map(t => npNormTrial(t.parameters));

                // For each suggestion: compute min distance to any prior trial + local variance (uncertainty proxy)
                const npPoints = suggestions.suggestions.map((sug, si) => {
                  const sugNorm = npSpecs.map((sp: { name: string; type: string; lower?: number; upper?: number }) => {
                    const lo = sp.lower ?? 0;
                    const hi = sp.upper ?? 1;
                    const range = hi - lo || 1;
                    return ((Number(sug[sp.name]) || 0) - lo) / range;
                  });

                  // Min distance to prior
                  let minDist = Infinity;
                  const dists: { d: number; kpi: number }[] = [];
                  for (let j = 0; j < npTrialNorms.length; j++) {
                    let dist = 0;
                    for (let k = 0; k < sugNorm.length; k++) {
                      dist += (sugNorm[k] - npTrialNorms[j][k]) ** 2;
                    }
                    dist = Math.sqrt(dist);
                    if (dist < minDist) minDist = dist;
                    dists.push({ d: dist, kpi: trials[j].kpis[npKpiKey] ?? 0 });
                  }

                  // Local variance from k nearest neighbors
                  dists.sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, npK);
                  const nMean = neighbors.reduce((s, n) => s + n.kpi, 0) / neighbors.length;
                  const localVar = neighbors.reduce((s, n) => s + (n.kpi - nMean) ** 2, 0) / neighbors.length;

                  return { idx: si, minDist, localVar };
                });

                const npMaxDist = Math.max(...npPoints.map(p => p.minDist)) || 1;
                const npMaxVar = Math.max(...npPoints.map(p => p.localVar)) || 0.001;
                const npMedDist = npMaxDist / 2;
                const npMedVar = npMaxVar / 2;

                // Classify
                const npExploit = npPoints.filter(p => p.minDist < npMedDist && p.localVar < npMedVar).length;
                const npExplore = npPoints.filter(p => p.minDist >= npMedDist).length;

                // SVG
                const npW = 260, npH = 180, npPadL = 40, npPadR = 10, npPadT = 14, npPadB = 24;
                const npPlotW = npW - npPadL - npPadR;
                const npPlotH = npH - npPadT - npPadB;
                const npXScale = (d: number) => npPadL + (d / npMaxDist) * npPlotW;
                const npYScale = (v: number) => npPadT + npPlotH - (v / npMaxVar) * npPlotH;

                const npColors = ["#3b82f6", "#22c55e", "#f59e0b", "#ef4444", "#a855f7", "#06b6d4", "#f97316", "#ec4899"];

                return (
                  <div className="card" style={{ marginBottom: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Focus size={16} style={{ color: "var(--color-primary)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Novelty vs. Proximity</h3>
                      <span className="findings-badge" style={{ marginLeft: "auto" }}>
                        {npExploit} exploit / {npExplore} explore
                      </span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: 8 }}>
                      Distance to nearest prior vs local uncertainty
                    </div>
                    <svg width={npW} height={npH} viewBox={`0 0 ${npW} ${npH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Quadrant backgrounds */}
                      <rect x={npPadL} y={npPadT} width={npPlotW / 2} height={npPlotH / 2} fill="rgba(34,197,94,0.04)" />
                      <rect x={npPadL + npPlotW / 2} y={npPadT} width={npPlotW / 2} height={npPlotH / 2} fill="rgba(239,68,68,0.04)" />
                      <rect x={npPadL} y={npPadT + npPlotH / 2} width={npPlotW / 2} height={npPlotH / 2} fill="rgba(59,130,246,0.04)" />
                      <rect x={npPadL + npPlotW / 2} y={npPadT + npPlotH / 2} width={npPlotW / 2} height={npPlotH / 2} fill="rgba(168,85,247,0.04)" />
                      {/* Quadrant labels */}
                      <text x={npPadL + npPlotW * 0.25} y={npPadT + 10} fontSize="6" fill="rgba(34,197,94,0.6)" textAnchor="middle" fontWeight="500">Local Risk</text>
                      <text x={npPadL + npPlotW * 0.75} y={npPadT + 10} fontSize="6" fill="rgba(239,68,68,0.6)" textAnchor="middle" fontWeight="500">Wild Card</text>
                      <text x={npPadL + npPlotW * 0.25} y={npPadT + npPlotH - 4} fontSize="6" fill="rgba(59,130,246,0.6)" textAnchor="middle" fontWeight="500">Exploitation</text>
                      <text x={npPadL + npPlotW * 0.75} y={npPadT + npPlotH - 4} fontSize="6" fill="rgba(168,85,247,0.6)" textAnchor="middle" fontWeight="500">Safe Explore</text>
                      {/* Grid dividers */}
                      <line x1={npPadL + npPlotW / 2} y1={npPadT} x2={npPadL + npPlotW / 2} y2={npPadT + npPlotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="4,4" />
                      <line x1={npPadL} y1={npPadT + npPlotH / 2} x2={npPadL + npPlotW} y2={npPadT + npPlotH / 2} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="4,4" />
                      {/* Y axis labels */}
                      <text x={npPadL - 4} y={npPadT + 4} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">High</text>
                      <text x={npPadL - 4} y={npPadT + npPlotH + 3} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">Low</text>
                      {/* X axis labels */}
                      <text x={npPadL} y={npH - 4} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="start">Near</text>
                      <text x={npPadL + npPlotW} y={npH - 4} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">Far</text>
                      <text x={npPadL + npPlotW / 2} y={npH - 4} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">Distance to Nearest Prior</text>
                      <text x={6} y={npPadT + npPlotH / 2} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 6, ${npPadT + npPlotH / 2})`}>Local Variance</text>
                      {/* Suggestion points */}
                      {npPoints.map((p, i) => (
                        <g key={`np${i}`}>
                          <circle
                            cx={npXScale(p.minDist)}
                            cy={npYScale(p.localVar)}
                            r="5"
                            fill={npColors[i % npColors.length]}
                            opacity="0.7"
                            stroke="white"
                            strokeWidth="1"
                          />
                          <text
                            x={npXScale(p.minDist)}
                            y={npYScale(p.localVar) + 2.5}
                            fontSize="5"
                            fill="white"
                            textAnchor="middle"
                            fontWeight="700"
                          >
                            {i + 1}
                          </text>
                        </g>
                      ))}
                    </svg>
                  </div>
                );
              })()}

              {/* Improvement vs Novelty Profile */}
              {suggestions && suggestions.suggestions.length >= 2 && trials.length >= 3 && (() => {
                const inSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (inSpecs.length === 0) return null;
                const inObjKey = Object.keys(trials[0].kpis)[0];
                if (!inObjKey) return null;
                const inKpiVals = trials.map(t => Number(t.kpis[inObjKey]) || 0);
                const inBest = Math.min(...inKpiVals);
                const inWorst = Math.max(...inKpiVals);
                const inRange = inWorst - inBest || 1;
                // Normalize function
                const inNorm = (params: Record<string, number>) => inSpecs.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1;
                  return hi > lo ? (Number(params[sp.name]) - lo) / (hi - lo) : 0.5;
                });
                const inTrialNorms = trials.map(t => inNorm(t.parameters));
                const inSugs = suggestions.suggestions.map((sug, idx) => {
                  const sugNorm = inNorm(sug);
                  // Novelty: min distance to any prior trial
                  const dists = inTrialNorms.map(tn => Math.sqrt(sugNorm.reduce((s, v, j) => s + (v - tn[j]) ** 2, 0)));
                  const minDist = Math.min(...dists);
                  // Predicted improvement: k-NN average of closest trials' KPI
                  const k = Math.min(3, trials.length);
                  const sorted = dists.map((d, i) => ({ d, kpi: inKpiVals[i] })).sort((a, b) => a.d - b.d);
                  const predKpi = sorted.slice(0, k).reduce((s, n) => s + n.kpi, 0) / k;
                  // Improvement = how much better than worst (lower is better assumption)
                  const improvement = (inWorst - predKpi) / inRange;
                  return { idx, novelty: minDist, improvement, predKpi };
                });
                const inMaxNovelty = Math.max(...inSugs.map(s => s.novelty), 0.01);
                const inMaxImprove = Math.max(...inSugs.map(s => s.improvement), 0.01);
                // Chart dimensions
                const inW = 280, inH = 150, inPadL = 38, inPadR = 12, inPadT = 14, inPadB = 24;
                const inPlotW = inW - inPadL - inPadR;
                const inPlotH = inH - inPadT - inPadB;
                // Classify
                const inExploiters = inSugs.filter(s => s.novelty / inMaxNovelty < 0.5 && s.improvement / inMaxImprove > 0.5).length;
                const inExplorers = inSugs.filter(s => s.novelty / inMaxNovelty >= 0.5).length;
                const inLabel = inExploiters > inExplorers ? "Exploitation-Heavy" : inExplorers > inExploiters ? "Exploration-Heavy" : "Balanced";
                const inColor = inLabel === "Balanced" ? "#22c55e" : "var(--color-primary)";
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <ScatterChart size={15} style={{ color: "var(--color-primary)" }} />
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Improvement vs. Novelty</h3>
                      </div>
                      <span className="findings-badge" style={{ background: inColor, color: "#fff" }}>{inLabel}</span>
                    </div>
                    <svg width={inW} height={inH} viewBox={`0 0 ${inW} ${inH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Quadrant backgrounds */}
                      <rect x={inPadL} y={inPadT} width={inPlotW / 2} height={inPlotH / 2} fill="rgba(34,197,94,0.06)" />
                      <rect x={inPadL + inPlotW / 2} y={inPadT} width={inPlotW / 2} height={inPlotH / 2} fill="rgba(59,130,246,0.06)" />
                      <rect x={inPadL} y={inPadT + inPlotH / 2} width={inPlotW / 2} height={inPlotH / 2} fill="rgba(156,163,175,0.04)" />
                      <rect x={inPadL + inPlotW / 2} y={inPadT + inPlotH / 2} width={inPlotW / 2} height={inPlotH / 2} fill="rgba(234,179,8,0.06)" />
                      {/* Quadrant labels */}
                      <text x={inPadL + inPlotW * 0.25} y={inPadT + 10} fontSize="5.5" fill="rgba(34,197,94,0.5)" textAnchor="middle" fontWeight="500">High Value</text>
                      <text x={inPadL + inPlotW * 0.75} y={inPadT + 10} fontSize="5.5" fill="rgba(59,130,246,0.5)" textAnchor="middle" fontWeight="500">Frontier</text>
                      <text x={inPadL + inPlotW * 0.25} y={inPadT + inPlotH - 4} fontSize="5.5" fill="rgba(156,163,175,0.4)" textAnchor="middle">Low Value</text>
                      <text x={inPadL + inPlotW * 0.75} y={inPadT + inPlotH - 4} fontSize="5.5" fill="rgba(234,179,8,0.5)" textAnchor="middle">Risky Explore</text>
                      {/* Axes */}
                      <line x1={inPadL} y1={inPadT + inPlotH} x2={inPadL + inPlotW} y2={inPadT + inPlotH} stroke="var(--color-border)" strokeWidth="0.5" />
                      <line x1={inPadL} y1={inPadT} x2={inPadL} y2={inPadT + inPlotH} stroke="var(--color-border)" strokeWidth="0.5" />
                      {/* Midlines */}
                      <line x1={inPadL + inPlotW / 2} y1={inPadT} x2={inPadL + inPlotW / 2} y2={inPadT + inPlotH} stroke="var(--color-border)" strokeWidth="0.3" strokeDasharray="2,2" />
                      <line x1={inPadL} y1={inPadT + inPlotH / 2} x2={inPadL + inPlotW} y2={inPadT + inPlotH / 2} stroke="var(--color-border)" strokeWidth="0.3" strokeDasharray="2,2" />
                      {/* Axis labels */}
                      <text x={inPadL + inPlotW / 2} y={inH - 2} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle">Novelty (min distance)</text>
                      <text x={6} y={inPadT + inPlotH / 2} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 6, ${inPadT + inPlotH / 2})`}>Predicted Improvement</text>
                      {/* Points */}
                      {inSugs.map((s, i) => {
                        const px = inPadL + (s.novelty / inMaxNovelty) * inPlotW * 0.9 + inPlotW * 0.05;
                        const py = inPadT + inPlotH - (s.improvement / inMaxImprove) * inPlotH * 0.9 - inPlotH * 0.05;
                        const hue = (s.improvement / inMaxImprove) * 120;
                        return (
                          <g key={i}>
                            <circle cx={px} cy={py} r="6" fill={`hsl(${hue}, 70%, 50%)`} opacity={0.8} stroke="white" strokeWidth="0.8" />
                            <text x={px} y={py + 2} fontSize="5" fill="white" textAnchor="middle" fontWeight="700">{i + 1}</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>{inExploiters} high-value</span>
                      <span>{inExplorers} exploratory</span>
                      <span style={{ marginLeft: "auto" }}>k=3 NN prediction</span>
                    </div>
                  </div>
                );
              })()}

              {/* Suggestion Coverage Gap */}
              {suggestions && suggestions.suggestions.length >= 2 && trials.length >= 5 && (() => {
                const cgSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (cgSpecs.length === 0) return null;
                const cgMaxP = Math.min(cgSpecs.length, 6);
                const cgParams = cgSpecs.slice(0, cgMaxP);
                const cgBins = 8;
                const cgData = cgParams.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1; const range = hi - lo || 1;
                  // Trial histogram
                  const trialHist = new Array(cgBins).fill(0);
                  trials.forEach(t => {
                    const v = (Number(t.parameters[sp.name]) - lo) / range;
                    const bin = Math.min(cgBins - 1, Math.max(0, Math.floor(v * cgBins)));
                    trialHist[bin]++;
                  });
                  const maxHist = Math.max(...trialHist, 1);
                  // Suggestion positions
                  const sugBins = suggestions.suggestions.map(sug => {
                    const v = (Number(sug[sp.name]) - lo) / range;
                    return Math.min(cgBins - 1, Math.max(0, Math.floor(v * cgBins)));
                  });
                  // Gap = bins with 0 trials AND 0 suggestions
                  const gaps = trialHist.map((h, i) => h === 0 && !sugBins.includes(i));
                  const gapCount = gaps.filter(Boolean).length;
                  return { name: sp.name, trialHist, maxHist, sugBins, gaps, gapCount };
                });
                const cgTotalGaps = cgData.reduce((s, d) => s + d.gapCount, 0);
                const cgTotalBins = cgData.length * cgBins;
                const cgCoverage = ((cgTotalBins - cgTotalGaps) / cgTotalBins * 100);
                const cgLabel = cgCoverage >= 90 ? "Well Covered" : cgCoverage >= 70 ? "Partial Gaps" : "Significant Gaps";
                const cgColor = cgCoverage >= 90 ? "#22c55e" : cgCoverage >= 70 ? "#eab308" : "#ef4444";
                // Small multiples
                const cgCols = Math.min(3, cgData.length);
                const cgCellW = 100, cgCellH = 50;
                const cgSvgW = cgCols * cgCellW;
                const cgRows = Math.ceil(cgData.length / cgCols);
                const cgSvgH = cgRows * cgCellH;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <ScanLine size={15} style={{ color: "var(--color-primary)" }} />
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Coverage Gap Analysis</h3>
                      </div>
                      <span className="findings-badge" style={{ background: cgColor, color: "#fff" }}>{cgLabel} ({cgCoverage.toFixed(0)}%)</span>
                    </div>
                    <svg width={cgSvgW} height={cgSvgH} viewBox={`0 0 ${cgSvgW} ${cgSvgH}`} style={{ width: "100%", height: "auto" }}>
                      {cgData.map((param, pi) => {
                        const col = pi % cgCols;
                        const row = Math.floor(pi / cgCols);
                        const ox = col * cgCellW + 4;
                        const oy = row * cgCellH;
                        const barArea = cgCellW - 8;
                        const barW = barArea / cgBins * 0.8;
                        const barGap = barArea / cgBins;
                        const maxBarH = cgCellH - 20;
                        return (
                          <g key={pi}>
                            <text x={ox + barArea / 2} y={oy + 8} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle" fontWeight="500">{param.name}</text>
                            {param.trialHist.map((h, bi) => {
                              const bx = ox + bi * barGap + barGap / 2;
                              const barH = (h / param.maxHist) * maxBarH;
                              const isGap = param.gaps[bi];
                              const hasSug = param.sugBins.includes(bi);
                              return (
                                <g key={bi}>
                                  {isGap && <rect x={bx - barW / 2 - 1} y={oy + cgCellH - maxBarH - 2} width={barW + 2} height={maxBarH + 2} rx={1} fill="#ef4444" opacity={0.08} />}
                                  <rect x={bx - barW / 2} y={oy + cgCellH - 4 - barH} width={barW} height={Math.max(barH, 0.5)} rx={1} fill={isGap ? "var(--color-border)" : "var(--color-primary)"} opacity={isGap ? 0.3 : 0.5} />
                                  {hasSug && <circle cx={bx} cy={oy + cgCellH - 4 - barH - 4} r="2" fill="#22c55e" stroke="white" strokeWidth="0.5" />}
                                </g>
                              );
                            })}
                            <line x1={ox} y1={oy + cgCellH - 4} x2={ox + barArea} y2={oy + cgCellH - 4} stroke="var(--color-border)" strokeWidth="0.3" />
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "var(--color-primary)", opacity: 0.5, marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Trial density</span>
                      <span><span style={{ display: "inline-block", width: 6, height: 6, background: "#22c55e", marginRight: 3, verticalAlign: "middle", borderRadius: "50%" }} />Suggestion</span>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "#ef4444", opacity: 0.1, marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Gap</span>
                      <span style={{ marginLeft: "auto" }}>{cgTotalGaps} gaps across {cgData.length} params</span>
                    </div>
                  </div>
                );
              })()}

              {/* Prediction Confidence Intervals */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const pcSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (pcSpecs.length === 0) return null;
                const pcKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!pcKey) return null;
                const pcK = Math.min(7, trials.length - 1);
                const pcSugs = suggestions.suggestions;

                // Normalize trials
                const pcTrialNorms = trials.map(t => {
                  const vals: number[] = [];
                  pcSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                    vals.push(((Number(t.parameters[s.name]) || 0) - (s.lower ?? 0)) / range);
                  });
                  return vals;
                });
                const pcKpis = trials.map(t => Number(t.kpis[pcKey]) || 0);

                // For each suggestion: k-NN prediction + std
                const pcData = pcSugs.map((sug: Record<string, number>, idx: number) => {
                  const sugNorm: number[] = [];
                  pcSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                    sugNorm.push(((Number(sug[s.name]) || 0) - (s.lower ?? 0)) / range);
                  });
                  const dists = pcTrialNorms.map((v, j) => ({
                    d: Math.sqrt(v.reduce((s, x, k) => s + (x - sugNorm[k]) ** 2, 0)),
                    j,
                  })).sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, pcK);
                  const predicted = neighbors.reduce((s, n) => s + pcKpis[n.j], 0) / pcK;
                  const std = Math.sqrt(neighbors.reduce((s, n) => s + (pcKpis[n.j] - predicted) ** 2, 0) / pcK);
                  return { idx: idx + 1, predicted, std, minDist: dists[0].d };
                }).sort((a, b) => a.predicted - b.predicted);

                const pcAllVals = pcData.flatMap(d => [d.predicted - d.std, d.predicted + d.std]);
                const pcMinVal = Math.min(...pcAllVals);
                const pcMaxVal = Math.max(...pcAllVals);
                const pcRange = pcMaxVal - pcMinVal || 1;
                const pcBest = Math.min(...pcKpis);

                // SVG dimensions
                const pcLabelW = 32, pcBarW = 220, pcValW = 60, pcH = pcData.length * 28 + 30;
                const pcTotalW = pcLabelW + pcBarW + pcValW;

                const pcAvgStd = pcData.reduce((s, d) => s + d.std, 0) / pcData.length;
                const pcKpiStd = Math.sqrt(pcKpis.reduce((s, v) => s + (v - pcKpis.reduce((a, b) => a + b, 0) / pcKpis.length) ** 2, 0) / pcKpis.length) || 1;
                const pcConfidence = pcAvgStd < pcKpiStd * 0.3 ? "High" : pcAvgStd < pcKpiStd * 0.6 ? "Moderate" : "Low";
                const pcConfColor = pcConfidence === "High" ? "var(--color-green, #22c55e)" : pcConfidence === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <CandlestickChart size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Prediction Confidence</h3>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: pcConfColor + "18", color: pcConfColor }}>{pcConfidence} Confidence</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      k-NN predicted {pcKey} ± std for each suggestion. Narrower bars = more certain.
                    </p>
                    <svg width={pcTotalW} height={pcH} viewBox={`0 0 ${pcTotalW} ${pcH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Best-so-far line */}
                      {(() => {
                        const bestX = pcLabelW + ((pcBest - pcMinVal) / pcRange) * pcBarW;
                        return (
                          <g>
                            <line x1={bestX} y1={4} x2={bestX} y2={pcH - 18} stroke="var(--color-green, #22c55e)" strokeWidth={1} strokeDasharray="3,3" opacity={0.6} />
                            <text x={bestX} y={pcH - 8} textAnchor="middle" fill="var(--color-green, #22c55e)" fontSize={7} fontFamily="var(--font-mono)">best</text>
                          </g>
                        );
                      })()}
                      {pcData.map((d, i) => {
                        const y = 8 + i * 28;
                        const centerX = pcLabelW + ((d.predicted - pcMinVal) / pcRange) * pcBarW;
                        const halfW = (d.std / pcRange) * pcBarW;
                        const leftX = Math.max(pcLabelW, centerX - halfW);
                        const rightX = Math.min(pcLabelW + pcBarW, centerX + halfW);
                        const hue = d.std < pcKpiStd * 0.3 ? "#22c55e" : d.std < pcKpiStd * 0.6 ? "#eab308" : "#ef4444";
                        return (
                          <g key={i}>
                            {/* Label */}
                            <text x={pcLabelW - 6} y={y + 12} textAnchor="end" fill="var(--color-text)" fontSize={10} fontFamily="var(--font-mono)" fontWeight={600}>#{d.idx}</text>
                            {/* Error bar (whiskers) */}
                            <line x1={leftX} y1={y + 10} x2={rightX} y2={y + 10} stroke={hue} strokeWidth={3} strokeLinecap="round" opacity={0.5} />
                            <line x1={leftX} y1={y + 6} x2={leftX} y2={y + 14} stroke={hue} strokeWidth={1.5} strokeLinecap="round" opacity={0.7} />
                            <line x1={rightX} y1={y + 6} x2={rightX} y2={y + 14} stroke={hue} strokeWidth={1.5} strokeLinecap="round" opacity={0.7} />
                            {/* Center dot */}
                            <circle cx={centerX} cy={y + 10} r={4} fill={hue} />
                            {/* Value text */}
                            <text x={pcLabelW + pcBarW + 6} y={y + 12} fill="var(--color-text)" fontSize={8} fontFamily="var(--font-mono)">{d.predicted.toPrecision(3)} ±{d.std.toPrecision(2)}</text>
                          </g>
                        );
                      })}
                      {/* Axis */}
                      <line x1={pcLabelW} y1={pcH - 20} x2={pcLabelW + pcBarW} y2={pcH - 20} stroke="var(--color-border)" strokeWidth={0.5} />
                      <text x={pcLabelW} y={pcH - 11} fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{pcMinVal.toPrecision(3)}</text>
                      <text x={pcLabelW + pcBarW} y={pcH - 11} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{pcMaxVal.toPrecision(3)}</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>k={pcK} NN prediction</span>
                      <span>avg ±{pcAvgStd.toPrecision(2)}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Suggestion Rank Stability */}
              {suggestions && suggestions.suggestions.length >= 3 && trials.length >= 5 && (() => {
                const rsSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rsSpecs.length === 0) return null;
                const rsKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!rsKey) return null;
                const rsSugs = suggestions.suggestions;
                const rsK = Math.min(5, trials.length - 1);

                // Normalize trials
                const rsTrialNorms = trials.map(t => {
                  const vals: number[] = [];
                  rsSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                    vals.push(((Number(t.parameters[s.name]) || 0) - (s.lower ?? 0)) / range);
                  });
                  return vals;
                });
                const rsKpis = trials.map(t => Number(t.kpis[rsKey]) || 0);

                // Score each suggestion on 3 criteria
                const rsScored = rsSugs.map((sug: Record<string, number>, idx: number) => {
                  const sugNorm: number[] = [];
                  rsSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                    sugNorm.push(((Number(sug[s.name]) || 0) - (s.lower ?? 0)) / range);
                  });
                  const dists = rsTrialNorms.map((v, j) => ({
                    d: Math.sqrt(v.reduce((s, x, k) => s + (x - sugNorm[k]) ** 2, 0)), j
                  })).sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, rsK);
                  const predicted = neighbors.reduce((s, n) => s + rsKpis[n.j], 0) / rsK;
                  const novelty = dists[0].d; // min distance = novelty
                  const confidence = 1 / (1 + Math.sqrt(neighbors.reduce((s, n) => s + (rsKpis[n.j] - predicted) ** 2, 0) / rsK));
                  return { idx: idx + 1, predicted, novelty, confidence };
                });

                // Rank by each criterion (lower predicted = better for min)
                const rsRankBy = (key: string, ascending: boolean) => {
                  const sorted = [...rsScored].sort((a, b) => ascending ? (a as Record<string, number>)[key] - (b as Record<string, number>)[key] : (b as Record<string, number>)[key] - (a as Record<string, number>)[key]);
                  const rankMap: Record<number, number> = {};
                  sorted.forEach((s, i) => { rankMap[s.idx] = i + 1; });
                  return rankMap;
                };
                const rsRanks = [
                  { label: "Predicted", ranks: rsRankBy("predicted", true) },
                  { label: "Novelty", ranks: rsRankBy("novelty", false) },
                  { label: "Confidence", ranks: rsRankBy("confidence", false) },
                ];

                // Compute rank consistency: sum of rank differences across criteria
                let rsTotalDiff = 0;
                const rsMaxDiff = rsScored.length * rsRanks.length * (rsScored.length - 1);
                rsScored.forEach(s => {
                  const ranks = rsRanks.map(r => r.ranks[s.idx] || 0);
                  for (let i = 0; i < ranks.length; i++) for (let j = i + 1; j < ranks.length; j++) rsTotalDiff += Math.abs(ranks[i] - ranks[j]);
                });
                const rsConsistency = 1 - rsTotalDiff / (rsMaxDiff || 1);
                const rsStatus = rsConsistency > 0.7 ? "Consistent" : rsConsistency > 0.4 ? "Mixed" : "Unstable";
                const rsStatusColor = rsStatus === "Consistent" ? "var(--color-green, #22c55e)" : rsStatus === "Mixed" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                // Bump chart
                const rsCount = rsScored.length;
                const rsCols = rsRanks.length;
                const rsColW = 80, rsRowH = 24;
                const rsPadL = 30, rsPadT = 20;
                const rsW = rsPadL + rsCols * rsColW;
                const rsH = rsPadT + rsCount * rsRowH + 10;
                const rsColors = ["#3b82f6", "#ef4444", "#22c55e", "#f59e0b", "#8b5cf6"];

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <ListOrdered size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Rank Stability</h3>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: rsStatusColor + "18", color: rsStatusColor }}>{rsStatus} ({(rsConsistency * 100).toFixed(0)}%)</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      How suggestion rankings change across different evaluation criteria.
                    </p>
                    <svg width={rsW} height={rsH} viewBox={`0 0 ${rsW} ${rsH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Column headers */}
                      {rsRanks.map((r, ci) => (
                        <text key={ci} x={rsPadL + ci * rsColW + rsColW / 2} y={12} textAnchor="middle" fill="var(--color-text-muted)" fontSize={8} fontWeight={600} fontFamily="var(--font-mono)">{r.label}</text>
                      ))}
                      {/* Lines connecting ranks */}
                      {rsScored.map((s, si) => {
                        const color = rsColors[si % rsColors.length];
                        const points = rsRanks.map((r, ci) => ({
                          x: rsPadL + ci * rsColW + rsColW / 2,
                          y: rsPadT + ((r.ranks[s.idx] || 1) - 1) * rsRowH + rsRowH / 2,
                        }));
                        return (
                          <g key={si}>
                            {points.slice(0, -1).map((p, i) => (
                              <line key={i} x1={p.x} y1={p.y} x2={points[i + 1].x} y2={points[i + 1].y} stroke={color} strokeWidth={2} opacity={0.5} strokeLinecap="round" />
                            ))}
                            {points.map((p, i) => (
                              <g key={`dot-${i}`}>
                                <circle cx={p.x} cy={p.y} r={8} fill={color} opacity={0.85} />
                                <text x={p.x} y={p.y + 3} textAnchor="middle" fill="#fff" fontSize={8} fontWeight={700} fontFamily="var(--font-mono)">#{s.idx}</text>
                              </g>
                            ))}
                          </g>
                        );
                      })}
                      {/* Rank labels on left */}
                      {Array.from({ length: rsCount }, (_, i) => (
                        <text key={i} x={rsPadL - 6} y={rsPadT + i * rsRowH + rsRowH / 2 + 3} textAnchor="end" fill="var(--color-text-muted)" fontSize={8} fontFamily="var(--font-mono)">{i + 1}</text>
                      ))}
                    </svg>
                  </div>
                );
              })()}

              {/* Batch Information Overlap */}
              {suggestions && suggestions.suggestions.length >= 2 && (() => {
                const biSugs = suggestions.suggestions;
                const biParams = (campaign.spec?.parameters || []).filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (biParams.length < 1) return null;
                const biN = biSugs.length;

                // Normalize suggestions
                const biNorm = biSugs.map((sug: Record<string, number>) =>
                  biParams.map((p: { name: string; lower?: number; upper?: number }) => {
                    const lo = p.lower!, hi = p.upper!;
                    return (hi - lo) > 0 ? ((sug[p.name] ?? lo) - lo) / (hi - lo) : 0.5;
                  })
                );

                // Pairwise similarity (1 - normalized Euclidean distance)
                const biMaxDist = Math.sqrt(biParams.length); // max possible dist in unit hypercube
                const biMatrix: number[][] = [];
                for (let i = 0; i < biN; i++) {
                  biMatrix[i] = [];
                  for (let j = 0; j < biN; j++) {
                    if (i === j) { biMatrix[i][j] = 1; continue; }
                    const dist = Math.sqrt(biNorm[i].reduce((s: number, v: number, k: number) => s + (v - biNorm[j][k]) ** 2, 0));
                    biMatrix[i][j] = 1 - dist / biMaxDist;
                  }
                }

                // Average off-diagonal similarity
                let biSumSim = 0, biCount = 0;
                for (let i = 0; i < biN; i++) for (let j = i + 1; j < biN; j++) { biSumSim += biMatrix[i][j]; biCount++; }
                const biAvgSim = biCount > 0 ? biSumSim / biCount : 0;
                const biIndependence = 1 - biAvgSim;

                const biStatus = biIndependence > 0.75 ? "Independent" : biIndependence > 0.5 ? "Mild Overlap" : "Redundant";
                const biColor = biStatus === "Independent" ? "var(--color-green, #22c55e)" : biStatus === "Mild Overlap" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const biCellSize = Math.min(40, 200 / biN);
                const biPadL = 36, biPadT = 24;
                const biW = biPadL + biN * biCellSize + 8;
                const biH = biPadT + biN * biCellSize + 8;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <Fingerprint size={15} style={{ color: biColor }} />
                      <h2 style={{ margin: 0 }}>Batch Overlap</h2>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: 8, background: biColor + "18", color: biColor }}>{biStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Pairwise similarity between suggestions. Lower = more diverse batch.
                    </p>
                    <svg width={biW} height={biH} viewBox={`0 0 ${biW} ${biH}`} style={{ width: "100%", height: "auto", maxHeight: 240 }}>
                      {/* Column headers */}
                      {Array.from({ length: biN }, (_, j) => (
                        <text key={`ch${j}`} x={biPadL + j * biCellSize + biCellSize / 2} y={biPadT - 6} textAnchor="middle" fontSize={9} fill="var(--color-text-muted)" fontWeight={600}>#{j + 1}</text>
                      ))}
                      {/* Row headers */}
                      {Array.from({ length: biN }, (_, i) => (
                        <text key={`rh${i}`} x={biPadL - 6} y={biPadT + i * biCellSize + biCellSize / 2 + 3} textAnchor="end" fontSize={9} fill="var(--color-text-muted)" fontWeight={600}>#{i + 1}</text>
                      ))}
                      {/* Lower triangle + diagonal */}
                      {Array.from({ length: biN }, (_, i) =>
                        Array.from({ length: biN }, (__, j) => {
                          if (j > i) return null; // upper triangle empty
                          const sim = biMatrix[i][j];
                          const isDiag = i === j;
                          const r = isDiag ? 200 : Math.round(60 + 195 * sim);
                          const g = isDiag ? 200 : Math.round(180 * (1 - sim) + 60);
                          const b = isDiag ? 210 : Math.round(60);
                          return (
                            <g key={`${i}-${j}`}>
                              <rect x={biPadL + j * biCellSize + 1} y={biPadT + i * biCellSize + 1} width={biCellSize - 2} height={biCellSize - 2} rx={3} fill={isDiag ? "var(--color-border)" : `rgb(${r},${g},${b})`} opacity={isDiag ? 0.4 : 0.85}>
                                <title>{isDiag ? `Suggestion #${i + 1}` : `#${i + 1} vs #${j + 1}: ${(sim * 100).toFixed(0)}% similar`}</title>
                              </rect>
                              {!isDiag && biCellSize >= 28 && (
                                <text x={biPadL + j * biCellSize + biCellSize / 2} y={biPadT + i * biCellSize + biCellSize / 2 + 3} textAnchor="middle" fontSize={8} fill="white" fontWeight={600}>{(sim * 100).toFixed(0)}%</text>
                              )}
                              {isDiag && (
                                <text x={biPadL + j * biCellSize + biCellSize / 2} y={biPadT + i * biCellSize + biCellSize / 2 + 3} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">—</text>
                              )}
                            </g>
                          );
                        })
                      )}
                    </svg>
                    <div style={{ display: "flex", gap: 12, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(60,240,60)" }} /> diverse</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 4 }}><span style={{ width: 10, height: 10, borderRadius: 2, background: "rgb(255,120,60)" }} /> similar</span>
                      <span style={{ marginLeft: "auto" }}>independence: {(biIndependence * 100).toFixed(0)}%</span>
                    </div>
                  </div>
                );
              })()}

              {/* Prediction Track Record — Batch 21 */}
              {suggestions && trials.length >= 5 && (() => {
                // Compare past suggestions' predicted values with actual outcomes
                const ptSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (ptSpecs.length === 0) return null;
                const ptSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // For each trial, compute how close it is to the "centroid" of previous suggestions
                // and track the actual KPI improvement
                const ptRecords: { iteration: number; predicted_rank: number; actual_rank: number; kpi: number }[] = [];
                const ptKpis = ptSorted.map(t => Object.values(t.kpis)[0] ?? 0);
                const ptBestSoFar: number[] = [];
                let ptRunningBest = -Infinity;
                ptKpis.forEach(k => {
                  ptRunningBest = Math.max(ptRunningBest, k);
                  ptBestSoFar.push(ptRunningBest);
                });
                // Build rank-based accuracy: for each window of 5 trials, rank by predicted vs actual KPI
                const ptWindowSize = Math.min(5, ptSorted.length);
                for (let i = ptWindowSize; i <= ptSorted.length - ptWindowSize; i += ptWindowSize) {
                  const ptWindow = ptSorted.slice(i, i + ptWindowSize);
                  const ptPrevWindow = ptSorted.slice(i - ptWindowSize, i);
                  // "Predicted" rank: based on distance from previous best trial's params
                  const ptBestPrev = ptPrevWindow.reduce((best, t) => (Object.values(t.kpis)[0] ?? 0) > (Object.values(best.kpis)[0] ?? 0) ? t : best, ptPrevWindow[0]);
                  const ptDistances = ptWindow.map(t => {
                    let d = 0;
                    ptSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                      const range = (s.upper ?? 1) - (s.lower ?? 0);
                      const diff = ((t.parameters[s.name] ?? 0) - (ptBestPrev.parameters[s.name] ?? 0)) / (range || 1);
                      d += diff * diff;
                    });
                    return Math.sqrt(d);
                  });
                  const ptPredRanks = ptDistances.map((d, idx) => ({ d, idx })).sort((a, b) => a.d - b.d).map((item, rank) => ({ idx: item.idx, rank: rank + 1 }));
                  const ptActualKpis = ptWindow.map(t => Object.values(t.kpis)[0] ?? 0);
                  const ptActualRanks = ptActualKpis.map((k, idx) => ({ k, idx })).sort((a, b) => b.k - a.k).map((item, rank) => ({ idx: item.idx, rank: rank + 1 }));
                  ptPredRanks.forEach(pr => {
                    const ar = ptActualRanks.find(a => a.idx === pr.idx);
                    ptRecords.push({ iteration: ptWindow[pr.idx].iteration, predicted_rank: pr.rank, actual_rank: ar?.rank ?? pr.rank, kpi: ptActualKpis[pr.idx] });
                  });
                }
                if (ptRecords.length < 3) return null;
                // Rank correlation (Spearman) across all records
                const ptN2 = ptRecords.length;
                const ptDiffSq = ptRecords.reduce((s, r) => s + (r.predicted_rank - r.actual_rank) ** 2, 0);
                const ptSpearman = 1 - (6 * ptDiffSq) / (ptN2 * (ptN2 * ptN2 - 1));
                const ptAccurate = ptRecords.filter(r => Math.abs(r.predicted_rank - r.actual_rank) <= 1).length;
                const ptAccuracy = ptAccurate / ptRecords.length;
                const ptBadge = ptAccuracy > 0.6 ? "Accurate" : ptAccuracy > 0.35 ? "Mixed" : "Unreliable";
                const ptBadgeColor = ptAccuracy > 0.6 ? "var(--color-green, #22c55e)" : ptAccuracy > 0.35 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Scatter plot: predicted rank vs actual rank
                const ptW = 180, ptH = 140, ptPad = 24;
                const ptMaxRank = Math.max(...ptRecords.map(r => Math.max(r.predicted_rank, r.actual_rank)));
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <LineChart size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Prediction Track Record</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: ptBadgeColor + "18", color: ptBadgeColor }}>{ptBadge} ({(ptAccuracy * 100).toFixed(0)}%)</span>
                    </div>
                    <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
                      <svg width={ptW} height={ptH} style={{ flexShrink: 0 }}>
                        {/* Perfect prediction line */}
                        <line x1={ptPad} y1={ptH - ptPad} x2={ptW - 8} y2={ptPad - 4} stroke="var(--color-border)" strokeWidth={1} strokeDasharray="3,3" />
                        {/* Points */}
                        {ptRecords.map((r, i) => {
                          const x = ptPad + ((r.predicted_rank - 1) / Math.max(1, ptMaxRank - 1)) * (ptW - ptPad - 8);
                          const y = (ptH - ptPad) - ((r.actual_rank - 1) / Math.max(1, ptMaxRank - 1)) * (ptH - ptPad - 4);
                          const accurate = Math.abs(r.predicted_rank - r.actual_rank) <= 1;
                          return (
                            <circle key={`pt-${i}`} cx={x} cy={y} r={3.5} fill={accurate ? "var(--color-green, #22c55e)" : "var(--color-red, #ef4444)"} opacity={0.7}>
                              <title>Pred rank: {r.predicted_rank}, Actual rank: {r.actual_rank}, KPI: {r.kpi.toFixed(4)}</title>
                            </circle>
                          );
                        })}
                        {/* Axis labels */}
                        <text x={ptW / 2} y={ptH - 2} textAnchor="middle" fontSize={9} fill="var(--color-text-muted)">Predicted Rank</text>
                        <text x={4} y={ptH / 2} textAnchor="middle" fontSize={9} fill="var(--color-text-muted)" transform={`rotate(-90,4,${ptH / 2})`}>Actual Rank</text>
                      </svg>
                      <div style={{ flex: 1, fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                        <div style={{ marginBottom: "6px" }}>
                          <span style={{ fontWeight: 600, color: "var(--color-text)" }}>Spearman ρ: {ptSpearman.toFixed(2)}</span>
                        </div>
                        <div style={{ marginBottom: "4px" }}>Within ±1 rank: {ptAccurate}/{ptRecords.length} ({(ptAccuracy * 100).toFixed(0)}%)</div>
                        <div style={{ marginBottom: "4px" }}>Windows evaluated: {Math.floor(ptRecords.length / ptWindowSize)}</div>
                        <div style={{ display: "flex", gap: "6px", marginTop: "6px" }}>
                          {[["var(--color-green, #22c55e)", "±1 rank"], ["var(--color-red, #ef4444)", ">1 rank off"]].map(([c, l]) => (
                            <span key={l} style={{ display: "flex", alignItems: "center", gap: "3px", fontSize: "0.7rem" }}>
                              <span style={{ width: 7, height: 7, borderRadius: "50%", background: c, display: "inline-block" }} />
                              {l}
                            </span>
                          ))}
                        </div>
                        <div style={{ fontSize: "0.73rem", fontStyle: "italic", marginTop: "6px" }}>
                          {ptAccuracy > 0.6 ? "Model predictions are well-calibrated — trust suggested rankings." : ptAccuracy > 0.35 ? "Mixed accuracy — treat predictions as rough guidance." : "Predictions are unreliable — consider more exploration."}
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })()}

              {/* Batch Informativeness — Batch 22 */}
              {suggestions && trials.length >= 5 && (() => {
                const bqSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (bqSpecs.length === 0 || suggestions.suggestions.length === 0) return null;
                const bqSuggs = suggestions.suggestions;
                const bqSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const bqK = Math.min(5, bqSorted.length);
                // Expected improvement proxy: predicted value improvement over current best
                const bqBestKpi = Math.max(...bqSorted.map(t => Object.values(t.kpis)[0] ?? -Infinity));
                const bqEIs: number[] = bqSuggs.map(s => {
                  // k-NN predicted value
                  const dists = bqSorted.map(t => {
                    let d = 0;
                    bqSpecs.forEach((spec: { name: string; lower?: number; upper?: number }) => {
                      const range = (spec.upper ?? 1) - (spec.lower ?? 0);
                      const diff = ((s[spec.name] ?? 0) - (t.parameters[spec.name] ?? 0)) / (range || 1);
                      d += diff * diff;
                    });
                    return { dist: Math.sqrt(d), kpi: Object.values(t.kpis)[0] ?? 0 };
                  }).sort((a, b) => a.dist - b.dist).slice(0, bqK);
                  const pred = dists.reduce((sum, d) => sum + d.kpi, 0) / dists.length;
                  return Math.max(0, pred - bqBestKpi);
                });
                // Diversity: avg pairwise distance
                let bqPairSum = 0, bqPairCount = 0;
                for (let i = 0; i < bqSuggs.length; i++) {
                  for (let j = i + 1; j < bqSuggs.length; j++) {
                    let d = 0;
                    bqSpecs.forEach((spec: { name: string; lower?: number; upper?: number }) => {
                      const range = (spec.upper ?? 1) - (spec.lower ?? 0);
                      const diff = ((bqSuggs[i][spec.name] ?? 0) - (bqSuggs[j][spec.name] ?? 0)) / (range || 1);
                      d += diff * diff;
                    });
                    bqPairSum += Math.sqrt(d);
                    bqPairCount++;
                  }
                }
                const bqDiversity = bqPairCount > 0 ? Math.min(1, bqPairSum / bqPairCount / Math.sqrt(bqSpecs.length)) : 0;
                // Coverage: how much of unexplored space the suggestions cover
                const bqNovelty = bqSuggs.map(s => {
                  const minDist = Math.min(...bqSorted.map(t => {
                    let d = 0;
                    bqSpecs.forEach((spec: { name: string; lower?: number; upper?: number }) => {
                      const range = (spec.upper ?? 1) - (spec.lower ?? 0);
                      const diff = ((s[spec.name] ?? 0) - (t.parameters[spec.name] ?? 0)) / (range || 1);
                      d += diff * diff;
                    });
                    return Math.sqrt(d);
                  }));
                  return Math.min(1, minDist / Math.sqrt(bqSpecs.length) * 2);
                });
                const bqAvgNovelty = bqNovelty.reduce((s, v) => s + v, 0) / bqNovelty.length;
                // Composite score: 40% EI quality + 30% diversity + 30% novelty
                const bqEiMax = Math.max(0.0001, ...bqEIs);
                const bqEiNorm = bqEIs.reduce((s, v) => s + v / bqEiMax, 0) / bqEIs.length;
                const bqScore = Math.min(100, Math.round((bqEiNorm * 0.4 + bqDiversity * 0.3 + bqAvgNovelty * 0.3) * 100));
                const bqBadge = bqScore > 70 ? "Run It" : bqScore > 45 ? "Acceptable" : "Reconsider";
                const bqBadgeColor = bqScore > 70 ? "var(--color-green, #22c55e)" : bqScore > 45 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Gauge visualization
                const bqGaugeW = 160, bqGaugeH = 90;
                const bqAngle = (bqScore / 100) * Math.PI;
                const bqR = 60;
                const bqCx = bqGaugeW / 2, bqCy = 75;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Award size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Batch Informativeness</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: bqBadgeColor + "18", color: bqBadgeColor }}>{bqBadge}</span>
                    </div>
                    <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
                      <svg width={bqGaugeW} height={bqGaugeH} style={{ flexShrink: 0 }}>
                        {/* Background arc */}
                        <path d={`M${bqCx - bqR},${bqCy} A${bqR},${bqR} 0 0,1 ${bqCx + bqR},${bqCy}`} fill="none" stroke="var(--color-border)" strokeWidth={8} strokeLinecap="round" />
                        {/* Score arc segments */}
                        {[
                          { start: 0, end: 0.45, color: "#ef4444" },
                          { start: 0.45, end: 0.7, color: "#eab308" },
                          { start: 0.7, end: 1, color: "#22c55e" },
                        ].map((seg, i) => {
                          const s = Math.PI - seg.start * Math.PI;
                          const e = Math.PI - seg.end * Math.PI;
                          return (
                            <path key={`bq-seg-${i}`} d={`M${bqCx + bqR * Math.cos(s)},${bqCy - bqR * Math.sin(s)} A${bqR},${bqR} 0 0,1 ${bqCx + bqR * Math.cos(e)},${bqCy - bqR * Math.sin(e)}`} fill="none" stroke={seg.color} strokeWidth={8} strokeLinecap="round" opacity={0.3} />
                          );
                        })}
                        {/* Needle */}
                        <line x1={bqCx} y1={bqCy} x2={bqCx + (bqR - 10) * Math.cos(Math.PI - bqAngle)} y2={bqCy - (bqR - 10) * Math.sin(Math.PI - bqAngle)} stroke="var(--color-text)" strokeWidth={2} strokeLinecap="round" />
                        <circle cx={bqCx} cy={bqCy} r={4} fill="var(--color-text)" />
                        <text x={bqCx} y={bqCy - 20} textAnchor="middle" fontSize={18} fontWeight={700} fill="var(--color-text)">{bqScore}</text>
                        <text x={bqCx} y={bqCy - 8} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">/ 100</text>
                        <text x={bqCx - bqR + 5} y={bqCy + 12} fontSize={7} fill="var(--color-text-muted)">0</text>
                        <text x={bqCx + bqR - 12} y={bqCy + 12} fontSize={7} fill="var(--color-text-muted)">100</text>
                      </svg>
                      <div style={{ flex: 1, fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                        <div style={{ marginBottom: "6px", fontWeight: 600, color: "var(--color-text)" }}>Quality Breakdown</div>
                        {[
                          { label: "Expected Improvement", value: bqEiNorm, weight: "40%" },
                          { label: "Batch Diversity", value: bqDiversity, weight: "30%" },
                          { label: "Novelty Coverage", value: bqAvgNovelty, weight: "30%" },
                        ].map(item => (
                          <div key={item.label} style={{ marginBottom: "4px" }}>
                            <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.73rem" }}>
                              <span>{item.label} ({item.weight})</span>
                              <span style={{ fontWeight: 600 }}>{(item.value * 100).toFixed(0)}%</span>
                            </div>
                            <div style={{ height: 4, background: "var(--color-border)", borderRadius: 2, overflow: "hidden" }}>
                              <div style={{ width: `${item.value * 100}%`, height: "100%", background: item.value > 0.6 ? "var(--color-green, #22c55e)" : item.value > 0.3 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)", borderRadius: 2 }} />
                            </div>
                          </div>
                        ))}
                        <div style={{ fontSize: "0.73rem", fontStyle: "italic", marginTop: "6px" }}>
                          {bqScore > 70 ? "This batch is worth running — good balance of exploitation and exploration." : bqScore > 45 ? "Acceptable batch — consider regenerating for better diversity." : "Batch quality is low — try increasing exploration weight."}
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })()}

              {/* Batch Pareto Frontier */}
              {suggestions && suggestions.suggestions.length >= 3 && trials.length >= 5 && (() => {
                const bpSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (bpSpecs.length < 2) return null;
                const bpObjKey = Object.keys(trials[0].kpis)[0];
                const bpNorm = (v: number, lo: number, hi: number) => hi > lo ? (v - lo) / (hi - lo) : 0;
                const bpRanges = bpSpecs.map((s: { name: string; lower?: number; upper?: number }) => ({
                  name: s.name, lo: s.lower!, hi: s.upper!
                }));
                const bpK = Math.min(5, Math.floor(trials.length / 3));
                // For each suggestion, compute: novelty, predicted improvement, diversity contribution
                const bpSuggs = suggestions.suggestions.map((sg, idx) => {
                  // Novelty: min distance to any trial
                  const dists = trials.map(t => {
                    let d2 = 0;
                    for (const r of bpRanges) {
                      const a = bpNorm(sg[r.name] ?? 0, r.lo, r.hi);
                      const b = bpNorm(t.parameters[r.name] ?? 0, r.lo, r.hi);
                      d2 += (a - b) ** 2;
                    }
                    return Math.sqrt(d2);
                  });
                  const novelty = Math.min(...dists);
                  // Predicted improvement via k-NN
                  const sorted = [...trials].map(t => {
                    let d2 = 0;
                    for (const r of bpRanges) {
                      const a = bpNorm(sg[r.name] ?? 0, r.lo, r.hi);
                      const b = bpNorm(t.parameters[r.name] ?? 0, r.lo, r.hi);
                      d2 += (a - b) ** 2;
                    }
                    return { dist: Math.sqrt(d2), val: t.kpis[bpObjKey] ?? 0 };
                  }).sort((a, b) => a.dist - b.dist);
                  const knn = sorted.slice(0, bpK);
                  const pred = knn.reduce((s, d) => s + d.val, 0) / bpK;
                  const bestSoFar = Math.min(...trials.map(t => t.kpis[bpObjKey] ?? Infinity));
                  const improvement = Math.max(0, bestSoFar - pred);
                  // Diversity: avg distance to other suggestions
                  const otherSuggs = suggestions.suggestions.filter((_, j) => j !== idx);
                  let divSum = 0;
                  for (const os of otherSuggs) {
                    let d2 = 0;
                    for (const r of bpRanges) {
                      const a = bpNorm(sg[r.name] ?? 0, r.lo, r.hi);
                      const b = bpNorm(os[r.name] ?? 0, r.lo, r.hi);
                      d2 += (a - b) ** 2;
                    }
                    divSum += Math.sqrt(d2);
                  }
                  const diversity = otherSuggs.length > 0 ? divSum / otherSuggs.length : 0;
                  return { idx: idx + 1, novelty, improvement, diversity };
                });
                // Normalize to 0-1
                const bpMaxN = Math.max(...bpSuggs.map(s => s.novelty), 0.001);
                const bpMaxI = Math.max(...bpSuggs.map(s => s.improvement), 0.001);
                const bpMaxD = Math.max(...bpSuggs.map(s => s.diversity), 0.001);
                const bpNormed = bpSuggs.map(s => ({
                  ...s,
                  nN: s.novelty / bpMaxN,
                  nI: s.improvement / bpMaxI,
                  nD: s.diversity / bpMaxD,
                }));
                // Pareto dominance check (2D: improvement vs novelty for visualization)
                const bpIsPareto = bpNormed.map((a, i) => {
                  return !bpNormed.some((b, j) => i !== j && b.nI >= a.nI && b.nN >= a.nN && (b.nI > a.nI || b.nN > a.nN));
                });
                const bpParetoCount = bpIsPareto.filter(Boolean).length;
                const bpParetoFrac = bpParetoCount / bpSuggs.length;
                const bpBadge = bpParetoFrac >= 0.8 ? "Pareto-Optimal" : bpParetoFrac >= 0.5 ? "Near-Optimal" : "Dominated";
                const bpBadgeColor = bpParetoFrac >= 0.8 ? "var(--color-green, #22c55e)" : bpParetoFrac >= 0.5 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // SVG scatter plot
                const bpW = 260, bpH = 200, bpPadL = 40, bpPadR = 15, bpPadT = 15, bpPadB = 30;
                const bpPlotW = bpW - bpPadL - bpPadR, bpPlotH = bpH - bpPadT - bpPadB;
                const bpPoints = bpNormed.map((s, i) => ({
                  x: bpPadL + s.nN * bpPlotW,
                  y: bpPadT + (1 - s.nI) * bpPlotH,
                  pareto: bpIsPareto[i],
                  idx: s.idx,
                  size: 4 + s.nD * 6,
                }));
                // Draw Pareto front line (connect pareto points sorted by novelty)
                const bpFront = bpPoints.filter(p => p.pareto).sort((a, b) => a.x - b.x);
                const bpFrontLine = bpFront.length >= 2 ? bpFront.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") : "";
                return (
                  <div className="card" style={{ padding: "20px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "10px", marginBottom: "12px" }}>
                      <Network size={18} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.95rem" }}>Batch Pareto Frontier</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: bpBadgeColor + "22", color: bpBadgeColor }}>{bpBadge}</span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: "8px" }}>
                      Trade-off between novelty and expected improvement. Dot size = batch diversity contribution.
                    </div>
                    <svg width={bpW} height={bpH} viewBox={`0 0 ${bpW} ${bpH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Grid */}
                      {[0, 0.25, 0.5, 0.75, 1].map(v => (
                        <Fragment key={`gy${v}`}>
                          <line x1={bpPadL} y1={bpPadT + (1 - v) * bpPlotH} x2={bpW - bpPadR} y2={bpPadT + (1 - v) * bpPlotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                          <text x={bpPadL - 4} y={bpPadT + (1 - v) * bpPlotH + 3} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>{(v * 100).toFixed(0)}%</text>
                        </Fragment>
                      ))}
                      {[0, 0.5, 1].map(v => (
                        <Fragment key={`gx${v}`}>
                          <line x1={bpPadL + v * bpPlotW} y1={bpPadT} x2={bpPadL + v * bpPlotW} y2={bpH - bpPadB} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                        </Fragment>
                      ))}
                      {/* Pareto front line */}
                      {bpFrontLine && <path d={bpFrontLine} fill="none" stroke={bpBadgeColor} strokeWidth="1.5" strokeDasharray="5,3" opacity={0.6} />}
                      {/* Points */}
                      {bpPoints.map((p, i) => (
                        <g key={i}>
                          <circle cx={p.x} cy={p.y} r={p.size} fill={p.pareto ? bpBadgeColor : "var(--color-text-muted)"} opacity={p.pareto ? 0.8 : 0.35} stroke={p.pareto ? bpBadgeColor : "none"} strokeWidth="1.5" />
                          <text x={p.x} y={p.y + 3} textAnchor="middle" style={{ fontSize: "0.55rem", fontWeight: 700, fill: "white" }}>#{p.idx}</text>
                        </g>
                      ))}
                      {/* Axis labels */}
                      <text x={(bpPadL + bpW - bpPadR) / 2} y={bpH - 3} textAnchor="middle" style={{ fontSize: "0.6rem", fill: "var(--color-text-muted)" }}>Novelty</text>
                      <text x={8} y={(bpPadT + bpH - bpPadB) / 2} textAnchor="middle" style={{ fontSize: "0.6rem", fill: "var(--color-text-muted)", transform: `rotate(-90, 8, ${(bpPadT + bpH - bpPadB) / 2})` }}>Improvement</text>
                    </svg>
                    <div style={{ display: "flex", gap: "12px", marginTop: "6px", fontSize: "0.72rem", justifyContent: "center" }}>
                      <span><span style={{ display: "inline-block", width: "8px", height: "8px", borderRadius: "50%", background: bpBadgeColor, marginRight: "4px" }}></span>Pareto-optimal ({bpParetoCount})</span>
                      <span><span style={{ display: "inline-block", width: "8px", height: "8px", borderRadius: "50%", background: "var(--color-text-muted)", opacity: 0.4, marginRight: "4px" }}></span>Dominated ({bpSuggs.length - bpParetoCount})</span>
                    </div>
                  </div>
                );
              })()}

              {/* Out-of-Support Detection — Mahalanobis distance flagging extrapolation risk */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const osSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (osSpecs.length < 2) return null;
                const osParamNames = osSpecs.map((s: { name: string }) => s.name);
                const osSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Compute mean and covariance of observed parameter values
                const osN = osSorted.length;
                const osD = osParamNames.length;
                const osMeans = osParamNames.map(p => {
                  const vals = osSorted.map(t => Number(t.parameters[p]) || 0);
                  return vals.reduce((s, v) => s + v, 0) / osN;
                });
                // Covariance matrix
                const osCov: number[][] = Array.from({ length: osD }, () => Array(osD).fill(0));
                for (let i = 0; i < osD; i++) {
                  for (let j = 0; j < osD; j++) {
                    let cov = 0;
                    for (let k = 0; k < osN; k++) {
                      const vi = (Number(osSorted[k].parameters[osParamNames[i]]) || 0) - osMeans[i];
                      const vj = (Number(osSorted[k].parameters[osParamNames[j]]) || 0) - osMeans[j];
                      cov += vi * vj;
                    }
                    osCov[i][j] = cov / Math.max(osN - 1, 1);
                  }
                }
                // Add regularization for numerical stability
                for (let i = 0; i < osD; i++) osCov[i][i] += 1e-6;
                // Simple inverse via Gauss-Jordan for small matrices (≤6)
                const osInv: number[][] = osCov.map(row => [...row]);
                const osI: number[][] = Array.from({ length: osD }, (_, i) => Array.from({ length: osD }, (__, j) => i === j ? 1 : 0));
                for (let i = 0; i < osD; i++) {
                  let maxRow = i;
                  for (let k = i + 1; k < osD; k++) if (Math.abs(osInv[k][i]) > Math.abs(osInv[maxRow][i])) maxRow = k;
                  [osInv[i], osInv[maxRow]] = [osInv[maxRow], osInv[i]];
                  [osI[i], osI[maxRow]] = [osI[maxRow], osI[i]];
                  const pivot = osInv[i][i];
                  if (Math.abs(pivot) < 1e-12) continue;
                  for (let j = 0; j < osD; j++) { osInv[i][j] /= pivot; osI[i][j] /= pivot; }
                  for (let k = 0; k < osD; k++) {
                    if (k === i) continue;
                    const factor = osInv[k][i];
                    for (let j = 0; j < osD; j++) { osInv[k][j] -= factor * osInv[i][j]; osI[k][j] -= factor * osI[i][j]; }
                  }
                }
                // Mahalanobis distance for each suggestion
                const osSuggs = suggestions.suggestions;
                const osDistances = osSuggs.map(s => {
                  const dx = osParamNames.map((p, i) => (Number(s[p]) || 0) - osMeans[i]);
                  let dist = 0;
                  for (let i = 0; i < osD; i++) for (let j = 0; j < osD; j++) dist += dx[i] * osI[i][j] * dx[j];
                  return Math.sqrt(Math.max(dist, 0));
                });
                // Threshold: chi-squared approximation (95% percentile for osD degrees of freedom)
                const osThreshold95 = Math.sqrt(osD + 2 * Math.sqrt(2 * osD)); // rough chi2 approx
                const osThreshold99 = Math.sqrt(osD + 3 * Math.sqrt(2 * osD));
                const osMaxDist = Math.max(...osDistances, osThreshold99);
                const osExtrapolating = osDistances.filter(d => d > osThreshold99).length;
                const osBorderline = osDistances.filter(d => d > osThreshold95 && d <= osThreshold99).length;
                const osGrounded = osDistances.filter(d => d <= osThreshold95).length;
                const osExtraPct = osSuggs.length > 0 ? osExtrapolating / osSuggs.length : 0;
                const osBadge = osExtraPct < 0.1 ? "Grounded" : osExtraPct < 0.4 ? "Borderline" : "Extrapolating";
                const osBadgeColor = osExtraPct < 0.1 ? "var(--color-green, #22c55e)" : osExtraPct < 0.4 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Dot plot
                const osPlotW = 280, osPlotH = 80, osPadL = 30, osPadR = 10, osPadT = 15, osPadB = 20;
                const osPlotArea = osPlotW - osPadL - osPadR;
                const osPlotHH = osPlotH - osPadT - osPadB;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <AlertOctagon size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Out-of-Support Detection</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: osBadgeColor + "18", color: osBadgeColor }}>{osBadge}</span>
                    </div>
                    <svg width={osPlotW} height={osPlotH} viewBox={`0 0 ${osPlotW} ${osPlotH}`} style={{ display: "block", margin: "0 auto" }}>
                      {/* Background zones */}
                      <rect x={osPadL} y={osPadT} width={Math.min(osThreshold95 / osMaxDist, 1) * osPlotArea} height={osPlotHH} fill="var(--color-green, #22c55e)" opacity={0.06} />
                      <rect x={osPadL + (osThreshold95 / osMaxDist) * osPlotArea} y={osPadT} width={Math.max(0, (osThreshold99 - osThreshold95) / osMaxDist) * osPlotArea} height={osPlotHH} fill="var(--color-yellow, #eab308)" opacity={0.06} />
                      <rect x={osPadL + (osThreshold99 / osMaxDist) * osPlotArea} y={osPadT} width={Math.max(0, osPlotArea - (osThreshold99 / osMaxDist) * osPlotArea)} height={osPlotHH} fill="var(--color-red, #ef4444)" opacity={0.06} />
                      {/* Threshold lines */}
                      <line x1={osPadL + (osThreshold95 / osMaxDist) * osPlotArea} y1={osPadT} x2={osPadL + (osThreshold95 / osMaxDist) * osPlotArea} y2={osPlotH - osPadB} stroke="var(--color-yellow, #eab308)" strokeWidth="1" strokeDasharray="4,3" opacity={0.6} />
                      <line x1={osPadL + (osThreshold99 / osMaxDist) * osPlotArea} y1={osPadT} x2={osPadL + (osThreshold99 / osMaxDist) * osPlotArea} y2={osPlotH - osPadB} stroke="var(--color-red, #ef4444)" strokeWidth="1" strokeDasharray="4,3" opacity={0.6} />
                      {/* Dot strip (jittered y for visibility) */}
                      {osDistances.map((d, i) => {
                        const x = osPadL + (d / osMaxDist) * osPlotArea;
                        const jitter = ((i * 7 + 13) % 5) / 5;
                        const y = osPadT + osPadT + jitter * (osPlotHH - 2 * osPadT);
                        const color = d > osThreshold99 ? "var(--color-red, #ef4444)" : d > osThreshold95 ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)";
                        return <circle key={i} cx={x} cy={y} r={4} fill={color} opacity={0.7} stroke="white" strokeWidth="0.5" />;
                      })}
                      {/* Labels */}
                      <text x={osPadL} y={osPlotH - 3} style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>0</text>
                      <text x={osPlotW - osPadR} y={osPlotH - 3} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>{osMaxDist.toFixed(1)}</text>
                      <text x={(osPadL + osPlotW - osPadR) / 2} y={osPlotH - 3} textAnchor="middle" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Mahalanobis Distance</text>
                      <text x={osPadL + 4} y={osPadT - 3} style={{ fontSize: "0.45rem", fill: "var(--color-green, #22c55e)" }}>Safe</text>
                      <text x={osPadL + (osThreshold99 / osMaxDist) * osPlotArea + 4} y={osPadT - 3} style={{ fontSize: "0.45rem", fill: "var(--color-red, #ef4444)" }}>Extrapolating</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "center", gap: "16px", marginTop: "8px", fontSize: "0.75rem" }}>
                      <span style={{ color: "var(--color-green, #22c55e)" }}><strong>{osGrounded}</strong> grounded</span>
                      <span style={{ color: "var(--color-yellow, #eab308)" }}><strong>{osBorderline}</strong> borderline</span>
                      <span style={{ color: "var(--color-red, #ef4444)" }}><strong>{osExtrapolating}</strong> extrapolating</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "6px", textAlign: "center" }}>
                      {osBadge === "Grounded" ? "Suggestions stay within observed data support — predictions are interpolative." :
                       osBadge === "Borderline" ? "Some suggestions near data boundary — verify predictions before committing." :
                       "Many suggestions extrapolate beyond observed data — high prediction uncertainty expected."}
                    </div>
                  </div>
                );
              })()}

              {/* Redundancy Filter — similarity of suggestions to past trials */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 3 && (() => {
                const rfSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rfSpecs.length < 2) return null;
                const rfParamNames = rfSpecs.map((s: { name: string }) => s.name);
                const rfRanges = rfSpecs.map((s: { lower?: number; upper?: number }) => Math.max((s.upper ?? 1) - (s.lower ?? 0), 1e-10));
                const rfSuggs = suggestions.suggestions;
                // For each suggestion, find min normalized Euclidean distance to any past trial
                const rfDistances = rfSuggs.map(s => {
                  let minDist = Infinity;
                  for (const t of trials) {
                    let dist = 0;
                    for (let j = 0; j < rfParamNames.length; j++) {
                      const diff = ((Number(s[rfParamNames[j]]) || 0) - (Number(t.parameters[rfParamNames[j]]) || 0)) / rfRanges[j];
                      dist += diff * diff;
                    }
                    dist = Math.sqrt(dist / rfParamNames.length);
                    if (dist < minDist) minDist = dist;
                  }
                  return minDist;
                });
                // Threshold: < 0.05 normalized distance = redundant, < 0.15 = overlap
                const rfRedundant = rfDistances.filter(d => d < 0.05).length;
                const rfOverlap = rfDistances.filter(d => d >= 0.05 && d < 0.15).length;
                const rfNovel = rfDistances.filter(d => d >= 0.15).length;
                const rfRedPct = rfSuggs.length > 0 ? rfRedundant / rfSuggs.length : 0;
                const rfBadge = rfRedPct < 0.1 ? "Novel" : rfRedPct < 0.4 ? "Some Overlap" : "Redundant";
                const rfBadgeColor = rfRedPct < 0.1 ? "var(--color-green, #22c55e)" : rfRedPct < 0.4 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Visual: horizontal bar per suggestion showing distance
                const rfMaxDist = Math.max(...rfDistances, 0.3);
                const rfW = 280, rfBarH = 22, rfLabelW = 30, rfPad = 8;
                const rfTotalH = rfSuggs.length * (rfBarH + 4) + 10;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Rabbit size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Redundancy Filter</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: rfBadgeColor + "18", color: rfBadgeColor }}>{rfBadge}</span>
                    </div>
                    <svg width={rfW} height={rfTotalH} viewBox={`0 0 ${rfW} ${rfTotalH}`} style={{ display: "block", margin: "0 auto" }}>
                      {/* Threshold lines */}
                      {[0.05, 0.15].map(th => {
                        const x = rfLabelW + rfPad + (th / rfMaxDist) * (rfW - rfLabelW - 2 * rfPad);
                        return <line key={th} x1={x} y1={0} x2={x} y2={rfTotalH} stroke={th === 0.05 ? "var(--color-red, #ef4444)" : "var(--color-yellow, #eab308)"} strokeWidth="1" strokeDasharray="4,3" opacity={0.4} />;
                      })}
                      {rfSuggs.map((_s, i) => {
                        const y = i * (rfBarH + 4) + 5;
                        const dist = rfDistances[i];
                        const w = (dist / rfMaxDist) * (rfW - rfLabelW - 2 * rfPad);
                        const color = dist < 0.05 ? "var(--color-red, #ef4444)" : dist < 0.15 ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)";
                        const label = dist < 0.05 ? "redundant" : dist < 0.15 ? "overlap" : "novel";
                        return (
                          <g key={i}>
                            <text x={rfLabelW - 2} y={y + rfBarH / 2 + 4} textAnchor="end" style={{ fontSize: "0.6rem", fontWeight: 600, fill: "var(--color-text-muted)" }}>#{i + 1}</text>
                            <rect x={rfLabelW + rfPad} y={y} width={rfW - rfLabelW - 2 * rfPad} height={rfBarH} rx={4} fill="var(--color-border)" opacity={0.15} />
                            <rect x={rfLabelW + rfPad} y={y} width={Math.max(w, 2)} height={rfBarH} rx={4} fill={color} opacity={0.6} />
                            <text x={rfLabelW + rfPad + Math.max(w, 2) + 4} y={y + rfBarH / 2 + 4} style={{ fontSize: "0.5rem", fontFamily: "var(--font-mono)", fill: color, fontWeight: 600 }}>{dist.toFixed(3)} {label}</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "center", gap: "16px", marginTop: "8px", fontSize: "0.72rem" }}>
                      <span style={{ color: "var(--color-green, #22c55e)" }}><strong>{rfNovel}</strong> novel</span>
                      <span style={{ color: "var(--color-yellow, #eab308)" }}><strong>{rfOverlap}</strong> overlap</span>
                      <span style={{ color: "var(--color-red, #ef4444)" }}><strong>{rfRedundant}</strong> redundant</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "6px", textAlign: "center" }}>
                      {rfBadge === "Novel" ? "All suggestions explore new parameter regions — efficient use of experimental budget." :
                       rfBadge === "Some Overlap" ? "Some suggestions overlap with past trials — consider increasing exploration weight." :
                       "Many suggestions duplicate past experiments — strongly consider increasing diversity."}
                    </div>
                  </div>
                );
              })()}

              {/* Suggestion Risk Score */}
              {suggestions && suggestions.suggestions.length > 0 && trials.length >= 5 && (() => {
                const srSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (srSpecs.length === 0) return null;
                const srObjKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!srObjKey) return null;
                // Find worst-performing trials (bottom 15%)
                const srSortedByObj = [...trials].sort((a, b) => b.kpis[srObjKey] - a.kpis[srObjKey]);
                const srWorstN = Math.max(3, Math.floor(trials.length * 0.15));
                const srWorst = srSortedByObj.slice(0, srWorstN);
                // Normalize suggestion and worst trials into [0,1] space
                const srNormParam = (val: number, s: { lower?: number; upper?: number }) => {
                  const lo = s.lower ?? 0, hi = s.upper ?? 1;
                  return hi > lo ? (val - lo) / (hi - lo) : 0.5;
                };
                // For each suggestion, compute min distance to worst trials
                const srResults = suggestions.suggestions.map((sug, si) => {
                  const sugNorm = srSpecs.map((s: { name: string; lower?: number; upper?: number }) => srNormParam(Number(sug[s.name]) || 0, s));
                  let minDistWorst = Infinity;
                  srWorst.forEach(w => {
                    const wNorm = srSpecs.map((s: { name: string; lower?: number; upper?: number }) => srNormParam(Number(w.parameters[s.name]) || 0, s));
                    const dist = Math.sqrt(sugNorm.reduce((sum, v, k) => sum + (v - wNorm[k]) ** 2, 0));
                    if (dist < minDistWorst) minDistWorst = dist;
                  });
                  // Risk score: closer to worst = higher risk. Scale to 0-100%
                  const maxDist = Math.sqrt(srSpecs.length); // diagonal of unit cube
                  const safety = Math.min(1, minDistWorst / (maxDist * 0.5));
                  return { idx: si + 1, safety, minDist: minDistWorst };
                });
                const srAvgSafety = srResults.reduce((s, r) => s + r.safety, 0) / srResults.length;
                const srBadge = srAvgSafety > 0.75 ? "Low Risk" : srAvgSafety > 0.45 ? "Moderate" : "High Risk";
                const srBadgeColor = srAvgSafety > 0.75 ? "var(--color-green, #22c55e)" : srAvgSafety > 0.45 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Horizontal bar chart
                const srBarH = 22;
                const srW = 260, srH = srResults.length * srBarH + 24;
                const srLabelW = 30, srBarMaxW = 180;
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Siren size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Suggestion Risk Score</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: srBadgeColor + "18", color: srBadgeColor }}>{srBadge}</span>
                    </div>
                    <svg width={srW} height={srH} style={{ width: "100%", maxWidth: srW }}>
                      {srResults.map((r, i) => {
                        const y = i * srBarH + 4;
                        const barW = r.safety * srBarMaxW;
                        const barColor = r.safety > 0.75 ? "var(--color-green, #22c55e)" : r.safety > 0.45 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={`sr-bar-${i}`}>
                            <text x={srLabelW - 4} y={y + srBarH / 2 + 3} textAnchor="end" fontSize={8} fill="var(--color-text-muted)" fontWeight={500}>#{r.idx}</text>
                            <rect x={srLabelW} y={y + 2} width={srBarMaxW} height={srBarH - 6} rx={3} fill="var(--color-border)" opacity={0.3} />
                            <rect x={srLabelW} y={y + 2} width={Math.max(2, barW)} height={srBarH - 6} rx={3} fill={barColor} opacity={0.7}>
                              <title>Suggestion #{r.idx}: {(r.safety * 100).toFixed(0)}% safe (dist to worst: {r.minDist.toFixed(3)})</title>
                            </rect>
                            <text x={srLabelW + Math.max(2, barW) + 4} y={y + srBarH / 2 + 3} fontSize={7.5} fill="var(--color-text)" fontFamily="var(--font-mono)" fontWeight={600}>
                              {(r.safety * 100).toFixed(0)}%
                            </text>
                          </g>
                        );
                      })}
                      <text x={srLabelW + srBarMaxW / 2} y={srH - 2} textAnchor="middle" fontSize={7.5} fill="var(--color-text-muted)">Safety Score (distance from worst trials)</text>
                    </svg>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {srBadge === "Low Risk" ? "Suggestions are well-separated from failure regions — safe to run." :
                       srBadge === "Moderate" ? "Some suggestions are near historically poor regions — review before running." :
                       "Suggestions are close to failure regions — manual review recommended."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Suggestion Provenance (Batch 27) ── */}
              {(() => {
                if (!suggestions?.suggestions?.length || !campaign?.observations?.length || campaign.observations.length < 3) return null;
                const spSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (spSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const spObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (spObs.length < 3) return null;
                // find best observation
                let spBestIdx = 0;
                spObs.forEach((o: { kpi_values: Record<string, number> }, i: number) => {
                  if (o.kpi_values[kpiKey] > spObs[spBestIdx].kpi_values[kpiKey]) spBestIdx = i;
                });
                const spBestParams = spObs[spBestIdx].parameters;
                // normalize distances
                const spNorm = (params: Record<string, number>, ref: Record<string, number>) => {
                  let sum = 0, count = 0;
                  spSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    if (range > 0 && params[s.name] != null && ref[s.name] != null) {
                      sum += ((params[s.name] - ref[s.name]) / range) ** 2;
                      count++;
                    }
                  });
                  return count > 0 ? Math.sqrt(sum / count) : 0;
                };
                // for each suggestion, compute exploit score (closeness to best) and explore score (distance from nearest obs)
                const spData = suggestions.suggestions.map((sug: Record<string, number>, idx: number) => {
                  const distToBest = spNorm(sug, spBestParams);
                  let minDistToObs = Infinity;
                  spObs.forEach((o: { parameters: Record<string, number> }) => {
                    const d = spNorm(sug, o.parameters);
                    if (d < minDistToObs) minDistToObs = d;
                  });
                  // exploit = 1 - distToBest (closer = more exploitative), clamped
                  const exploit = Math.max(0, Math.min(1, 1 - distToBest * 3));
                  // explore = minDistToObs (farther from data = more exploratory), clamped
                  const explore = Math.max(0, Math.min(1, minDistToObs * 3));
                  const total = exploit + explore || 1;
                  return { idx: idx + 1, exploit: exploit / total, explore: explore / total };
                });
                const spAvgExploit = spData.reduce((s: number, d: { exploit: number }) => s + d.exploit, 0) / spData.length;
                const spBadge = spAvgExploit > 0.65 ? "Exploit-Heavy" : spAvgExploit < 0.35 ? "Explore-Heavy" : "Balanced";
                const spBadgeColor = spBadge === "Exploit-Heavy" ? "var(--color-orange, #f97316)" : spBadge === "Explore-Heavy" ? "var(--color-blue, #3b82f6)" : "var(--color-green, #22c55e)";
                const spW = 220, spBarH = 18, spGap = 6;
                const spH = spData.length * (spBarH + spGap) + 24;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Split size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Suggestion Provenance</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: spBadgeColor, color: "#fff" }}>{spBadge}</span>
                    </div>
                    <svg width={spW} height={spH} viewBox={`0 0 ${spW} ${spH}`} style={{ display: "block", width: "100%" }}>
                      {/* legend */}
                      <rect x="0" y="0" width="10" height="10" rx="2" fill="var(--color-orange, #f97316)" opacity="0.75" />
                      <text x="14" y="9" fontSize="9" fill="var(--color-text-muted, #64748b)">Exploit</text>
                      <rect x="60" y="0" width="10" height="10" rx="2" fill="var(--color-blue, #3b82f6)" opacity="0.75" />
                      <text x="74" y="9" fontSize="9" fill="var(--color-text-muted, #64748b)">Explore</text>
                      {spData.map((d: { idx: number; exploit: number; explore: number }, i: number) => {
                        const y = i * (spBarH + spGap) + 20;
                        const maxBar = spW - 40;
                        const exploitW = d.exploit * maxBar;
                        const exploreW = d.explore * maxBar;
                        return (
                          <g key={d.idx}>
                            <text x="0" y={y + 13} fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">#{d.idx}</text>
                            <rect x="28" y={y} width={exploitW} height={spBarH} rx="3" fill="var(--color-orange, #f97316)" opacity="0.75" />
                            <rect x={28 + exploitW} y={y} width={exploreW} height={spBarH} rx="3" fill="var(--color-blue, #3b82f6)" opacity="0.75" />
                            <text x={28 + exploitW + exploreW + 4} y={y + 13} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">{(d.exploit * 100).toFixed(0)}/{(d.explore * 100).toFixed(0)}</text>
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {spBadge === "Balanced" ? "Good balance between refining known regions and exploring new areas." : spBadge === "Exploit-Heavy" ? "Batch is focused on refining near the current best." : "Batch is pushing into unexplored territory."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Suggestion Consensus (Batch 28) ── */}
              {(() => {
                if (!suggestions?.suggestions?.length || suggestions.suggestions.length < 2) return null;
                const scSpecs = (campaign?.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (scSpecs.length === 0) return null;
                // for each parameter, compute spread of suggested values relative to full range
                const scData: { name: string; spread: number; center: number }[] = [];
                scSpecs.forEach((spec: { name: string; lower?: number; upper?: number }) => {
                  const range = (spec.upper || 1) - (spec.lower || 0);
                  if (range <= 0) return;
                  const vals = suggestions.suggestions.map((s: Record<string, number>) => s[spec.name]).filter((v: number) => v != null);
                  if (vals.length < 2) return;
                  const min = Math.min(...vals);
                  const max = Math.max(...vals);
                  const spread = (max - min) / range;
                  const center = ((min + max) / 2 - (spec.lower || 0)) / range;
                  scData.push({ name: spec.name, spread, center });
                });
                if (scData.length === 0) return null;
                const scAvgSpread = scData.reduce((s, d) => s + d.spread, 0) / scData.length;
                const scBadge = scAvgSpread < 0.2 ? "Converging" : scAvgSpread < 0.5 ? "Mixed" : "Diverging";
                const scBadgeColor = scBadge === "Converging" ? "var(--color-green, #22c55e)" : scBadge === "Mixed" ? "var(--color-yellow, #eab308)" : "var(--color-blue, #3b82f6)";
                const scBarW = 220, scRowH = 24;
                const scH = scData.length * scRowH + 4;
                const scLabelW = Math.min(Math.max(...scData.map(d => d.name.length)) * 7 + 10, 85);
                const scChartW = scBarW - scLabelW - 8;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <GitMerge size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Suggestion Consensus</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: scBadgeColor, color: "#fff" }}>{scBadge}</span>
                    </div>
                    <svg width={scBarW} height={scH} viewBox={`0 0 ${scBarW} ${scH}`} style={{ display: "block", width: "100%" }}>
                      {scData.map((d, i) => {
                        const y = i * scRowH + 2;
                        const barX = scLabelW + d.center * scChartW - (d.spread * scChartW) / 2;
                        const barWidth = Math.max(d.spread * scChartW, 3);
                        const centerX = scLabelW + d.center * scChartW;
                        const color = d.spread < 0.2 ? "var(--color-green, #22c55e)" : d.spread < 0.5 ? "var(--color-yellow, #eab308)" : "var(--color-blue, #3b82f6)";
                        return (
                          <g key={d.name}>
                            <text x={scLabelW - 4} y={y + 14} textAnchor="end" fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">{d.name.length > 11 ? d.name.slice(0, 10) + "…" : d.name}</text>
                            {/* full range background */}
                            <rect x={scLabelW} y={y + 4} width={scChartW} height="14" rx="3" fill="var(--color-border, #e2e8f0)" />
                            {/* spread bar */}
                            <rect x={Math.max(scLabelW, barX)} y={y + 4} width={Math.min(barWidth, scChartW)} height="14" rx="3" fill={color} opacity="0.7" />
                            {/* center dot */}
                            <circle cx={Math.max(scLabelW + 2, Math.min(centerX, scLabelW + scChartW - 2))} cy={y + 11} r="3" fill={color} />
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {scBadge === "Converging" ? "Suggestions agree on parameter values — optimizer is confident." : scBadge === "Mixed" ? "Some parameters are well-determined, others still being explored." : "Wide parameter spread — optimizer is still searching broadly."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Gradient Alignment (Batch 29) ── */}
              {(() => {
                if (!suggestions?.suggestions?.length || !campaign?.observations?.length || campaign.observations.length < 5) return null;
                const gaSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (gaSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const gaObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (gaObs.length < 5) return null;
                // find best observation
                let gaBestIdx = 0;
                gaObs.forEach((o: { kpi_values: Record<string, number> }, i: number) => {
                  if (o.kpi_values[kpiKey] > gaObs[gaBestIdx].kpi_values[kpiKey]) gaBestIdx = i;
                });
                const gaBestObs = gaObs[gaBestIdx];
                // estimate gradient at best point using k=5 nearest neighbors finite differences
                const gaDists = gaObs.map((o: { parameters: Record<string, number>; kpi_values: Record<string, number> }, i: number) => {
                  if (i === gaBestIdx) return { i, d: Infinity };
                  let sum = 0;
                  gaSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    sum += ((o.parameters[s.name] - gaBestObs.parameters[s.name]) / (range || 1)) ** 2;
                  });
                  return { i, d: Math.sqrt(sum) };
                }).sort((a: { d: number }, b: { d: number }) => a.d - b.d);
                const gaK = Math.min(5, gaObs.length - 1);
                const gaNeighbors = gaDists.slice(0, gaK);
                // finite difference gradient per parameter
                const gaGrad: Record<string, number> = {};
                gaSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                  const range = (s.upper || 1) - (s.lower || 0);
                  let num = 0, den = 0;
                  gaNeighbors.forEach((n: { i: number }) => {
                    const o = gaObs[n.i];
                    const dp = (o.parameters[s.name] - gaBestObs.parameters[s.name]) / (range || 1);
                    const dy = o.kpi_values[kpiKey] - gaBestObs.kpi_values[kpiKey];
                    num += dp * dy;
                    den += dp * dp;
                  });
                  gaGrad[s.name] = den > 1e-10 ? num / den : 0;
                });
                // normalize gradient
                const gaGradNorm = Math.sqrt(gaSpecs.reduce((s: number, spec: { name: string }) => s + gaGrad[spec.name] ** 2, 0)) || 1;
                // for each suggestion, compute alignment = dot product of (sug - best) direction with gradient
                const gaData = suggestions.suggestions.map((sug: Record<string, number>, idx: number) => {
                  let dot = 0, sugNorm = 0;
                  gaSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    const dir = (sug[s.name] - gaBestObs.parameters[s.name]) / (range || 1);
                    dot += dir * (gaGrad[s.name] / gaGradNorm);
                    sugNorm += dir * dir;
                  });
                  sugNorm = Math.sqrt(sugNorm) || 1;
                  const alignment = dot / sugNorm; // cosine similarity, range [-1, 1]
                  return { idx: idx + 1, alignment };
                });
                const gaAvgAlign = gaData.reduce((s: number, d: { alignment: number }) => s + d.alignment, 0) / gaData.length;
                const gaBadge = gaAvgAlign > 0.3 ? "Aligned" : gaAvgAlign > -0.1 ? "Mixed" : "Counter-Gradient";
                const gaBadgeColor = gaBadge === "Aligned" ? "var(--color-green, #22c55e)" : gaBadge === "Mixed" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const gaW = 220, gaBarH = 18, gaGap = 6;
                const gaH = gaData.length * (gaBarH + gaGap) + 8;
                const gaMidX = gaW / 2;
                const gaMaxBar = (gaW - 50) / 2;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <ArrowRight size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Gradient Alignment</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: gaBadgeColor, color: "#fff" }}>{gaBadge}</span>
                    </div>
                    <svg width={gaW} height={gaH} viewBox={`0 0 ${gaW} ${gaH}`} style={{ display: "block", width: "100%" }}>
                      {/* center line */}
                      <line x1={gaMidX} y1={0} x2={gaMidX} y2={gaH - 4} stroke="var(--color-border, #e2e8f0)" strokeWidth="1" />
                      {gaData.map((d: { idx: number; alignment: number }, i: number) => {
                        const y = i * (gaBarH + gaGap) + 4;
                        const barLen = Math.abs(d.alignment) * gaMaxBar;
                        const barX = d.alignment >= 0 ? gaMidX : gaMidX - barLen;
                        const color = d.alignment > 0.3 ? "var(--color-green, #22c55e)" : d.alignment > -0.1 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={d.idx}>
                            <text x="2" y={y + 13} fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">#{d.idx}</text>
                            <rect x={barX} y={y} width={Math.max(barLen, 2)} height={gaBarH} rx="3" fill={color} opacity="0.7" />
                            <text x={d.alignment >= 0 ? gaMidX + barLen + 4 : gaMidX - barLen - 4} y={y + 13} textAnchor={d.alignment >= 0 ? "start" : "end"} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">{d.alignment >= 0 ? "+" : ""}{d.alignment.toFixed(2)}</text>
                          </g>
                        );
                      })}
                      {/* axis labels */}
                      <text x={gaMidX - gaMaxBar} y={gaH - 1} textAnchor="middle" fontSize="7" fill="var(--color-text-muted, #64748b)">← away</text>
                      <text x={gaMidX + gaMaxBar} y={gaH - 1} textAnchor="middle" fontSize="7" fill="var(--color-text-muted, #64748b)">toward →</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      {gaBadge === "Aligned" ? "Suggestions move toward the estimated optimum direction." : gaBadge === "Mixed" ? "Some suggestions explore, others exploit the gradient." : "Suggestions move away from the gradient — exploring alternative regions."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Experiment Value Estimate (Batch 30) ── */}
              {(() => {
                if (!suggestions?.suggestions?.length || !campaign?.observations?.length || campaign.observations.length < 5) return null;
                const evSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (evSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const evObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (evObs.length < 5) return null;
                const evBestKpi = Math.max(...evObs.map((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey]));
                // for each suggestion, predict KPI via k=5 nearest neighbors
                const evK = Math.min(5, evObs.length);
                const evData = suggestions.suggestions.map((sug: Record<string, number>, idx: number) => {
                  const dists: { d: number; kpi: number }[] = [];
                  evObs.forEach((o: { parameters: Record<string, number>; kpi_values: Record<string, number> }) => {
                    let sum = 0;
                    evSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                      const range = (s.upper || 1) - (s.lower || 0);
                      sum += ((sug[s.name] - o.parameters[s.name]) / (range || 1)) ** 2;
                    });
                    dists.push({ d: Math.sqrt(sum), kpi: o.kpi_values[kpiKey] });
                  });
                  dists.sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, evK);
                  // inverse-distance weighted average
                  let evWSum = 0, evWTotal = 0;
                  neighbors.forEach(n => {
                    const w = 1 / (n.d + 0.001);
                    evWSum += w * n.kpi;
                    evWTotal += w;
                  });
                  const predicted = evWTotal > 0 ? evWSum / evWTotal : 0;
                  const delta = predicted - evBestKpi;
                  // also compute std of neighbors for uncertainty
                  const nMean = neighbors.reduce((s, n) => s + n.kpi, 0) / neighbors.length;
                  const nStd = Math.sqrt(neighbors.reduce((s, n) => s + (n.kpi - nMean) ** 2, 0) / neighbors.length);
                  return { idx: idx + 1, predicted, delta, uncertainty: nStd };
                });
                const evMaxDelta = Math.max(...evData.map((d: { delta: number }) => Math.abs(d.delta)), 0.001);
                const evAvgDelta = evData.reduce((s: number, d: { delta: number }) => s + d.delta, 0) / evData.length;
                const evBadge = evAvgDelta > -evMaxDelta * 0.1 ? "High Potential" : evAvgDelta > -evMaxDelta * 0.5 ? "Moderate" : "Low Upside";
                const evBadgeColor = evBadge === "High Potential" ? "var(--color-green, #22c55e)" : evBadge === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                const evW = 220, evBarH = 18, evGap = 6;
                const evH = evData.length * (evBarH + evGap) + 8;
                const evMidX = evW / 2;
                const evMaxBar = (evW - 50) / 2;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Calculator size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Experiment Value Estimate</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: evBadgeColor, color: "#fff" }}>{evBadge}</span>
                    </div>
                    <svg width={evW} height={evH} viewBox={`0 0 ${evW} ${evH}`} style={{ display: "block", width: "100%" }}>
                      {/* center = current best */}
                      <line x1={evMidX} y1={0} x2={evMidX} y2={evH - 4} stroke="var(--color-border, #e2e8f0)" strokeWidth="1" />
                      <text x={evMidX} y={evH - 1} textAnchor="middle" fontSize="7" fill="var(--color-text-muted, #64748b)">current best</text>
                      {evData.map((d: { idx: number; delta: number; uncertainty: number }, i: number) => {
                        const y = i * (evBarH + evGap) + 4;
                        const barLen = Math.abs(d.delta) / evMaxDelta * evMaxBar;
                        const barX = d.delta >= 0 ? evMidX : evMidX - barLen;
                        const color = d.delta >= 0 ? "var(--color-green, #22c55e)" : "var(--color-red, #ef4444)";
                        // uncertainty whisker
                        const uncLen = (d.uncertainty / evMaxDelta) * evMaxBar * 0.5;
                        const tipX = d.delta >= 0 ? evMidX + barLen : evMidX - barLen;
                        return (
                          <g key={d.idx}>
                            <text x="2" y={y + 13} fontSize="10" fontFamily="var(--font-mono)" fill="var(--color-text, #1e293b)">#{d.idx}</text>
                            <rect x={barX} y={y} width={Math.max(barLen, 2)} height={evBarH} rx="3" fill={color} opacity="0.6" />
                            {/* uncertainty whisker */}
                            <line x1={tipX - uncLen} y1={y + evBarH / 2} x2={tipX + uncLen} y2={y + evBarH / 2} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="1" />
                            <line x1={tipX - uncLen} y1={y + 4} x2={tipX - uncLen} y2={y + evBarH - 4} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="0.5" />
                            <line x1={tipX + uncLen} y1={y + 4} x2={tipX + uncLen} y2={y + evBarH - 4} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="0.5" />
                          </g>
                        );
                      })}
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      k-NN predicted Δ from best — whiskers show neighbor variance.
                    </div>
                  </div>
                );
              })()}

              {/* Batch Synergy */}
              {suggestions && suggestions.suggestions.length >= 2 && (() => {
                const bsParams = (campaign.spec?.parameters ?? []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (bsParams.length < 2) return null;
                const bsSuggs = suggestions.suggestions;
                // Normalize each suggestion parameter to [0,1]
                const bsNorm = bsSuggs.map((s: Record<string, number>) =>
                  bsParams.map((p: { name: string; lower?: number; upper?: number }) => {
                    const lo = p.lower ?? 0, hi = p.upper ?? 1, range = hi - lo || 1;
                    return ((s[p.name] ?? 0) - lo) / range;
                  })
                );
                // Compute pairwise angles between suggestion vectors (centered)
                const bsMean = bsParams.map((_: unknown, j: number) => bsNorm.reduce((a: number, r: number[]) => a + r[j], 0) / bsNorm.length);
                const bsCentered = bsNorm.map((r: number[]) => r.map((v: number, j: number) => v - bsMean[j]));
                // Compute minimum pairwise angle as synergy measure
                let bsMinCos = 1;
                for (let a = 0; a < bsCentered.length; a++) {
                  for (let b = a + 1; b < bsCentered.length; b++) {
                    let dot = 0, magA = 0, magB = 0;
                    for (let k = 0; k < bsCentered[a].length; k++) {
                      dot += bsCentered[a][k] * bsCentered[b][k];
                      magA += bsCentered[a][k] ** 2;
                      magB += bsCentered[b][k] ** 2;
                    }
                    const cos = (magA > 0 && magB > 0) ? Math.abs(dot) / (Math.sqrt(magA) * Math.sqrt(magB)) : 1;
                    if (cos < bsMinCos) bsMinCos = cos;
                  }
                }
                // Also compute average pairwise cosine similarity
                let bsCosSum = 0, bsCosCount = 0;
                for (let a = 0; a < bsCentered.length; a++) {
                  for (let b = a + 1; b < bsCentered.length; b++) {
                    let dot = 0, magA = 0, magB = 0;
                    for (let k = 0; k < bsCentered[a].length; k++) {
                      dot += bsCentered[a][k] * bsCentered[b][k];
                      magA += bsCentered[a][k] ** 2;
                      magB += bsCentered[b][k] ** 2;
                    }
                    const cos = (magA > 0 && magB > 0) ? Math.abs(dot) / (Math.sqrt(magA) * Math.sqrt(magB)) : 1;
                    bsCosSum += cos;
                    bsCosCount++;
                  }
                }
                const bsAvgCos = bsCosCount > 0 ? bsCosSum / bsCosCount : 1;
                const bsSynergy = 1 - bsAvgCos; // 1 = perfectly orthogonal, 0 = identical directions
                const bsBadge = bsSynergy > 0.6 ? "Synergistic" : bsSynergy > 0.3 ? "Moderate" : "Redundant";
                const bsColor = bsBadge === "Synergistic" ? "var(--color-primary)" : bsBadge === "Moderate" ? "#eab308" : "#ef4444";
                // Gauge visualization
                const bsGW = 180, bsGH = 100;
                const bsAngle = -180 + bsSynergy * 180;
                const bsRad = (bsAngle * Math.PI) / 180;
                const bsR = 70;
                const bsNx = bsGW / 2 + bsR * Math.cos(bsRad);
                const bsNy = bsGH - 10 + bsR * Math.sin(bsRad);
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <CircleDot size={16} style={{ color: "var(--color-primary)" }} />
                      <strong style={{ fontSize: "0.88rem" }}>Batch Synergy</strong>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "6px", background: bsBadge === "Synergistic" ? "var(--color-success-bg)" : bsBadge === "Moderate" ? "rgba(234,179,8,0.12)" : "rgba(239,68,68,0.1)", color: bsColor }}>{bsBadge}</span>
                    </div>
                    <svg width={bsGW} height={bsGH} viewBox={`0 0 ${bsGW} ${bsGH}`} style={{ display: "block", margin: "0 auto" }}>
                      <path d={`M ${bsGW / 2 - bsR} ${bsGH - 10} A ${bsR} ${bsR} 0 0 1 ${bsGW / 2 + bsR} ${bsGH - 10}`} fill="none" stroke="var(--color-border)" strokeWidth="10" strokeLinecap="round" />
                      <path d={`M ${bsGW / 2 - bsR} ${bsGH - 10} A ${bsR} ${bsR} 0 0 1 ${bsGW / 2 + bsR} ${bsGH - 10}`} fill="none" stroke={bsColor} strokeWidth="10" strokeLinecap="round" strokeDasharray={`${bsSynergy * Math.PI * bsR} ${Math.PI * bsR}`} />
                      <line x1={bsGW / 2} y1={bsGH - 10} x2={bsNx} y2={bsNy} stroke="var(--color-text)" strokeWidth="2" strokeLinecap="round" />
                      <circle cx={bsGW / 2} cy={bsGH - 10} r="4" fill="var(--color-text)" />
                      <text x={bsGW / 2} y={bsGH - 30} textAnchor="middle" fontSize="18" fontWeight="700" fill="var(--color-text)" fontFamily="var(--font-mono)">{(bsSynergy * 100).toFixed(0)}%</text>
                      <text x={bsGW / 2 - bsR - 2} y={bsGH - 2} textAnchor="end" fontSize="9" fill="var(--color-text-muted)">0%</text>
                      <text x={bsGW / 2 + bsR + 2} y={bsGH - 2} textAnchor="start" fontSize="9" fill="var(--color-text-muted)">100%</text>
                    </svg>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {bsBadge === "Synergistic" ? "Suggestions explore orthogonal directions — maximum information gain." : bsBadge === "Moderate" ? "Some directional overlap — reasonable coverage." : "Suggestions point in similar directions — consider diversifying."}
                    </div>
                  </div>
                );
              })()}

              {/* Empty State */}
              {!suggestions && !loadingSuggestions && (
                <div className="suggestions-empty">
                  <div className="suggestions-empty-icon">
                    <Beaker size={32} />
                  </div>
                  <h3>Ready to suggest your next experiments</h3>
                  <p>
                    The optimization engine will analyze your {campaign.total_trials} past experiments
                    and suggest the most promising parameter configurations to try next.
                  </p>
                  <div className="suggestions-empty-info">
                    <Info size={14} />
                    <span>
                      Each suggestion includes a confidence score and an explanation of why
                      it was chosen, so you can make informed decisions.
                    </span>
                  </div>
                </div>
              )}

              {/* Loading Skeleton */}
              {loadingSuggestions && !suggestions && (
                <div className="suggestions-grid">
                  {[1, 2, 3, 4, 5].map((i) => (
                    <div key={i} className="suggestion-skeleton">
                      <div className="skeleton-line skeleton-line-short" />
                      <div className="skeleton-line skeleton-line-medium" />
                      <div className="skeleton-line skeleton-line-long" />
                      <div className="skeleton-line skeleton-line-medium" />
                    </div>
                  ))}
                </div>
              )}

              {/* Suggestion Cards */}
              {suggestions && (
                <div className="suggestions-grid">
                  {suggestions.suggestions.map((sug, i) => {
                    const diversity = computeDiversityScore(sug);
                    return (
                      <div key={i} className={`suggestion-card-wrapper ${selectedSuggestions.has(i) ? "suggestion-selected" : ""}`}>
                        <div className="suggestion-select-check" onClick={(e) => { e.stopPropagation(); toggleSuggestionSelect(i); }}>
                          <CheckSquare
                            size={14}
                            className={selectedSuggestions.has(i) ? "sug-check-active" : "sug-check-idle"}
                            fill={selectedSuggestions.has(i) ? "currentColor" : "none"}
                          />
                        </div>
                        {diversity !== null && (
                          <div
                            className={`diversity-badge ${diversity > 0.5 ? "diversity-high" : diversity > 0.25 ? "diversity-mid" : "diversity-low"}`}
                            title={`Diversity: ${(diversity * 100).toFixed(0)}% — ${diversity > 0.5 ? "Highly exploratory" : diversity > 0.25 ? "Moderately novel" : "Close to recent trials"}`}
                          >
                            <Activity size={11} />
                            {diversity > 0.5 ? "Explore" : diversity > 0.25 ? "Balanced" : "Refine"}
                          </div>
                        )}
                        <RealSuggestionCard
                          index={i + 1}
                          suggestion={sug}
                          parameterSpecs={
                            campaign.spec?.parameters ??
                            Object.keys(sug).map((name) => ({
                              name,
                              type: "continuous" as const,
                              lower: 0,
                              upper: 1,
                            }))
                          }
                          objectiveName={campaign.objective_names?.[0] ?? "Objective"}
                          predictedValue={suggestions.predicted_values?.[i]}
                          predictedUncertainty={suggestions.predicted_uncertainties?.[i]}
                          phase={suggestions.phase}
                          bestParams={bestResult?.parameters}
                          bestObjective={bestResult ? Object.values(bestResult.kpis)[0] : undefined}
                          onReject={() => handleRejectSuggestion(sug, i + 1)}
                        />
                      </div>
                    );
                  })}
                </div>
              )}

              {/* Rejected Suggestions Stack */}
              {rejectedSuggestions.length > 0 && (
                <div className="rejected-stack">
                  <button
                    className="rejected-stack-toggle"
                    onClick={() => setShowRejectedStack(s => !s)}
                  >
                    <Undo2 size={14} />
                    <span>Recently Rejected ({rejectedSuggestions.length})</span>
                    {showRejectedStack ? <ArrowUp size={14} /> : <ArrowDown size={14} />}
                  </button>
                  {showRejectedStack && (
                    <div className="rejected-stack-list">
                      {rejectedSuggestions.map((r, idx) => {
                        const paramEntries = Object.entries(r.suggestion).slice(0, 4);
                        return (
                          <div key={r.timestamp} className="rejected-item">
                            <div className="rejected-item-header">
                              <span className="rejected-item-index">#{r.index}</span>
                              <span className="rejected-item-time">
                                {new Date(r.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
                              </span>
                              <button
                                className="btn btn-sm btn-secondary rejected-reconsider-btn"
                                onClick={() => handleReconsider(idx)}
                              >
                                <Undo2 size={12} /> Reconsider
                              </button>
                            </div>
                            <div className="rejected-item-params">
                              {paramEntries.map(([k, v]) => (
                                <span key={k} className="rejected-param">
                                  <span className="rejected-param-name">{k}</span>
                                  <span className="mono">{typeof v === "number" ? v.toFixed(3) : String(v)}</span>
                                </span>
                              ))}
                              {Object.keys(r.suggestion).length > 4 && (
                                <span className="rejected-param-more">+{Object.keys(r.suggestion).length - 4} more</span>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}

              {/* Batch Planner Bar */}
              {suggestions && selectedSuggestions.size > 0 && (
                <div className="batch-planner-bar">
                  <div className="batch-planner-left">
                    <Package size={15} />
                    <span className="batch-planner-count">{selectedSuggestions.size} selected</span>
                    {(() => {
                      if (!suggestions || selectedSuggestions.size < 2) return null;
                      const selected = suggestions.suggestions.filter((_, i) => selectedSuggestions.has(i));
                      const specs = campaign.spec?.parameters?.filter(s => s.type === "continuous" && s.lower != null && s.upper != null) ?? [];
                      if (specs.length === 0 || selected.length < 2) return null;
                      let totalDist = 0;
                      let pairs = 0;
                      for (let a = 0; a < selected.length; a++) {
                        for (let b = a + 1; b < selected.length; b++) {
                          let sumSq = 0;
                          for (const spec of specs) {
                            const r = (spec.upper! - spec.lower!) || 1;
                            sumSq += (((selected[a][spec.name] ?? 0) - (selected[b][spec.name] ?? 0)) / r) ** 2;
                          }
                          totalDist += Math.sqrt(sumSq / specs.length);
                          pairs++;
                        }
                      }
                      const batchDiversity = pairs > 0 ? totalDist / pairs : 0;
                      return (
                        <span className="batch-diversity-pill">
                          <Activity size={11} />
                          Batch diversity: {(batchDiversity * 100).toFixed(0)}%
                        </span>
                      );
                    })()}
                  </div>
                  <div className="batch-planner-right">
                    <button className="btn btn-sm btn-secondary" onClick={handleExportSelectedCSV}>
                      <FileDown size={13} /> Export CSV
                    </button>
                    <button className="btn btn-sm btn-secondary" onClick={() => setSelectedSuggestions(new Set())}>
                      Clear
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}

          {activeTab === "insights" && (
            <div className="tab-panel">
              <InsightsPanel campaignId={id} />
            </div>
          )}

          {activeTab === "history" && (
            <div className="tab-panel">
              {/* Trial Outcome Distribution */}
              {trials.length >= 5 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const vals = trials.map(t => Number(t.kpis[objKey]) || 0).sort((a, b) => a - b);
                const minV = vals[0];
                const maxV = vals[vals.length - 1];
                const range = maxV - minV;
                if (range === 0) return null;
                const nBins = Math.min(20, Math.max(8, Math.ceil(Math.sqrt(vals.length))));
                const binWidth = range / nBins;
                const bins = Array.from({ length: nBins }, (_, i) => ({
                  low: minV + i * binWidth,
                  high: minV + (i + 1) * binWidth,
                  count: 0,
                }));
                vals.forEach(v => {
                  const bi = Math.min(Math.floor((v - minV) / binWidth), nBins - 1);
                  bins[bi].count++;
                });
                const maxCount = Math.max(...bins.map(b => b.count));
                const q1 = vals[Math.floor(vals.length * 0.25)];
                const median = vals[Math.floor(vals.length * 0.5)];
                const q3 = vals[Math.floor(vals.length * 0.75)];
                const bestV = vals[0]; // sorted ascending, best is min for minimize
                const W = 460, H = 120, padL = 4, padR = 4, padT = 8, padB = 24;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const barW = plotW / nBins - 1;
                const qX = (v: number) => padL + ((v - minV) / range) * plotW;

                return (
                  <div className="card histogram-card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }}>
                      <BarChart3 size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Outcome Distribution</h2>
                      <span style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginLeft: "auto" }}>
                        {objKey} &middot; {trials.length} trials
                      </span>
                    </div>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Bins */}
                      {bins.map((b, i) => {
                        const x = padL + (i / nBins) * plotW;
                        const barH = maxCount > 0 ? (b.count / maxCount) * plotH : 0;
                        const pctile = (b.low + b.high) / 2;
                        const color = pctile <= q1 ? "rgba(34,197,94,0.6)" : pctile >= q3 ? "rgba(239,68,68,0.5)" : "rgba(59,130,246,0.4)";
                        return (
                          <g key={i}>
                            <rect x={x} y={padT + plotH - barH} width={barW} height={barH} rx="2" fill={color}>
                              <title>{`${b.low.toFixed(4)} – ${b.high.toFixed(4)}: ${b.count} trials`}</title>
                            </rect>
                          </g>
                        );
                      })}
                      {/* Quartile markers */}
                      {[
                        { v: q1, label: "Q1", color: "var(--color-text-muted)" },
                        { v: median, label: "Med", color: "var(--color-primary)" },
                        { v: q3, label: "Q3", color: "var(--color-text-muted)" },
                        { v: bestV, label: "Best", color: "#22c55e" },
                      ].map(({ v, label, color }) => (
                        <g key={label}>
                          <line x1={qX(v)} y1={padT} x2={qX(v)} y2={padT + plotH + 4} stroke={color} strokeWidth="1" strokeDasharray="3,2" />
                          <text x={qX(v)} y={H - 4} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill={color} fontWeight={label === "Best" ? 600 : 400}>
                            {label}
                          </text>
                        </g>
                      ))}
                      {/* X-axis labels */}
                      <text x={padL} y={H - 4} textAnchor="start" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                        {minV.toFixed(3)}
                      </text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                        {maxV.toFixed(3)}
                      </text>
                    </svg>
                  </div>
                );
              })()}

              {/* Exploration vs Exploitation Timeline */}
              {trials.length >= 8 && (() => {
                const chrono = [...trials].sort((a, b) => a.iteration - b.iteration);
                const paramNames = Object.keys(chrono[0].parameters);
                const objKey = Object.keys(chrono[0].kpis)[0];

                // Classify each trial as explore or exploit
                const classifications: Array<{ iteration: number; score: number; label: "explore" | "exploit" }> = [];
                let runningBestIdx = 0;
                let runningBestVal = Number(chrono[0].kpis[objKey]) || 0;

                for (let i = 0; i < chrono.length; i++) {
                  const curVal = Number(chrono[i].kpis[objKey]) || 0;
                  if (curVal < runningBestVal) {
                    runningBestVal = curVal;
                    runningBestIdx = i;
                  }
                  if (i === 0) {
                    classifications.push({ iteration: chrono[i].iteration, score: 1, label: "explore" });
                    continue;
                  }

                  // Novelty: min normalized distance to all previous trials
                  let minDist = Infinity;
                  for (let j = 0; j < i; j++) {
                    let dist = 0;
                    for (const p of paramNames) {
                      const d = (Number(chrono[i].parameters[p]) || 0) - (Number(chrono[j].parameters[p]) || 0);
                      dist += d * d;
                    }
                    minDist = Math.min(minDist, Math.sqrt(dist));
                  }
                  // Distance to best-so-far
                  let bestDist = 0;
                  for (const p of paramNames) {
                    const d = (Number(chrono[i].parameters[p]) || 0) - (Number(chrono[runningBestIdx].parameters[p]) || 0);
                    bestDist += d * d;
                  }
                  bestDist = Math.sqrt(bestDist);

                  // Exploration score: high novelty & far from best = explore; low novelty & near best = exploit
                  const noveltyNorm = Math.min(minDist / (Math.sqrt(paramNames.length) * 0.3 + 0.01), 1);
                  const bestDistNorm = Math.min(bestDist / (Math.sqrt(paramNames.length) * 0.3 + 0.01), 1);
                  const score = 0.5 * noveltyNorm + 0.5 * bestDistNorm;
                  classifications.push({
                    iteration: chrono[i].iteration,
                    score,
                    label: score > 0.45 ? "explore" : "exploit",
                  });
                }

                const exploreCount = classifications.filter(c => c.label === "explore").length;
                const exploitCount = classifications.length - exploreCount;
                const explorePct = ((exploreCount / classifications.length) * 100).toFixed(0);

                const W = 460, H = 80, padL = 4, padR = 4, padT = 8, padB = 20;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const barW = Math.max(1, plotW / classifications.length - 0.5);

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Shuffle size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Explore vs Exploit</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        {explorePct}% explore · {100 - Number(explorePct)}% exploit
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 6px" }}>
                      Each bar represents a trial. Blue = exploring new regions, orange = refining near known good results.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {classifications.map((c, i) => {
                        const x = padL + (i / classifications.length) * plotW;
                        const barH = padT + (1 - c.score) * plotH;
                        const color = c.label === "explore" ? "rgba(59,130,246,0.7)" : "rgba(249,115,22,0.65)";
                        return (
                          <rect key={i} x={x} y={barH} width={barW} height={padT + plotH - barH} fill={color} rx="1">
                            <title>Trial #{c.iteration}: {c.label} (score {c.score.toFixed(2)})</title>
                          </rect>
                        );
                      })}
                      {/* Threshold line */}
                      <line x1={padL} y1={padT + 0.55 * plotH} x2={padL + plotW} y2={padT + 0.55 * plotH}
                        stroke="var(--color-text-muted)" strokeWidth="0.5" strokeDasharray="4,3" opacity="0.5" />
                      {/* X labels */}
                      <text x={padL} y={H - 4} fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">0</text>
                      <text x={padL + plotW} y={H - 4} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">{classifications.length}</text>
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">Trial</text>
                    </svg>
                    <div className="efficiency-legend" style={{ maxWidth: `${W}px` }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(59,130,246,0.7)", marginRight: 4, verticalAlign: "middle" }} />Explore ({exploreCount})</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: "rgba(249,115,22,0.65)", marginRight: 4, verticalAlign: "middle" }} />Exploit ({exploitCount})</span>
                    </div>
                  </div>
                );
              })()}

              {/* Trial Clustering Visualization */}
              {trials.length >= 12 && (() => {
                const paramNames = Object.keys(trials[0].parameters);
                if (paramNames.length < 2) return null;
                const objKey = Object.keys(trials[0].kpis)[0];

                // Normalize parameter values to [0,1]
                const mins = paramNames.map(p => Math.min(...trials.map(t => Number(t.parameters[p]) || 0)));
                const maxs = paramNames.map(p => Math.max(...trials.map(t => Number(t.parameters[p]) || 0)));
                const ranges = paramNames.map((_, i) => maxs[i] - mins[i] || 1);
                const normalized = trials.map(t =>
                  paramNames.map((p, i) => ((Number(t.parameters[p]) || 0) - mins[i]) / ranges[i])
                );

                // Simple k-means clustering (k=3)
                const k = Math.min(3, Math.floor(trials.length / 4));
                // Initialize centroids via spread
                const centroids: number[][] = [];
                for (let c = 0; c < k; c++) {
                  const idx = Math.floor((c / k) * normalized.length);
                  centroids.push([...normalized[idx]]);
                }

                // Run 15 iterations of k-means
                const assignments = new Array(trials.length).fill(0);
                for (let iter = 0; iter < 15; iter++) {
                  // Assign
                  for (let i = 0; i < normalized.length; i++) {
                    let bestDist = Infinity;
                    for (let c = 0; c < k; c++) {
                      let dist = 0;
                      for (let d = 0; d < paramNames.length; d++) {
                        dist += (normalized[i][d] - centroids[c][d]) ** 2;
                      }
                      if (dist < bestDist) { bestDist = dist; assignments[i] = c; }
                    }
                  }
                  // Update centroids
                  for (let c = 0; c < k; c++) {
                    const members = normalized.filter((_, i) => assignments[i] === c);
                    if (members.length === 0) continue;
                    for (let d = 0; d < paramNames.length; d++) {
                      centroids[c][d] = members.reduce((a, m) => a + m[d], 0) / members.length;
                    }
                  }
                }

                // Cluster stats
                const clusterColors = ["rgba(59,130,246,0.7)", "rgba(239,68,68,0.65)", "rgba(34,197,94,0.7)"];
                const clusterLabels = ["Cluster A", "Cluster B", "Cluster C"];
                const clusterStats = Array.from({ length: k }, (_, c) => {
                  const members = trials.filter((_, i) => assignments[i] === c);
                  const objVals = members.map(t => Number(t.kpis[objKey]) || 0);
                  return {
                    count: members.length,
                    bestObj: objVals.length > 0 ? Math.min(...objVals) : Infinity,
                    meanObj: objVals.length > 0 ? objVals.reduce((a, b) => a + b, 0) / objVals.length : 0,
                  };
                });

                // Plot using first two parameters
                const xParam = paramNames[0];
                const yParam = paramNames[1];
                const W = 460, H = 200, padL = 50, padR = 12, padT = 10, padB = 32;
                const plotW = W - padL - padR;
                const plotH = H - padT - padB;
                const xVals = trials.map(t => Number(t.parameters[xParam]) || 0);
                const yVals = trials.map(t => Number(t.parameters[yParam]) || 0);
                const xMin = Math.min(...xVals), xMax = Math.max(...xVals);
                const yMin = Math.min(...yVals), yMax = Math.max(...yVals);
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                const sx = (v: number) => padL + ((v - xMin) / xRange) * plotW;
                const sy = (v: number) => padT + (1 - (v - yMin) / yRange) * plotH;

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <GitBranch size={16} style={{ color: "var(--color-primary)" }} />
                      <h2 style={{ margin: 0 }}>Trial Clusters</h2>
                      <span style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginLeft: "auto", fontFamily: "var(--font-mono)" }}>
                        k={k} · {paramNames.length}D
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      K-means clustering of trials in parameter space. Colors indicate cluster membership, diamonds mark centroids.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Grid */}
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={f}>
                          <line x1={padL} y1={padT + f * plotH} x2={padL + plotW} y2={padT + f * plotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                          <line x1={padL + f * plotW} y1={padT} x2={padL + f * plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                        </Fragment>
                      ))}
                      {/* Data points */}
                      {trials.map((t, i) => (
                        <circle
                          key={i}
                          cx={sx(xVals[i])}
                          cy={sy(yVals[i])}
                          r="3.5"
                          fill={clusterColors[assignments[i] % k]}
                          stroke="white"
                          strokeWidth="0.5"
                          opacity="0.8"
                        >
                          <title>Trial #{t.iteration}: {clusterLabels[assignments[i]]} · {objKey}={Number(t.kpis[objKey]).toFixed(4)}</title>
                        </circle>
                      ))}
                      {/* Centroids as diamonds */}
                      {centroids.map((c, ci) => {
                        const cx = padL + c[0] * plotW;
                        const cy = padT + (1 - c[1]) * plotH;
                        const s = 6;
                        return (
                          <polygon
                            key={ci}
                            points={`${cx},${cy - s} ${cx + s},${cy} ${cx},${cy + s} ${cx - s},${cy}`}
                            fill={clusterColors[ci % k]}
                            stroke="white"
                            strokeWidth="1.5"
                          >
                            <title>{clusterLabels[ci]}: {clusterStats[ci].count} trials, best={clusterStats[ci].bestObj.toFixed(4)}</title>
                          </polygon>
                        );
                      })}
                      {/* Axes */}
                      <line x1={padL} y1={padT} x2={padL} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      <line x1={padL} y1={padT + plotH} x2={padL + plotW} y2={padT + plotH} stroke="var(--color-border)" strokeWidth="1" />
                      {/* Axis labels */}
                      {[0, 0.5, 1].map(f => (
                        <Fragment key={`a${f}`}>
                          <text x={padL + f * plotW} y={H - 8} textAnchor="middle" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(xMin + f * xRange).toFixed(2)}
                          </text>
                          <text x={padL - 4} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fill="var(--color-text-muted)">
                            {(yMin + f * yRange).toFixed(2)}
                          </text>
                        </Fragment>
                      ))}
                      <text x={padL + plotW / 2} y={H - 0} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)">{xParam}</text>
                      <text x={10} y={padT + plotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" transform={`rotate(-90, 10, ${padT + plotH / 2})`}>{yParam}</text>
                    </svg>
                    {/* Cluster summary */}
                    <div style={{ display: "flex", gap: "16px", flexWrap: "wrap", marginTop: "8px" }}>
                      {clusterStats.map((cs, ci) => (
                        <div key={ci} style={{ display: "flex", alignItems: "center", gap: "6px", fontSize: "0.78rem" }}>
                          <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, background: clusterColors[ci % k] }} />
                          <span style={{ fontWeight: 500 }}>{clusterLabels[ci]}</span>
                          <span style={{ color: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>
                            n={cs.count} · best={cs.bestObj.toFixed(4)} · avg={cs.meanObj.toFixed(4)}
                          </span>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Fidelity-Aware Trial Timeline */}
              {trials.length >= 8 && (() => {
                const ftObjKey = Object.keys(trials[0].kpis)[0];
                const ftObjVals = trials.map(t => Number(t.kpis[ftObjKey]) || 0);
                const ftMinObj = Math.min(...ftObjVals), ftMaxObj = Math.max(...ftObjVals);
                const ftObjRange = ftMaxObj - ftMinObj || 1;
                // Infer fidelity from trial position and objective variance
                // Heuristic: early trials = low fidelity (exploration), mid = medium, late = high (exploitation)
                const ftTiers = trials.map((_t, i) => {
                  if (i < trials.length * 0.3) return "low";
                  if (i < trials.length * 0.7) return "medium";
                  return "high";
                });

                const tierConfig: Record<string, { color: string; label: string; order: number }> = {
                  low: { color: "rgba(147,197,253,0.7)", label: "Low Fidelity", order: 0 },
                  medium: { color: "rgba(59,130,246,0.7)", label: "Medium Fidelity", order: 1 },
                  high: { color: "rgba(30,64,175,0.85)", label: "High Fidelity", order: 2 },
                };

                const W = 420, H = 200, padL = 52, padR = 16, padT = 28, padB = 32;
                const plotW = W - padL - padR, plotH = H - padT - padB;
                const n = trials.length;

                const ftToX = (i: number) => padL + (i / Math.max(n - 1, 1)) * plotW;
                const ftToY = (v: number) => padT + (1 - (v - ftMinObj) / ftObjRange) * plotH;

                // Running best line
                let ftRunBest = ftObjVals[0];
                const ftBestLine = ftObjVals.map(v => { ftRunBest = Math.min(ftRunBest, v); return ftRunBest; });
                const ftBestPath = ftBestLine.map((v, i) => `${i === 0 ? "M" : "L"}${ftToX(i).toFixed(1)},${ftToY(v).toFixed(1)}`).join(" ");

                const tierCounts = Object.entries(tierConfig).map(([k, cfg]) => ({
                  ...cfg, key: k, count: ftTiers.filter(t => t === k).length,
                })).filter(tc => tc.count > 0).sort((a, b) => a.order - b.order);

                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }}>
                      <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                        <Layers size={16} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Fidelity Timeline</h2>
                      </div>
                      <span style={{ fontSize: "0.75rem", fontFamily: "var(--font-mono)", color: "var(--color-text-muted)" }}>
                        {tierCounts.map(tc => `${tc.count} ${tc.key}`).join(" · ")}
                      </span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Trial performance colored by inferred fidelity level. Bold line tracks the running best.
                    </p>
                    <svg width={W} height={H} style={{ display: "block", width: "100%", maxWidth: `${W}px` }}>
                      {/* Grid */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => (
                        <Fragment key={f}>
                          <line x1={padL} y1={padT + (1 - f) * plotH} x2={padL + plotW} y2={padT + (1 - f) * plotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="2,3" />
                          <text x={padL - 6} y={padT + (1 - f) * plotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                            {(ftMinObj + f * ftObjRange).toFixed(2)}
                          </text>
                        </Fragment>
                      ))}
                      {/* X-axis */}
                      <text x={padL + plotW / 2} y={H - 4} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)">Trial Index</text>
                      {/* Running best line */}
                      <path d={ftBestPath} fill="none" stroke="var(--color-primary)" strokeWidth="1.5" strokeDasharray="4,2" opacity="0.5" />
                      {/* Data points */}
                      {trials.map((t, i) => {
                        const tier = ftTiers[i];
                        const cfg = tierConfig[tier] || tierConfig.medium;
                        return (
                          <circle
                            key={i}
                            cx={ftToX(i)}
                            cy={ftToY(ftObjVals[i])}
                            r={tier === "high" ? 4 : tier === "medium" ? 3.5 : 3}
                            fill={cfg.color}
                            stroke="white"
                            strokeWidth="0.5"
                            opacity="0.85"
                          >
                            <title>Trial #{t.iteration}: {ftObjKey}={ftObjVals[i].toFixed(4)} ({tier} fidelity)</title>
                          </circle>
                        );
                      })}
                    </svg>
                    {/* Legend */}
                    <div style={{ display: "flex", gap: "14px", marginTop: "4px" }}>
                      {tierCounts.map(tc => (
                        <span key={tc.key} className="efficiency-legend-item">
                          <span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: tc.color, marginRight: 4, verticalAlign: "middle" }} />
                          {tc.label}
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Trial Diversity Timeline */}
              {trials.length >= 10 && (() => {
                // Measure pairwise diversity over sliding windows
                const tdObjKey = Object.keys(trials[0].kpis)[0];
                const pKeys = Object.keys(trials[0].parameters);
                const windowSize = Math.max(3, Math.floor(trials.length / 8));
                const tdWindows: { start: number; end: number; diversity: number; meanObj: number }[] = [];

                // Normalize parameter values for distance calculation
                const tdParamRanges = pKeys.map(k => {
                  const vals = trials.map(t => Number(t.parameters[k]) || 0);
                  const min = Math.min(...vals);
                  const max = Math.max(...vals);
                  return { k, min, range: max - min || 1 };
                });

                for (let i = 0; i <= trials.length - windowSize; i += Math.max(1, Math.floor(windowSize / 2))) {
                  const windowTrials = trials.slice(i, i + windowSize);
                  // Average pairwise distance (normalized)
                  let totalDist = 0, pairs = 0;
                  for (let a = 0; a < windowTrials.length; a++) {
                    for (let b = a + 1; b < windowTrials.length; b++) {
                      let dist = 0;
                      for (const pr of tdParamRanges) {
                        const diff = ((Number(windowTrials[a].parameters[pr.k]) || 0) - (Number(windowTrials[b].parameters[pr.k]) || 0)) / pr.range;
                        dist += diff * diff;
                      }
                      totalDist += Math.sqrt(dist / pKeys.length);
                      pairs++;
                    }
                  }
                  const diversity = pairs > 0 ? totalDist / pairs : 0;
                  const meanObj = windowTrials.reduce((s, t) => s + (Number(t.kpis[tdObjKey]) || 0), 0) / windowTrials.length;
                  tdWindows.push({ start: i, end: i + windowSize - 1, diversity, meanObj });
                }

                if (tdWindows.length < 3) return null;

                const tdW = 440, tdH = 140, tdPadL = 44, tdPadR = 16, tdPadT = 16, tdPadB = 28;
                const tdPlotW = tdW - tdPadL - tdPadR;
                const tdPlotH = tdH - tdPadT - tdPadB;
                const tdDivs = tdWindows.map(w => w.diversity);
                const tdMaxDiv = Math.max(...tdDivs);
                const tdMinDiv = Math.min(...tdDivs);
                const tdDivRange = tdMaxDiv - tdMinDiv || 1;

                const toTdX = (i: number) => tdPadL + (i / (tdWindows.length - 1)) * tdPlotW;
                const toTdY = (d: number) => tdPadT + tdPlotH - ((d - tdMinDiv) / tdDivRange) * tdPlotH;

                const tdLinePath = tdWindows.map((w, i) => `${i === 0 ? "M" : "L"}${toTdX(i).toFixed(1)},${toTdY(w.diversity).toFixed(1)}`).join(" ");
                const tdAreaPath = `${tdLinePath} L${toTdX(tdWindows.length - 1)},${tdPadT + tdPlotH} L${tdPadL},${tdPadT + tdPlotH} Z`;

                // Detect exploration vs exploitation phases
                const tdMidDiv = (tdMaxDiv + tdMinDiv) / 2;
                const explorationPct = (tdWindows.filter(w => w.diversity > tdMidDiv).length / tdWindows.length * 100);

                // Trend: compare first vs last third
                const thirdN = Math.max(1, Math.floor(tdWindows.length / 3));
                const earlyDiv = tdWindows.slice(0, thirdN).reduce((s, w) => s + w.diversity, 0) / thirdN;
                const lateDiv = tdWindows.slice(-thirdN).reduce((s, w) => s + w.diversity, 0) / thirdN;
                const divTrend = lateDiv > earlyDiv * 1.05 ? "expanding" : lateDiv < earlyDiv * 0.95 ? "contracting" : "stable";
                const divTrendColor = divTrend === "expanding" ? "var(--color-blue)" : divTrend === "contracting" ? "rgba(234,179,8,0.8)" : "var(--color-text-muted)";

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Layers size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Trial Diversity Timeline</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Pairwise parameter diversity across sliding windows of {windowSize} trials.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", color: divTrendColor, borderColor: divTrendColor }}>
                        {divTrend === "expanding" ? "↑" : divTrend === "contracting" ? "↓" : "→"} {divTrend}
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={tdW} height={tdH} viewBox={`0 0 ${tdW} ${tdH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Grid */}
                        {[0, 0.25, 0.5, 0.75, 1].map(f => (
                          <line key={f} x1={tdPadL} y1={tdPadT + (1 - f) * tdPlotH} x2={tdPadL + tdPlotW} y2={tdPadT + (1 - f) * tdPlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                        ))}
                        {/* Area fill */}
                        <path d={tdAreaPath} fill="rgba(99,102,241,0.12)" />
                        {/* Line */}
                        <path d={tdLinePath} fill="none" stroke="rgba(99,102,241,0.7)" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                        {/* Midline (exploration threshold) */}
                        <line x1={tdPadL} y1={toTdY(tdMidDiv)} x2={tdPadL + tdPlotW} y2={toTdY(tdMidDiv)} stroke="var(--color-text-muted)" strokeWidth={0.8} strokeDasharray="4,3" opacity={0.4} />
                        <text x={tdPadL + tdPlotW + 2} y={toTdY(tdMidDiv) + 3} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">mid</text>
                        {/* Window dots */}
                        {tdWindows.map((w, i) => (
                          <circle key={i} cx={toTdX(i)} cy={toTdY(w.diversity)} r={2.5} fill={w.diversity > tdMidDiv ? "rgba(99,102,241,0.8)" : "rgba(234,179,8,0.7)"} />
                        ))}
                        {/* Axis labels */}
                        <text x={tdPadL + tdPlotW / 2} y={tdH - 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          Window
                        </text>
                        <text x={8} y={tdPadT + tdPlotH / 2} textAnchor="middle" fontSize="10" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" transform={`rotate(-90,8,${tdPadT + tdPlotH / 2})`}>
                          Diversity
                        </text>
                        {/* Y-axis ticks */}
                        {[0, 0.5, 1].map(f => (
                          <text key={f} x={tdPadL - 4} y={tdPadT + (1 - f) * tdPlotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                            {(tdMinDiv + f * tdDivRange).toFixed(2)}
                          </text>
                        ))}
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(99,102,241,0.8)", marginRight: 4, verticalAlign: "middle" }} />Exploring</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: "rgba(234,179,8,0.7)", marginRight: 4, verticalAlign: "middle" }} />Exploiting</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.78rem", color: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>
                        {explorationPct.toFixed(0)}% exploring windows
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Parameter Lock-In Detector */}
              {trials.length >= 15 && (() => {
                const liSpecs = campaign.spec?.parameters || [];
                const liContSpecs = liSpecs.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                if (liContSpecs.length === 0) return null;

                const liWinSize = Math.max(5, Math.floor(trials.length / 8));
                const liWindows: { start: number; end: number }[] = [];
                for (let i = 0; i <= trials.length - liWinSize; i += Math.max(1, Math.floor(liWinSize / 2))) {
                  liWindows.push({ start: i, end: i + liWinSize - 1 });
                }
                if (liWindows.length < 3) return null;

                // For each parameter, compute range spread in each window (normalized to [0,1])
                const liData = liContSpecs.map((s: { name: string; type: string; lower?: number; upper?: number }) => {
                  const fullRange = (s.upper ?? 1) - (s.lower ?? 0) || 1;
                  const windowSpreads = liWindows.map(w => {
                    const vals = trials.slice(w.start, w.end + 1).map(t => Number(t.parameters[s.name]) || 0);
                    const min = Math.min(...vals);
                    const max = Math.max(...vals);
                    return (max - min) / fullRange;
                  });
                  // Lock-in detected if late spread < 30% of early spread
                  const earlyAvg = windowSpreads.slice(0, Math.ceil(windowSpreads.length / 3)).reduce((a, b) => a + b, 0) / Math.ceil(windowSpreads.length / 3);
                  const lateAvg = windowSpreads.slice(-Math.ceil(windowSpreads.length / 3)).reduce((a, b) => a + b, 0) / Math.ceil(windowSpreads.length / 3);
                  const locked = earlyAvg > 0.05 && lateAvg < earlyAvg * 0.3;
                  return { name: s.name, windowSpreads, earlyAvg, lateAvg, locked };
                });

                const lockedCount = liData.filter(d => d.locked).length;
                const liW = 440, liH = 130, liPadL = 80, liPadR = 16, liPadT = 8, liPadB = 24;
                const liPlotW = liW - liPadL - liPadR;
                const liPlotH = liH - liPadT - liPadB;
                const rowH = liPlotH / liData.length;

                // Color palette for parameters
                const liColors = ["rgba(59,130,246,0.6)", "rgba(34,197,94,0.6)", "rgba(234,179,8,0.6)", "rgba(239,68,68,0.5)", "rgba(168,85,247,0.5)", "rgba(236,72,153,0.5)", "rgba(20,184,166,0.5)", "rgba(249,115,22,0.5)"];

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <TrendingDown size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Parameter Lock-In Detector</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Sampling range evolution per parameter. Narrowing = potential premature convergence.
                        </p>
                      </div>
                      {lockedCount > 0 && (
                        <span className="findings-badge" style={{ marginLeft: "auto", color: "rgba(239,68,68,0.8)", borderColor: "rgba(239,68,68,0.3)" }}>
                          {lockedCount} locked
                        </span>
                      )}
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={liW} height={liH} viewBox={`0 0 ${liW} ${liH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Row backgrounds and parameter names */}
                        {liData.map((d, pi) => (
                          <g key={pi}>
                            {pi % 2 === 0 && (
                              <rect x={liPadL} y={liPadT + pi * rowH} width={liPlotW} height={rowH} fill="var(--color-border)" opacity={0.2} />
                            )}
                            <text x={liPadL - 6} y={liPadT + pi * rowH + rowH / 2 + 3} textAnchor="end" fontSize="9" fontFamily="var(--font-mono)" fontWeight={d.locked ? 700 : 400} fill={d.locked ? "rgba(239,68,68,0.8)" : "var(--color-text-muted)"}>
                              {d.name.length > 10 ? d.name.slice(0, 9) + "…" : d.name}
                              {d.locked ? " ⚠" : ""}
                            </text>
                          </g>
                        ))}
                        {/* Stream bands - spread for each parameter across windows */}
                        {liData.map((d, pi) => {
                          const centerY = liPadT + pi * rowH + rowH / 2;
                          const maxSpread = Math.max(...d.windowSpreads, 0.01);
                          const halfH = (rowH * 0.4);
                          const topPath = d.windowSpreads.map((sp, wi) => {
                            const x = liPadL + (wi / (liWindows.length - 1)) * liPlotW;
                            const y = centerY - (sp / maxSpread) * halfH;
                            return `${wi === 0 ? "M" : "L"}${x.toFixed(1)},${y.toFixed(1)}`;
                          }).join(" ");
                          const bottomPath = d.windowSpreads.map((_sp, wi) => {
                            const x = liPadL + ((liWindows.length - 1 - wi) / (liWindows.length - 1)) * liPlotW;
                            const y = centerY + (d.windowSpreads[liWindows.length - 1 - wi] / maxSpread) * halfH;
                            return `L${x.toFixed(1)},${y.toFixed(1)}`;
                          }).join(" ");
                          return (
                            <path key={pi} d={`${topPath} ${bottomPath} Z`} fill={liColors[pi % liColors.length]} opacity={0.7} />
                          );
                        })}
                        {/* X axis */}
                        <text x={liPadL + liPlotW / 2} y={liH - 2} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                          Window →
                        </text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "6px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 20, height: 8, background: "rgba(59,130,246,0.4)", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Wide spread</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 6, height: 8, background: "rgba(239,68,68,0.5)", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Narrowing</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                        ⚠ = locked in (late spread &lt; 30% of early)
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Posterior Contraction Timeline */}
              {trials.length >= 15 && (() => {
                const pcObjKey = Object.keys(trials[0].kpis)[0];
                const pcPKeys = Object.keys(trials[0].parameters);
                const pcSpecs = campaign.spec?.parameters || [];
                const pcRanges = pcPKeys.map(k => {
                  const sp = pcSpecs.find((s: { name: string }) => s.name === k);
                  const range = sp && (sp as { upper?: number }).upper != null && (sp as { lower?: number }).lower != null ? ((sp as { upper: number }).upper - (sp as { lower: number }).lower) : 1;
                  return range || 1;
                });
                // At each trial, compute IQR-volume of top-k trials so far
                const pcK = Math.max(5, Math.floor(trials.length / 5));
                const pcWinSize = Math.max(3, Math.floor(trials.length / 20));
                const pcPoints: Array<{ idx: number; volume: number }> = [];
                for (let i = pcK - 1; i < trials.length; i += pcWinSize) {
                  // Get top-k by objective (minimize = lowest values)
                  const subset = trials.slice(0, i + 1).map((t, j) => ({
                    j,
                    val: Number(t.kpis[pcObjKey]) || 0,
                    params: pcPKeys.map((k, d) => (Number(t.parameters[k]) || 0) / pcRanges[d]),
                  })).sort((a, b) => a.val - b.val).slice(0, pcK);
                  // Compute normalized IQR volume: product of IQRs per dimension
                  let logVol = 0;
                  for (let d = 0; d < pcPKeys.length; d++) {
                    const dimVals = subset.map(s => s.params[d]).sort((a, b) => a - b);
                    const q1 = dimVals[Math.floor(dimVals.length * 0.25)];
                    const q3 = dimVals[Math.floor(dimVals.length * 0.75)];
                    const iqr = Math.max(q3 - q1, 0.001);
                    logVol += Math.log(iqr);
                  }
                  pcPoints.push({ idx: i, volume: Math.exp(logVol / pcPKeys.length) }); // Geometric mean of IQRs
                }
                if (pcPoints.length < 2) return null;
                const pcMaxVol = Math.max(...pcPoints.map(p => p.volume));
                const pcMinVol = Math.min(...pcPoints.map(p => p.volume));
                const pcVolRange = pcMaxVol - pcMinVol || 1;
                const pcW = 320, pcH = 120, pcPadL = 40, pcPadR = 20, pcPadT = 12, pcPadB = 24;
                const pcPlotW = pcW - pcPadL - pcPadR;
                const pcPlotH = pcH - pcPadT - pcPadB;
                const pcMaxIdx = trials.length - 1;
                const pcPathPts = pcPoints.map(p => ({
                  x: pcPadL + (p.idx / pcMaxIdx) * pcPlotW,
                  y: pcPadT + (1 - (p.volume - pcMinVol) / pcVolRange) * pcPlotH,
                }));
                const pcAreaPath = `M${pcPathPts.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" L")} L${pcPathPts[pcPathPts.length - 1].x.toFixed(1)},${pcPadT + pcPlotH} L${pcPathPts[0].x.toFixed(1)},${pcPadT + pcPlotH} Z`;
                const pcLinePath = pcPathPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // Trend: compare first third vs last third
                const pcThird = Math.max(1, Math.floor(pcPoints.length / 3));
                const pcEarlyAvg = pcPoints.slice(0, pcThird).reduce((s, p) => s + p.volume, 0) / pcThird;
                const pcLateAvg = pcPoints.slice(-pcThird).reduce((s, p) => s + p.volume, 0) / pcThird;
                const pcContraction = pcEarlyAvg > 0 ? ((pcEarlyAvg - pcLateAvg) / pcEarlyAvg) * 100 : 0;
                const pcTrend = pcContraction > 20 ? "Converging" : pcContraction > 5 ? "Narrowing" : pcContraction > -5 ? "Stable" : "Diverging";
                const pcTrendColor = pcContraction > 20 ? "#22c55e" : pcContraction > 5 ? "#3b82f6" : pcContraction > -5 ? "#eab308" : "#ef4444";
                return (
                  <div className="card">
                    <div style={{ display: "flex", alignItems: "flex-start", gap: "10px", marginBottom: "8px" }}>
                      <Minimize2 size={16} style={{ color: "var(--color-primary)", marginTop: 2 }} />
                      <div style={{ flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Posterior Contraction</h2>
                        <p style={{ margin: "2px 0 0", fontSize: "0.78rem", color: "var(--color-text-muted)" }}>
                          Search volume of top-{pcK} trials over time. Shrinking = spatial convergence.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ background: pcTrendColor + "22", color: pcTrendColor, border: `1px solid ${pcTrendColor}44` }}>
                        {pcTrend} ({pcContraction > 0 ? "-" : "+"}{Math.abs(pcContraction).toFixed(0)}%)
                      </span>
                    </div>
                    <svg width={pcW} height={pcH} viewBox={`0 0 ${pcW} ${pcH}`} role="img" aria-label="Posterior contraction timeline" style={{ display: "block" }}>
                      {/* Grid */}
                      {[0, 0.5, 1].map(f => (
                        <g key={f}>
                          <line x1={pcPadL} y1={pcPadT + f * pcPlotH} x2={pcPadL + pcPlotW} y2={pcPadT + f * pcPlotH} stroke="var(--color-border)" strokeWidth={0.5} />
                          <text x={pcPadL - 4} y={pcPadT + f * pcPlotH + 3} textAnchor="end" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">
                            {(pcMaxVol - f * pcVolRange).toPrecision(2)}
                          </text>
                        </g>
                      ))}
                      {/* Area fill */}
                      <path d={pcAreaPath} fill={pcTrendColor} opacity={0.15} />
                      {/* Line */}
                      <path d={pcLinePath} fill="none" stroke={pcTrendColor} strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                      {/* Dots */}
                      {pcPathPts.map((p, i) => (
                        <circle key={i} cx={p.x} cy={p.y} r={2.5} fill={pcTrendColor}>
                          <title>Trial {pcPoints[i].idx}: volume {pcPoints[i].volume.toPrecision(3)}</title>
                        </circle>
                      ))}
                      {/* X axis */}
                      <text x={pcPadL + pcPlotW / 2} y={pcH - 2} textAnchor="middle" fontSize="9" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">Trial</text>
                      <text x={pcPadL} y={pcH - 2} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">0</text>
                      <text x={pcPadL + pcPlotW} y={pcH - 2} textAnchor="middle" fontSize="8" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">{pcMaxIdx}</text>
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: "50%", background: pcTrendColor, marginRight: 4, verticalAlign: "middle" }} />IQR Volume (top-{pcK})</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>Shrinking area = convergence in parameter space</span>
                    </div>
                  </div>
                );
              })()}

              {/* Search Coverage Progression */}
              {trials.length >= 5 && (() => {
                const scSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (scSpecs.length === 0) return null;
                const scSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const scG = 20; // grid cells per dimension
                const scN = scSorted.length;
                const scStep = Math.max(1, Math.floor(scN / 20));
                const scCheckpoints: { iter: number; coverage: number }[] = [];
                // Track which cells are covered per dimension
                const scCovered: Set<number>[] = scSpecs.map(() => new Set<number>());
                for (let i = 0; i < scN; i++) {
                  const t = scSorted[i];
                  for (let d = 0; d < scSpecs.length; d++) {
                    const sp = scSpecs[d] as { name: string; lower?: number; upper?: number };
                    const lo = sp.lower ?? 0, hi = sp.upper ?? 1;
                    const norm = hi > lo ? (t.parameters[sp.name] - lo) / (hi - lo) : 0.5;
                    const cell = Math.min(scG - 1, Math.max(0, Math.floor(norm * scG)));
                    scCovered[d].add(cell);
                  }
                  if ((i + 1) % scStep === 0 || i === scN - 1) {
                    const avgCov = scCovered.reduce((a, s) => a + s.size / scG, 0) / scSpecs.length;
                    scCheckpoints.push({ iter: t.iteration, coverage: avgCov });
                  }
                }
                if (scCheckpoints.length < 2) return null;
                const scCurrent = scCheckpoints[scCheckpoints.length - 1].coverage;
                // Stall detection: last 5 checkpoints delta < 0.01
                const scLastN = scCheckpoints.slice(-5);
                const scStalled = scLastN.length >= 5 && Math.abs(scLastN[scLastN.length - 1].coverage - scLastN[0].coverage) < 0.01;
                const scW = 200, scH = 70, scPadX = 20, scPadY = 12;
                const scChartW = scW - 2 * scPadX, scChartH = scH - 2 * scPadY;
                const scPts = scCheckpoints.map((c, i) => ({
                  x: scPadX + (i / (scCheckpoints.length - 1)) * scChartW,
                  y: scH - scPadY - c.coverage * scChartH,
                }));
                const scAreaPath = `M${scPts[0].x},${scH - scPadY} ` + scPts.map(p => `L${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") + ` L${scPts[scPts.length - 1].x},${scH - scPadY} Z`;
                const scLinePath = scPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const scTargetY = scH - scPadY - 0.8 * scChartH;
                const scCovColor = scCurrent >= 0.7 ? "#22c55e" : scCurrent >= 0.4 ? "#f59e0b" : "#ef4444";
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <MapPin size={16} style={{ color: "var(--color-text-muted)" }} />
                      <h3 style={{ margin: 0, fontSize: "0.92rem" }}>Search Coverage</h3>
                      <span className="findings-badge" style={{ background: scCovColor + "18", color: scCovColor, marginLeft: "auto" }}>
                        {(scCurrent * 100).toFixed(0)}% covered{scStalled ? " (stalled)" : ""}
                      </span>
                    </div>
                    <svg width="100%" viewBox={`0 0 ${scW} ${scH}`} style={{ display: "block" }}>
                      <defs>
                        <linearGradient id="sc-grad" x1="0" y1="1" x2="0" y2="0">
                          <stop offset="0%" stopColor={scCovColor} stopOpacity="0.02" />
                          <stop offset="100%" stopColor={scCovColor} stopOpacity="0.25" />
                        </linearGradient>
                      </defs>
                      {/* Grid */}
                      {[0.25, 0.5, 0.75].map(t => (
                        <line key={`scg${t}`} x1={scPadX} y1={scH - scPadY - t * scChartH} x2={scW - scPadX} y2={scH - scPadY - t * scChartH} stroke="var(--color-border)" strokeWidth="0.5" />
                      ))}
                      {/* Target line at 80% */}
                      <line x1={scPadX} y1={scTargetY} x2={scW - scPadX} y2={scTargetY} stroke="#22c55e" strokeWidth="0.8" strokeDasharray="3 2" opacity={0.5} />
                      <text x={scW - scPadX + 2} y={scTargetY + 3} fontSize="5.5" fill="#22c55e" opacity={0.7}>80%</text>
                      {/* Area fill */}
                      <path d={scAreaPath} fill="url(#sc-grad)" />
                      {/* Line */}
                      <path d={scLinePath} fill="none" stroke={scCovColor} strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Endpoint */}
                      <circle cx={scPts[scPts.length - 1].x} cy={scPts[scPts.length - 1].y} r="3" fill={scCovColor} />
                      {/* Current value label */}
                      <text x={scPts[scPts.length - 1].x + 2} y={scPts[scPts.length - 1].y - 4} fontSize="7" fill={scCovColor} fontWeight="600" fontFamily="var(--font-mono)">{(scCurrent * 100).toFixed(0)}%</text>
                      {/* Axes labels */}
                      <text x={scPadX} y={scH - 1} fontSize="5.5" fill="var(--color-text-muted)">iter {scCheckpoints[0].iter}</text>
                      <text x={scW - scPadX} y={scH - 1} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">iter {scCheckpoints[scCheckpoints.length - 1].iter}</text>
                      <text x={scPadX - 3} y={scH - scPadY + 2} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">0</text>
                      <text x={scPadX - 3} y={scPadY + 3} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">1</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 2 }}>
                      <span>{scSpecs.length} dims × {scG} grid cells</span>
                      {scStalled && <span style={{ color: "#f59e0b", fontWeight: 500 }}>Coverage stalled — consider forcing exploration</span>}
                    </div>
                  </div>
                );
              })()}

              {/* Learning Velocity Timeline */}
              {trials.length >= 12 && (() => {
                const lvSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const lvKpi = Object.keys(lvSorted[0]?.kpis || {})[0];
                if (!lvKpi) return null;
                const lvN = lvSorted.length;
                const lvWin = Math.max(3, Math.floor(lvN / 12));

                // Compute rolling best and rolling variance for windows
                const lvWindows: { iter: number; improvement: number; varReduction: number }[] = [];
                let lvRunBest = Number(lvSorted[0].kpis[lvKpi]) || 0;
                // Determine if minimizing (assume minimize if first values are more negative)
                const lvFirstAvg = lvSorted.slice(0, 5).reduce((s, t) => s + (Number(t.kpis[lvKpi]) || 0), 0) / 5;
                const lvLastAvg = lvSorted.slice(-5).reduce((s, t) => s + (Number(t.kpis[lvKpi]) || 0), 0) / 5;
                const lvMinimize = lvLastAvg <= lvFirstAvg;

                for (let i = lvWin; i <= lvN; i += Math.max(1, Math.floor(lvWin / 2))) {
                  const winSlice = lvSorted.slice(i - lvWin, i);
                  const winKpis = winSlice.map(t => Number(t.kpis[lvKpi]) || 0);

                  // Improvement: how much best improved in this window
                  const winBest = lvMinimize ? Math.min(...winKpis) : Math.max(...winKpis);
                  const prevBest = lvRunBest;
                  if (lvMinimize ? winBest < lvRunBest : winBest > lvRunBest) {
                    lvRunBest = winBest;
                  }
                  const improvement = Math.abs(lvRunBest - prevBest);

                  // Variance reduction: compare window variance to previous window
                  const winMean = winKpis.reduce((a, b) => a + b, 0) / winKpis.length;
                  const winVar = winKpis.reduce((s, v) => s + (v - winMean) ** 2, 0) / winKpis.length;
                  const prevSlice = lvSorted.slice(Math.max(0, i - 2 * lvWin), i - lvWin);
                  let varReduction = 0;
                  if (prevSlice.length > 2) {
                    const prevKpis = prevSlice.map(t => Number(t.kpis[lvKpi]) || 0);
                    const prevMean = prevKpis.reduce((a, b) => a + b, 0) / prevKpis.length;
                    const prevVar = prevKpis.reduce((s, v) => s + (v - prevMean) ** 2, 0) / prevKpis.length;
                    varReduction = prevVar > 0 ? Math.max(0, (prevVar - winVar) / prevVar) : 0;
                  }

                  lvWindows.push({ iter: winSlice[winSlice.length - 1].iteration, improvement, varReduction });
                }

                if (lvWindows.length < 3) return null;

                const lvMaxImp = Math.max(...lvWindows.map(w => w.improvement), 0.0001);
                const lvW = 440, lvH = 110, lvPadL = 46, lvPadR = 46, lvPadT = 10, lvPadB = 24;
                const lvPlotW = lvW - lvPadL - lvPadR;
                const lvPlotH = lvH - lvPadT - lvPadB;

                // Phase detection
                const lvRecentImps = lvWindows.slice(-3).map(w => w.improvement);
                const lvRecentAvg = lvRecentImps.reduce((a, b) => a + b, 0) / lvRecentImps.length;
                const lvOverallAvg = lvWindows.map(w => w.improvement).reduce((a, b) => a + b, 0) / lvWindows.length;
                const lvPhase = lvRecentAvg > lvOverallAvg * 1.5 ? "Accelerating" : lvRecentAvg > lvOverallAvg * 0.3 ? "Steady" : "Plateau";
                const lvPhaseColor = lvPhase === "Accelerating" ? "#22c55e" : lvPhase === "Steady" ? "#3b82f6" : "#f59e0b";

                // Plot points
                const lvImpPts = lvWindows.map((w, i) => ({
                  x: lvPadL + (i / (lvWindows.length - 1)) * lvPlotW,
                  y: lvPadT + (1 - w.improvement / lvMaxImp) * lvPlotH,
                }));
                const lvVarPts = lvWindows.map((w, i) => ({
                  x: lvPadL + (i / (lvWindows.length - 1)) * lvPlotW,
                  y: lvPadT + (1 - w.varReduction) * lvPlotH,
                }));

                const lvImpPath = lvImpPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const lvVarPath = lvVarPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");

                // Background phase regions
                const lvThird = Math.floor(lvWindows.length / 3);

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Thermometer size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Learning Velocity</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Rate of improvement and variance reduction per trial window.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", color: lvPhaseColor, borderColor: lvPhaseColor + "40" }}>
                        {lvPhase}
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={lvW} height={lvH} viewBox={`0 0 ${lvW} ${lvH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Phase background regions */}
                        {lvThird > 0 && (
                          <>
                            <rect x={lvPadL} y={lvPadT} width={(lvThird / (lvWindows.length - 1)) * lvPlotW} height={lvPlotH} fill="#22c55e" opacity={0.04} />
                            <rect x={lvPadL + (lvThird / (lvWindows.length - 1)) * lvPlotW} y={lvPadT} width={((lvThird) / (lvWindows.length - 1)) * lvPlotW} height={lvPlotH} fill="#3b82f6" opacity={0.04} />
                            <rect x={lvPadL + (2 * lvThird / (lvWindows.length - 1)) * lvPlotW} y={lvPadT} width={((lvWindows.length - 1 - 2 * lvThird) / (lvWindows.length - 1)) * lvPlotW} height={lvPlotH} fill="#f59e0b" opacity={0.04} />
                          </>
                        )}
                        {/* Grid lines */}
                        {[0.25, 0.5, 0.75].map(f => (
                          <line key={f} x1={lvPadL} y1={lvPadT + (1 - f) * lvPlotH} x2={lvW - lvPadR} y2={lvPadT + (1 - f) * lvPlotH} stroke="var(--color-border)" strokeWidth="0.5" />
                        ))}
                        {/* Zero line */}
                        <line x1={lvPadL} y1={lvPadT + lvPlotH} x2={lvW - lvPadR} y2={lvPadT + lvPlotH} stroke="var(--color-border)" strokeWidth="0.8" />
                        {/* Improvement line */}
                        <path d={lvImpPath} fill="none" stroke="#3b82f6" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                        {lvImpPts.map((p, i) => (
                          <circle key={`imp${i}`} cx={p.x} cy={p.y} r="2.5" fill="#3b82f6" />
                        ))}
                        {/* Variance reduction line (dashed) */}
                        <path d={lvVarPath} fill="none" stroke="#8b5cf6" strokeWidth="1.5" strokeDasharray="4 2" strokeLinecap="round" />
                        {/* Y axis labels */}
                        <text x={lvPadL - 4} y={lvPadT + 3} textAnchor="end" fontSize="6.5" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">max</text>
                        <text x={lvPadL - 4} y={lvPadT + lvPlotH + 3} textAnchor="end" fontSize="6.5" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">0</text>
                        {/* Right Y axis labels */}
                        <text x={lvW - lvPadR + 4} y={lvPadT + 3} fontSize="6.5" fill="#8b5cf6" fontFamily="var(--font-mono)">100%</text>
                        <text x={lvW - lvPadR + 4} y={lvPadT + lvPlotH + 3} fontSize="6.5" fill="#8b5cf6" fontFamily="var(--font-mono)">0%</text>
                        {/* X axis */}
                        <text x={lvPadL} y={lvH - 2} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">iter {lvWindows[0].iter}</text>
                        <text x={lvW - lvPadR} y={lvH - 2} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" textAnchor="end">iter {lvWindows[lvWindows.length - 1].iter}</text>
                        <text x={lvPadL + lvPlotW / 2} y={lvH - 2} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">Window →</text>
                        {/* Peak annotation */}
                        {(() => {
                          const peakIdx = lvWindows.reduce((best, w, i) => w.improvement > lvWindows[best].improvement ? i : best, 0);
                          if (lvWindows[peakIdx].improvement > 0) {
                            const px = lvImpPts[peakIdx].x;
                            const py = lvImpPts[peakIdx].y;
                            return (
                              <text x={px} y={py - 6} textAnchor="middle" fontSize="6.5" fill="#3b82f6" fontWeight="600">
                                Peak t={lvWindows[peakIdx].iter}
                              </text>
                            );
                          }
                          return null;
                        })()}
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: "#3b82f6", marginRight: 4, verticalAlign: "middle", borderRadius: 1 }} />Improvement rate</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 0, borderTop: "2px dashed #8b5cf6", marginRight: 4, verticalAlign: "middle" }} />Var reduction</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                        {lvWin}-trial windows
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Objective Distribution Evolution */}
              {trials.length >= 12 && (() => {
                const deSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const deKpiKey = Object.keys(deSorted[0]?.kpis || {})[0];
                if (!deKpiKey) return null;
                const deN = deSorted.length;
                const deNWindows = Math.min(8, Math.floor(deN / 3));
                if (deNWindows < 3) return null;
                const deWinSize = Math.floor(deN / deNWindows);

                // Compute quartile stats for each window
                const deWindows: { iter: number; q0: number; q25: number; q50: number; q75: number; q100: number }[] = [];
                for (let w = 0; w < deNWindows; w++) {
                  const start = w * deWinSize;
                  const end = w === deNWindows - 1 ? deN : (w + 1) * deWinSize;
                  const vals = deSorted.slice(start, end).map(t => t.kpis[deKpiKey] ?? 0).sort((a, b) => a - b);
                  const qAt = (p: number) => {
                    const idx = p * (vals.length - 1);
                    const lo = Math.floor(idx), hi = Math.ceil(idx);
                    return lo === hi ? vals[lo] : vals[lo] + (vals[hi] - vals[lo]) * (idx - lo);
                  };
                  deWindows.push({
                    iter: Math.round((start + end) / 2),
                    q0: vals[0],
                    q25: qAt(0.25),
                    q50: qAt(0.5),
                    q75: qAt(0.75),
                    q100: vals[vals.length - 1],
                  });
                }

                // Global y range
                const deYMin = Math.min(...deWindows.map(w => w.q0));
                const deYMax = Math.max(...deWindows.map(w => w.q100));
                const deYRange = deYMax - deYMin || 1;

                // Detect shift
                const deFirst = deWindows[0];
                const deLast = deWindows[deWindows.length - 1];
                const deMedianShift = deLast.q50 - deFirst.q50;
                const deIQRFirst = deFirst.q75 - deFirst.q25 || 0.001;
                const deIQRLast = deLast.q75 - deLast.q25 || 0.001;
                const deNarrowing = deIQRLast < deIQRFirst * 0.7;
                const deShiftLabel = deNarrowing ? "Converging" : Math.abs(deMedianShift) / deIQRFirst > 0.5 ? "Shifting" : "Stable";
                const deShiftColor = deNarrowing ? "#22c55e" : Math.abs(deMedianShift) / deIQRFirst > 0.5 ? "#3b82f6" : "var(--color-text-muted)";

                // SVG layout
                const deW = 320, deH = 140, dePadL = 40, dePadR = 10, dePadT = 10, dePadB = 24;
                const dePlotW = deW - dePadL - dePadR;
                const dePlotH = deH - dePadT - dePadB;
                const deXScale = (i: number) => dePadL + (i / (deNWindows - 1)) * dePlotW;
                const deYScale = (v: number) => dePadT + dePlotH - ((v - deYMin) / deYRange) * dePlotH;
                const deBandW = Math.max(6, dePlotW / deNWindows * 0.6);

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <BarChart2 size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Objective Distribution Evolution</h2>
                        <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)" }}>Quartile shift across iteration windows</div>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", background: deShiftColor + "18", color: deShiftColor }}>
                        {deShiftLabel}
                      </span>
                    </div>
                    <svg width={deW} height={deH} viewBox={`0 0 ${deW} ${deH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Y axis labels */}
                      {[0, 0.25, 0.5, 0.75, 1].map(f => {
                        const v = deYMin + f * deYRange;
                        return (
                          <Fragment key={`dey${f}`}>
                            <line x1={dePadL} y1={deYScale(v)} x2={dePadL + dePlotW} y2={deYScale(v)} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                            <text x={dePadL - 4} y={deYScale(v) + 3} fontSize="6" fill="var(--color-text-muted)" textAnchor="end">{v.toPrecision(3)}</text>
                          </Fragment>
                        );
                      })}
                      {/* Box plots for each window */}
                      {deWindows.map((w, i) => {
                        const x = deXScale(i);
                        const half = deBandW / 2;
                        return (
                          <g key={`dew${i}`}>
                            {/* Whisker: q0 to q25 */}
                            <line x1={x} y1={deYScale(w.q0)} x2={x} y2={deYScale(w.q25)} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                            {/* Whisker: q75 to q100 */}
                            <line x1={x} y1={deYScale(w.q75)} x2={x} y2={deYScale(w.q100)} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                            {/* Whisker caps */}
                            <line x1={x - half * 0.5} y1={deYScale(w.q0)} x2={x + half * 0.5} y2={deYScale(w.q0)} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                            <line x1={x - half * 0.5} y1={deYScale(w.q100)} x2={x + half * 0.5} y2={deYScale(w.q100)} stroke="var(--color-text-muted)" strokeWidth="0.8" />
                            {/* IQR box */}
                            <rect
                              x={x - half}
                              y={deYScale(w.q75)}
                              width={deBandW}
                              height={Math.max(1, deYScale(w.q25) - deYScale(w.q75))}
                              rx={2}
                              fill={i < deNWindows / 3 ? "rgba(59,130,246,0.15)" : i < 2 * deNWindows / 3 ? "rgba(168,85,247,0.15)" : "rgba(34,197,94,0.15)"}
                              stroke={i < deNWindows / 3 ? "#3b82f6" : i < 2 * deNWindows / 3 ? "#a855f7" : "#22c55e"}
                              strokeWidth="1"
                            />
                            {/* Median line */}
                            <line
                              x1={x - half}
                              y1={deYScale(w.q50)}
                              x2={x + half}
                              y2={deYScale(w.q50)}
                              stroke={i < deNWindows / 3 ? "#3b82f6" : i < 2 * deNWindows / 3 ? "#a855f7" : "#22c55e"}
                              strokeWidth="2"
                            />
                            {/* Window label */}
                            <text x={x} y={deH - dePadB + 12} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">t{w.iter}</text>
                          </g>
                        );
                      })}
                      {/* Median trend line */}
                      <polyline
                        points={deWindows.map((w, i) => `${deXScale(i)},${deYScale(w.q50)}`).join(" ")}
                        fill="none"
                        stroke="var(--color-primary)"
                        strokeWidth="1"
                        strokeDasharray="4,3"
                        opacity="0.5"
                      />
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: 4, flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "rgba(59,130,246,0.3)", border: "1px solid #3b82f6", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Early</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "rgba(168,85,247,0.3)", border: "1px solid #a855f7", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Mid</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "rgba(34,197,94,0.3)", border: "1px solid #22c55e", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Late</span>
                      <span className="efficiency-legend-item" style={{ marginLeft: "auto" }}>IQR: {deIQRFirst.toPrecision(3)} → {deIQRLast.toPrecision(3)}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Landscape Conditioning Timeline */}
              {trials.length >= 15 && (() => {
                const lcSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (lcSpecs.length < 2) return null;
                const lcKpiKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!lcKpiKey) return null;
                const lcSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const lcN = lcSorted.length;
                const lcD = Math.min(lcSpecs.length, 6);
                const lcNWin = Math.min(8, Math.floor(lcN / 5));
                if (lcNWin < 3) return null;
                const lcWinSize = Math.floor(lcN / lcNWin);

                // For each window, fit local quadratic: compute variance in each parameter direction
                // and cross-variance. Condition number proxy = max_eigenvalue / min_eigenvalue
                // Simplified: use ratio of max to min parameter variance as conditioning proxy
                const lcWindows: { iter: number; condNum: number; effRank: number }[] = [];
                for (let wi = 0; wi < lcNWin; wi++) {
                  const start = wi * lcWinSize;
                  const end = wi === lcNWin - 1 ? lcN : (wi + 1) * lcWinSize;
                  const win = lcSorted.slice(start, end);

                  // Compute parameter variance in each dimension (normalized)
                  const dimVars: number[] = [];
                  for (let d = 0; d < lcD; d++) {
                    const pName = (lcSpecs[d] as { name: string; lower: number; upper: number }).name;
                    const lo = (lcSpecs[d] as { lower: number }).lower;
                    const hi = (lcSpecs[d] as { upper: number }).upper;
                    const range = hi - lo || 1;
                    const vals = win.map(t => ((Number(t.parameters[pName]) || 0) - lo) / range);
                    const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                    const variance = vals.reduce((s, v) => s + (v - mean) ** 2, 0) / vals.length;
                    dimVars.push(variance);
                  }

                  // Also include KPI variance weighted by parameter correlations
                  const kpiVals = win.map(t => t.kpis[lcKpiKey] ?? 0);
                  const kpiMean = kpiVals.reduce((a, b) => a + b, 0) / kpiVals.length;
                  const kpiVar = kpiVals.reduce((s, v) => s + (v - kpiMean) ** 2, 0) / kpiVals.length;

                  // Compute parameter-KPI correlations to estimate effective rank
                  const corrAbs: number[] = [];
                  for (let d = 0; d < lcD; d++) {
                    const pName = (lcSpecs[d] as { name: string; lower: number; upper: number }).name;
                    const lo = (lcSpecs[d] as { lower: number }).lower;
                    const hi = (lcSpecs[d] as { upper: number }).upper;
                    const range = hi - lo || 1;
                    const xs = win.map(t => ((Number(t.parameters[pName]) || 0) - lo) / range);
                    const mx = xs.reduce((a, b) => a + b, 0) / xs.length;
                    let cov = 0, sx = 0;
                    for (let k = 0; k < xs.length; k++) {
                      cov += (xs[k] - mx) * (kpiVals[k] - kpiMean);
                      sx += (xs[k] - mx) ** 2;
                    }
                    const corr = sx > 0 && kpiVar > 0 ? Math.abs(cov / (Math.sqrt(sx * kpiVals.reduce((s, v) => s + (v - kpiMean) ** 2, 0)) || 1)) : 0;
                    corrAbs.push(corr);
                  }

                  // Condition number proxy: max dim variance / min dim variance
                  const maxVar = Math.max(...dimVars);
                  const minVar = Math.min(...dimVars.filter(v => v > 0)) || 0.001;
                  const condNum = maxVar / minVar;

                  // Effective rank: count dimensions with |corr| > 0.15
                  const effRank = corrAbs.filter(c => c > 0.15).length;

                  lcWindows.push({ iter: start + Math.floor(lcWinSize / 2), condNum, effRank });
                }

                const lcMaxCond = Math.max(...lcWindows.map(w => w.condNum));
                const lcMaxRank = lcD;

                // Trend
                const lcFirst = lcWindows[0].condNum;
                const lcLast = lcWindows[lcWindows.length - 1].condNum;
                const lcCondTrend = lcLast < lcFirst * 0.7 ? "Improving" : lcLast > lcFirst * 1.3 ? "Worsening" : "Stable";
                const lcCondColor = lcCondTrend === "Improving" ? "#22c55e" : lcCondTrend === "Worsening" ? "#ef4444" : "var(--color-text-muted)";

                // SVG
                const lcW = 320, lcH = 140, lcPadL = 40, lcPadR = 36, lcPadT = 10, lcPadB = 24;
                const lcPlotW = lcW - lcPadL - lcPadR;
                const lcPlotH = lcH - lcPadT - lcPadB;
                const lcXScale = (i: number) => lcPadL + (i / (lcNWin - 1)) * lcPlotW;
                const lcYCond = (v: number) => lcPadT + lcPlotH - (Math.min(v, lcMaxCond) / lcMaxCond) * lcPlotH;
                const lcYRank = (v: number) => lcPadT + lcPlotH - (v / lcMaxRank) * lcPlotH;

                // Build condition area path
                const lcCondUpper = lcWindows.map((w, i) => `${i === 0 ? "M" : "L"}${lcXScale(i).toFixed(1)},${lcYCond(w.condNum).toFixed(1)}`).join(" ");
                const lcCondLower = [...lcWindows].reverse().map((_, i) => `L${lcXScale(lcNWin - 1 - i).toFixed(1)},${(lcPadT + lcPlotH).toFixed(1)}`).join(" ");
                const lcCondArea = `${lcCondUpper} ${lcCondLower} Z`;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <Activity size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Landscape Conditioning</h2>
                        <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)" }}>Condition number + effective rank over time</div>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", background: lcCondColor + "18", color: lcCondColor }}>
                        {lcCondTrend}
                      </span>
                    </div>
                    <svg width={lcW} height={lcH} viewBox={`0 0 ${lcW} ${lcH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Y axis grids (condition) */}
                      {[0, 0.5, 1].map(f => {
                        const v = f * lcMaxCond;
                        return (
                          <Fragment key={`lcg${f}`}>
                            <line x1={lcPadL} y1={lcYCond(v)} x2={lcPadL + lcPlotW} y2={lcYCond(v)} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                            <text x={lcPadL - 4} y={lcYCond(v) + 3} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="end">{v.toFixed(1)}</text>
                          </Fragment>
                        );
                      })}
                      {/* Right Y axis labels (rank) */}
                      {[0, Math.floor(lcMaxRank / 2), lcMaxRank].map(r => (
                        <text key={`lcr${r}`} x={lcPadL + lcPlotW + 4} y={lcYRank(r) + 3} fontSize="5.5" fill="#a855f7" textAnchor="start">{r}</text>
                      ))}
                      {/* Condition area */}
                      <path d={lcCondArea} fill="rgba(249,115,22,0.12)" />
                      <polyline
                        points={lcWindows.map((w, i) => `${lcXScale(i)},${lcYCond(w.condNum)}`).join(" ")}
                        fill="none"
                        stroke="#f97316"
                        strokeWidth="1.5"
                        strokeLinejoin="round"
                      />
                      {/* Condition dots */}
                      {lcWindows.map((w, i) => (
                        <circle key={`lcd${i}`} cx={lcXScale(i)} cy={lcYCond(w.condNum)} r="2.5" fill="#f97316" />
                      ))}
                      {/* Effective rank step line */}
                      {lcWindows.map((w, i) => {
                        if (i === 0) return null;
                        const prev = lcWindows[i - 1];
                        return (
                          <g key={`lcrl${i}`}>
                            <line x1={lcXScale(i - 1)} y1={lcYRank(prev.effRank)} x2={lcXScale(i)} y2={lcYRank(prev.effRank)} stroke="#a855f7" strokeWidth="1.5" strokeDasharray="4,3" />
                            <line x1={lcXScale(i)} y1={lcYRank(prev.effRank)} x2={lcXScale(i)} y2={lcYRank(w.effRank)} stroke="#a855f7" strokeWidth="1.5" strokeDasharray="4,3" />
                          </g>
                        );
                      })}
                      {/* Rank dots */}
                      {lcWindows.map((w, i) => (
                        <circle key={`lcrd${i}`} cx={lcXScale(i)} cy={lcYRank(w.effRank)} r="2" fill="#a855f7" />
                      ))}
                      {/* X axis */}
                      {lcWindows.map((w, i) => (
                        <text key={`lcx${i}`} x={lcXScale(i)} y={lcH - lcPadB + 12} fontSize="5.5" fill="var(--color-text-muted)" textAnchor="middle">t{w.iter}</text>
                      ))}
                      {/* Axis labels */}
                      <text x={8} y={lcPadT + lcPlotH / 2} fontSize="6" fill="#f97316" textAnchor="middle" transform={`rotate(-90, 8, ${lcPadT + lcPlotH / 2})`}>Condition #</text>
                      <text x={lcW - 4} y={lcPadT + lcPlotH / 2} fontSize="6" fill="#a855f7" textAnchor="middle" transform={`rotate(90, ${lcW - 4}, ${lcPadT + lcPlotH / 2})`}>Eff. Rank</text>
                    </svg>
                    <div style={{ display: "flex", gap: "16px", marginTop: 4, flexWrap: "wrap" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 3, background: "#f97316", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Condition #</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 0, borderTop: "2px dashed #a855f7", marginRight: 4, verticalAlign: "middle" }} />Eff. Rank (/{lcD}D)</span>
                    </div>
                  </div>
                );
              })()}

              {/* Optimization Momentum Indicator */}
              {trials.length >= 10 && (() => {
                const omSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const omObjKey = Object.keys(omSorted[0].kpis)[0];
                if (!omObjKey) return null;
                // Best-so-far curve
                const omBsf: number[] = [];
                let omRunBest = Infinity;
                for (const t of omSorted) {
                  const v = Number(t.kpis[omObjKey]) || 0;
                  omRunBest = Math.min(omRunBest, v);
                  omBsf.push(omRunBest);
                }
                // First differences (velocity) and second differences (acceleration)
                const omVelocity: number[] = [];
                for (let i = 1; i < omBsf.length; i++) omVelocity.push(omBsf[i] - omBsf[i - 1]);
                const omAccel: number[] = [];
                for (let i = 1; i < omVelocity.length; i++) omAccel.push(omVelocity[i] - omVelocity[i - 1]);
                if (omAccel.length < 3) return null;
                // Smooth with 3-point moving average
                const omSmooth = (arr: number[]) => arr.map((_, i) => {
                  const s = Math.max(0, i - 1), e = Math.min(arr.length - 1, i + 1);
                  return arr.slice(s, e + 1).reduce((a, b) => a + b, 0) / (e - s + 1);
                });
                const omSmAccel = omSmooth(omAccel);
                // Classify each window
                const omPhases = omSmAccel.map(a => {
                  if (a < -0.001) return "accelerating";
                  if (a > 0.001) return "decelerating";
                  return Math.abs(a) <= 0.001 ? "cruising" : "stalled";
                });
                // Check if best-so-far actually changed in recent windows
                const omRecentVel = omVelocity.slice(-Math.min(5, omVelocity.length));
                const omIsStalled = omRecentVel.every(v => Math.abs(v) < 1e-10);
                if (omIsStalled) {
                  for (let i = Math.max(0, omPhases.length - 5); i < omPhases.length; i++) {
                    omPhases[i] = "stalled";
                  }
                }
                const omMaxAbs = Math.max(...omSmAccel.map(a => Math.abs(a)), 0.0001);
                // Current momentum
                const omRecent = omPhases.slice(-3);
                const omDominant = omRecent.filter(p => p === "accelerating").length >= 2 ? "Accelerating"
                  : omRecent.filter(p => p === "decelerating").length >= 2 ? "Decelerating"
                  : omRecent.filter(p => p === "stalled").length >= 2 ? "Stalled"
                  : "Cruising";
                const omColor = omDominant === "Accelerating" ? "#22c55e" : omDominant === "Decelerating" ? "#eab308" : omDominant === "Stalled" ? "#ef4444" : "var(--color-primary)";
                const omPhaseColors: Record<string, string> = {
                  accelerating: "#22c55e",
                  cruising: "var(--color-primary)",
                  decelerating: "#eab308",
                  stalled: "#ef4444",
                };
                // Chart
                const omW = 320, omH = 110, omPadL = 34, omPadR = 10, omPadT = 12, omPadB = 26;
                const omPlotW = omW - omPadL - omPadR;
                const omPlotH = omH - omPadT - omPadB;
                const omBarW = Math.min(8, omPlotW / omSmAccel.length * 0.7);
                const omGap = omPlotW / omSmAccel.length;
                const omMidY = omPadT + omPlotH / 2;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <Flame size={15} style={{ color: omColor }} />
                        <h2 style={{ margin: 0 }}>Optimization Momentum</h2>
                      </div>
                      <span className="findings-badge" style={{ background: omColor, color: "#fff" }}>{omDominant}</span>
                    </div>
                    <svg width={omW} height={omH} viewBox={`0 0 ${omW} ${omH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Zero line */}
                      <line x1={omPadL} y1={omMidY} x2={omPadL + omPlotW} y2={omMidY} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,2" />
                      <text x={omPadL - 4} y={omPadT + 6} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">Accel</text>
                      <text x={omPadL - 4} y={omPadT + omPlotH} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">Decel</text>
                      {/* Bars */}
                      {omSmAccel.map((a, i) => {
                        const cx = omPadL + i * omGap + omGap / 2;
                        const h = (Math.abs(a) / omMaxAbs) * (omPlotH / 2 - 4);
                        const isNeg = a >= 0; // positive accel = decelerating (BSF stopped decreasing)
                        const phase = omPhases[i];
                        return (
                          <g key={i}>
                            <rect
                              x={cx - omBarW / 2}
                              y={isNeg ? omMidY : omMidY - h}
                              width={omBarW}
                              height={Math.max(h, 0.5)}
                              rx={1.5}
                              fill={omPhaseColors[phase]}
                              opacity={0.75}
                            />
                          </g>
                        );
                      })}
                      {/* Trend line connecting bar tips */}
                      {omSmAccel.length > 1 && (() => {
                        const pts = omSmAccel.map((a, i) => {
                          const cx = omPadL + i * omGap + omGap / 2;
                          const h = (a / omMaxAbs) * (omPlotH / 2 - 4);
                          return `${i === 0 ? "M" : "L"}${cx.toFixed(1)},${(omMidY - h).toFixed(1)}`;
                        });
                        return <path d={pts.join(" ")} fill="none" stroke="var(--color-text-muted)" strokeWidth="0.8" opacity={0.5} />;
                      })()}
                      {/* X-axis iteration labels (sparse) */}
                      {omSmAccel.map((_, i) => {
                        if (i % Math.max(1, Math.floor(omSmAccel.length / 6)) !== 0 && i !== omSmAccel.length - 1) return null;
                        const cx = omPadL + i * omGap + omGap / 2;
                        return <text key={i} x={cx} y={omH - 6} fontSize="5" fill="var(--color-text-muted)" textAnchor="middle">t{i + 2}</text>;
                      })}
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 4, flexWrap: "wrap" }}>
                      {(["accelerating", "cruising", "decelerating", "stalled"] as const).map(phase => (
                        <span key={phase} className="efficiency-legend-item">
                          <span style={{ display: "inline-block", width: 10, height: 8, background: omPhaseColors[phase], marginRight: 4, verticalAlign: "middle", borderRadius: 2, opacity: 0.75 }} />
                          {phase.charAt(0).toUpperCase() + phase.slice(1)} ({omPhases.filter(p => p === phase).length})
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}

              {/* Regional Value Heatmap */}
              {trials.length >= 10 && (() => {
                const rvSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rvSpecs.length < 2) return null;
                const rvObjKey = Object.keys(trials[0].kpis)[0];
                if (!rvObjKey) return null;
                const rvObjVals = trials.map(t => Number(t.kpis[rvObjKey]) || 0);
                // Pick top 2 params by variance
                const rvParamVar = rvSpecs.map((sp: { name: string; lower?: number; upper?: number }) => {
                  const lo = sp.lower ?? 0; const hi = sp.upper ?? 1; const range = hi - lo || 1;
                  const vals = trials.map(t => (Number(t.parameters[sp.name]) - lo) / range);
                  const m = vals.reduce((a, b) => a + b, 0) / vals.length;
                  const v = vals.reduce((s, x) => s + (x - m) ** 2, 0) / vals.length;
                  return { spec: sp, variance: v };
                });
                rvParamVar.sort((a, b) => b.variance - a.variance);
                const rvP1 = rvParamVar[0].spec as { name: string; lower?: number; upper?: number };
                const rvP2 = rvParamVar[1].spec as { name: string; lower?: number; upper?: number };
                const rvLo1 = rvP1.lower ?? 0, rvHi1 = rvP1.upper ?? 1;
                const rvLo2 = rvP2.lower ?? 0, rvHi2 = rvP2.upper ?? 1;
                // Grid: 6x6 cells
                const rvGrid = 6;
                const rvCells: { row: number; col: number; values: number[]; mean: number }[] = [];
                for (let r = 0; r < rvGrid; r++) {
                  for (let c = 0; c < rvGrid; c++) {
                    const vals: number[] = [];
                    trials.forEach((t, idx) => {
                      const x = (Number(t.parameters[rvP1.name]) - rvLo1) / (rvHi1 - rvLo1 || 1);
                      const y = (Number(t.parameters[rvP2.name]) - rvLo2) / (rvHi2 - rvLo2 || 1);
                      const ci = Math.min(rvGrid - 1, Math.floor(x * rvGrid));
                      const ri = Math.min(rvGrid - 1, Math.floor((1 - y) * rvGrid));
                      if (ci === c && ri === r) vals.push(rvObjVals[idx]);
                    });
                    rvCells.push({ row: r, col: c, values: vals, mean: vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : NaN });
                  }
                }
                const rvFilledCells = rvCells.filter(c => !isNaN(c.mean));
                if (rvFilledCells.length < 3) return null;
                const rvMinKpi = Math.min(...rvFilledCells.map(c => c.mean));
                const rvMaxKpi = Math.max(...rvFilledCells.map(c => c.mean));
                const rvRange = rvMaxKpi - rvMinKpi || 1;
                // Best region
                const rvBestCell = rvFilledCells.reduce((best, c) => c.mean < best.mean ? c : best, rvFilledCells[0]);
                const rvHotspots = rvFilledCells.filter(c => c.mean < rvMinKpi + rvRange * 0.25).length;
                const rvLabel = rvHotspots === 1 ? "Unimodal" : rvHotspots <= 3 ? "Few Basins" : "Multi-modal";
                const rvColor = rvHotspots === 1 ? "#22c55e" : rvHotspots <= 3 ? "var(--color-primary)" : "#a855f7";
                // Chart
                const rvW = 260, rvH = 220, rvPadL = 40, rvPadR = 30, rvPadT = 14, rvPadB = 30;
                const rvPlotW = rvW - rvPadL - rvPadR;
                const rvPlotH = rvH - rvPadT - rvPadB;
                const rvCellW = rvPlotW / rvGrid;
                const rvCellH = rvPlotH / rvGrid;
                return (
                  <div className="card" style={{ padding: "14px 16px" }}>
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                        <Map size={15} style={{ color: rvColor }} />
                        <h2 style={{ margin: 0 }}>Regional Value Map</h2>
                      </div>
                      <span className="findings-badge" style={{ background: rvColor, color: "#fff" }}>{rvLabel} ({rvHotspots} hot)</span>
                    </div>
                    <svg width={rvW} height={rvH} viewBox={`0 0 ${rvW} ${rvH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Cells */}
                      {rvCells.map((cell, i) => {
                        const x = rvPadL + cell.col * rvCellW;
                        const y = rvPadT + cell.row * rvCellH;
                        if (isNaN(cell.mean)) {
                          return <rect key={i} x={x} y={y} width={rvCellW} height={rvCellH} fill="var(--color-border)" opacity={0.1} stroke="var(--color-border)" strokeWidth="0.3" />;
                        }
                        // Green (good/low KPI) to Red (bad/high KPI) for minimization
                        const norm = (cell.mean - rvMinKpi) / rvRange;
                        const r = Math.round(norm * 239 + (1 - norm) * 34);
                        const g = Math.round(norm * 68 + (1 - norm) * 197);
                        const b = Math.round(norm * 68 + (1 - norm) * 94);
                        const isBest = cell === rvBestCell;
                        return (
                          <g key={i}>
                            <rect x={x} y={y} width={rvCellW} height={rvCellH} fill={`rgb(${r},${g},${b})`} opacity={0.7} stroke="white" strokeWidth="0.5" rx={1} />
                            {cell.values.length > 0 && <text x={x + rvCellW / 2} y={y + rvCellH / 2 + 2} fontSize="5" fill="white" textAnchor="middle" fontWeight="500">{cell.values.length}</text>}
                            {isBest && <rect x={x + 1} y={y + 1} width={rvCellW - 2} height={rvCellH - 2} fill="none" stroke="white" strokeWidth="1.5" rx={2} />}
                          </g>
                        );
                      })}
                      {/* Axes */}
                      <text x={rvPadL + rvPlotW / 2} y={rvH - 4} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle">{rvP1.name}</text>
                      <text x={8} y={rvPadT + rvPlotH / 2} fontSize="6" fill="var(--color-text-muted)" textAnchor="middle" transform={`rotate(-90, 8, ${rvPadT + rvPlotH / 2})`}>{rvP2.name}</text>
                      {/* Axis ticks */}
                      <text x={rvPadL} y={rvH - 14} fontSize="5" fill="var(--color-text-muted)" textAnchor="middle">{rvLo1.toPrecision(2)}</text>
                      <text x={rvPadL + rvPlotW} y={rvH - 14} fontSize="5" fill="var(--color-text-muted)" textAnchor="middle">{rvHi1.toPrecision(2)}</text>
                      <text x={rvPadL - 4} y={rvPadT + 4} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">{rvHi2.toPrecision(2)}</text>
                      <text x={rvPadL - 4} y={rvPadT + rvPlotH} fontSize="5" fill="var(--color-text-muted)" textAnchor="end">{rvLo2.toPrecision(2)}</text>
                      {/* Color legend */}
                      <defs>
                        <linearGradient id="rvGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor="rgb(239,68,68)" />
                          <stop offset="100%" stopColor="rgb(34,197,94)" />
                        </linearGradient>
                      </defs>
                      <rect x={rvW - 18} y={rvPadT} width={8} height={rvPlotH} rx={2} fill="url(#rvGrad)" opacity={0.7} />
                      <text x={rvW - 14} y={rvPadT - 3} fontSize="4.5" fill="var(--color-text-muted)" textAnchor="middle">Worse</text>
                      <text x={rvW - 14} y={rvPadT + rvPlotH + 8} fontSize="4.5" fill="var(--color-text-muted)" textAnchor="middle">Better</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, marginTop: 2, fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                      <span>{rvGrid}×{rvGrid} grid, top 2 variance params</span>
                      <span style={{ marginLeft: "auto" }}>Best: {rvMinKpi.toPrecision(3)} in ({rvBestCell.col + 1},{rvGrid - rvBestCell.row})</span>
                    </div>
                  </div>
                );
              })()}

              {/* Stagnation Pattern Detector */}
              {trials.length >= 20 && (() => {
                const spSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const spKey = Object.keys(spSorted[0]?.kpis || {})[0];
                if (!spKey) return null;
                const spKpis = spSorted.map(t => Number(t.kpis[spKey]) || 0);
                const spN = spKpis.length;

                // Best-so-far curve
                const spBsf: number[] = [];
                let spBest = spKpis[0];
                spKpis.forEach(v => { spBest = Math.min(spBest, v); spBsf.push(spBest); });

                // Rolling improvement rate (window=10)
                const spWin = Math.min(10, Math.floor(spN / 3));
                const spRates: { iter: number; rate: number }[] = [];
                for (let i = spWin; i < spN; i++) {
                  const improvement = spBsf[i - spWin] - spBsf[i]; // positive = improving (for min)
                  const range = Math.max(...spKpis) - Math.min(...spKpis) || 1;
                  spRates.push({ iter: spSorted[i].iteration, rate: (improvement / range) * 100 });
                }
                if (spRates.length === 0) return null;

                // Detect epochs: progressing, plateau, cycling
                const spSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                const spEpochs: { start: number; end: number; type: string }[] = [];
                const spEpochWin = Math.min(10, spRates.length);
                for (let i = 0; i <= spRates.length - spEpochWin; i += Math.max(1, Math.floor(spEpochWin / 2))) {
                  const chunk = spRates.slice(i, i + spEpochWin);
                  const avgRate = chunk.reduce((s, r) => s + r.rate, 0) / chunk.length;
                  let type: string;
                  if (avgRate > 0.5) type = "progressing";
                  else if (avgRate > -0.1) {
                    // Check cycling: compare parameter centroid shift
                    if (spSpecs.length > 0 && i + spEpochWin < spN) {
                      const windowTrials = spSorted.slice(i + spWin, i + spWin + spEpochWin);
                      const prevTrials = spSorted.slice(Math.max(0, i + spWin - spEpochWin), i + spWin);
                      if (prevTrials.length >= 3 && windowTrials.length >= 3) {
                        const centroid = (ts: typeof trials) => spSpecs.map((s: { name: string; lower?: number; upper?: number }) => {
                          const range = ((s.upper ?? 1) - (s.lower ?? 0)) || 1;
                          return ts.reduce((acc, t) => acc + ((Number(t.parameters[s.name]) || 0) - (s.lower ?? 0)) / range, 0) / ts.length;
                        });
                        const c1 = centroid(prevTrials), c2 = centroid(windowTrials);
                        const drift = Math.sqrt(c1.reduce((s, v, k) => s + (v - c2[k]) ** 2, 0));
                        type = drift < 0.15 ? "cycling" : "plateau";
                      } else type = "plateau";
                    } else type = "plateau";
                  } else type = "plateau";
                  spEpochs.push({ start: chunk[0].iter, end: chunk[chunk.length - 1].iter, type });
                }

                // Overall status from last epoch
                const spLastType = spEpochs.length > 0 ? spEpochs[spEpochs.length - 1].type : "progressing";
                const spStatus = spLastType === "progressing" ? "Progressing" : spLastType === "cycling" ? "Cycling" : "Plateau";
                const spStatusColor = spStatus === "Progressing" ? "var(--color-green, #22c55e)" : spStatus === "Plateau" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                // SVG
                const spPadL = 30, spPadR = 10, spChartW = 320, spChartH = 100;
                const spW = spPadL + spChartW + spPadR;
                const spH = spChartH + 40;
                const spMaxRate = Math.max(5, Math.max(...spRates.map(r => Math.abs(r.rate))));
                const spZeroY = 16 + spChartH / 2;

                const spMinIter = spRates[0].iter, spMaxIter = spRates[spRates.length - 1].iter;
                const spIterRange = spMaxIter - spMinIter || 1;
                const spX = (iter: number) => spPadL + ((iter - spMinIter) / spIterRange) * spChartW;
                const spY = (rate: number) => spZeroY - (rate / spMaxRate) * (spChartH / 2);

                // Line path
                const spLine = spRates.map((r, i) => `${i === 0 ? "M" : "L"}${spX(r.iter).toFixed(1)},${spY(r.rate).toFixed(1)}`).join(" ");

                // Epoch colors
                const spEpochColors: Record<string, string> = { progressing: "rgba(34,197,94,0.12)", plateau: "rgba(234,179,8,0.12)", cycling: "rgba(239,68,68,0.12)" };

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <Hourglass size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Stagnation Patterns</h2>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: spStatusColor + "18", color: spStatusColor }}>{spStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Rolling improvement rate (window={spWin}) with detected epochs.
                    </p>
                    <svg width={spW} height={spH} viewBox={`0 0 ${spW} ${spH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Epoch backgrounds */}
                      {spEpochs.map((e, i) => (
                        <rect key={i} x={spX(e.start)} y={16} width={Math.max(2, spX(e.end) - spX(e.start))} height={spChartH} fill={spEpochColors[e.type] || "transparent"} rx={2} />
                      ))}
                      {/* Zero line */}
                      <line x1={spPadL} y1={spZeroY} x2={spPadL + spChartW} y2={spZeroY} stroke="var(--color-border)" strokeWidth={0.5} strokeDasharray="4,3" />
                      <text x={spPadL - 4} y={spZeroY + 3} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">0%</text>
                      {/* Rate line */}
                      <path d={spLine} fill="none" stroke="var(--color-primary)" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
                      {/* Axis labels */}
                      <text x={spPadL} y={spH - 2} fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{spMinIter}</text>
                      <text x={spPadL + spChartW} y={spH - 2} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">{spMaxIter}</text>
                      <text x={spPadL - 4} y={20} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">+{spMaxRate.toFixed(0)}%</text>
                      <text x={spPadL - 4} y={16 + spChartH} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">-{spMaxRate.toFixed(0)}%</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, justifyContent: "center", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "rgba(34,197,94,0.3)", marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Progressing</span>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "rgba(234,179,8,0.3)", marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Plateau</span>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "rgba(239,68,68,0.3)", marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Cycling</span>
                    </div>
                  </div>
                );
              })()}

              {/* Regime Change Detector */}
              {trials.length >= 20 && (() => {
                const rcSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (rcSpecs.length === 0) return null;
                const rcSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const rcKey = Object.keys(rcSorted[0]?.kpis || {})[0];
                if (!rcKey) return null;
                const rcN = rcSorted.length;
                const rcWin = Math.min(10, Math.floor(rcN / 3));

                // Signal 1: Parameter variance (rolling normalized std)
                const rcParamVar: number[] = [];
                for (let i = rcWin; i <= rcN; i++) {
                  const chunk = rcSorted.slice(i - rcWin, i);
                  let totalVar = 0;
                  rcSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const vals = chunk.map(t => Number(t.parameters[s.name]) || 0);
                    const range = ((s.upper ?? 1) - (s.lower ?? 0)) || 1;
                    const norms = vals.map(v => (v - (s.lower ?? 0)) / range);
                    const mu = norms.reduce((a, b) => a + b, 0) / norms.length;
                    totalVar += norms.reduce((a, v) => a + (v - mu) ** 2, 0) / norms.length;
                  });
                  rcParamVar.push(totalVar / rcSpecs.length);
                }

                // Signal 2: KPI improvement rate (rolling)
                const rcKpis = rcSorted.map(t => Number(t.kpis[rcKey]) || 0);
                const rcBsf: number[] = [];
                let rcBest = rcKpis[0];
                rcKpis.forEach(v => { rcBest = Math.min(rcBest, v); rcBsf.push(rcBest); });
                const rcImprRate: number[] = [];
                for (let i = rcWin; i <= rcN; i++) {
                  const improvement = rcBsf[i - rcWin] - rcBsf[i - 1];
                  rcImprRate.push(improvement);
                }

                // Normalize signals to [0,1]
                const rcMaxVar = Math.max(...rcParamVar, 0.001);
                const rcNormVar = rcParamVar.map(v => v / rcMaxVar);
                const rcMaxImpr = Math.max(...rcImprRate.map(Math.abs), 0.001);
                const rcNormImpr = rcImprRate.map(v => Math.max(0, v / rcMaxImpr));

                // Composite exploration signal: param_var * 0.6 + impr_rate * 0.4
                const rcSignal = rcNormVar.map((v, i) => v * 0.6 + (rcNormImpr[i] || 0) * 0.4);

                // Detect transition: find point where signal drops below 50% of initial mean
                const rcEarlyMean = rcSignal.slice(0, Math.min(5, rcSignal.length)).reduce((a, b) => a + b, 0) / Math.min(5, rcSignal.length);
                const rcThreshold = rcEarlyMean * 0.5;
                let rcTransition = rcSignal.length; // default: no transition
                for (let i = Math.floor(rcSignal.length * 0.2); i < rcSignal.length; i++) {
                  const windowMean = rcSignal.slice(Math.max(0, i - 3), i + 1).reduce((a, b) => a + b, 0) / Math.min(4, i + 1);
                  if (windowMean < rcThreshold) { rcTransition = i; break; }
                }

                const rcTransPct = rcTransition / rcSignal.length;
                const rcStatus = rcTransition >= rcSignal.length ? "No Transition" : rcTransPct < 0.4 ? "Early" : rcTransPct < 0.65 ? "On-Schedule" : "Late";
                const rcStatusColor = rcStatus === "On-Schedule" ? "var(--color-green, #22c55e)" : rcStatus === "Early" ? "var(--color-yellow, #eab308)" : rcStatus === "Late" ? "var(--color-red, #ef4444)" : "var(--color-text-muted, #94a3b8)";

                // SVG
                const rcPadL = 30, rcPadR = 10, rcChartW = 320, rcChartH = 80;
                const rcW = rcPadL + rcChartW + rcPadR;
                const rcH = rcChartH + 50;
                const rcMaxSig = Math.max(...rcSignal, 0.01);
                const rcX = (i: number) => rcPadL + (i / (rcSignal.length - 1 || 1)) * rcChartW;
                const rcY = (v: number) => 20 + (1 - v / rcMaxSig) * rcChartH;

                // Area fill for exploration vs exploitation
                const rcAreaPath = `M${rcX(0).toFixed(1)},${(20 + rcChartH).toFixed(1)} ` +
                  rcSignal.map((v, i) => `L${rcX(i).toFixed(1)},${rcY(v).toFixed(1)}`).join(" ") +
                  ` L${rcX(rcSignal.length - 1).toFixed(1)},${(20 + rcChartH).toFixed(1)} Z`;
                const rcLinePath = rcSignal.map((v, i) => `${i === 0 ? "M" : "L"}${rcX(i).toFixed(1)},${rcY(v).toFixed(1)}`).join(" ");

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 12 }}>
                      <SplitSquareVertical size={16} style={{ color: "var(--color-primary)" }} />
                      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
                        <h2 style={{ margin: 0 }}>Regime Change</h2>
                      </div>
                      <span style={{ fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: 9, background: rcStatusColor + "18", color: rcStatusColor }}>{rcStatus}{rcTransition < rcSignal.length ? ` (${(rcTransPct * 100).toFixed(0)}%)` : ""}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Exploration signal (param variance + improvement) over time. Drop = transition to exploitation.
                    </p>
                    <svg width={rcW} height={rcH} viewBox={`0 0 ${rcW} ${rcH}`} style={{ display: "block", maxWidth: "100%" }}>
                      {/* Exploration phase background */}
                      {rcTransition < rcSignal.length && (
                        <>
                          <rect x={rcPadL} y={20} width={rcX(rcTransition) - rcPadL} height={rcChartH} fill="rgba(59,130,246,0.06)" rx={2} />
                          <rect x={rcX(rcTransition)} y={20} width={rcPadL + rcChartW - rcX(rcTransition)} height={rcChartH} fill="rgba(249,115,22,0.06)" rx={2} />
                          <line x1={rcX(rcTransition)} y1={18} x2={rcX(rcTransition)} y2={20 + rcChartH + 2} stroke="#f59e0b" strokeWidth={1.5} strokeDasharray="4,3" />
                          <text x={rcX(rcTransition)} y={14} textAnchor="middle" fill="#f59e0b" fontSize={7} fontFamily="var(--font-mono)">transition</text>
                        </>
                      )}
                      {/* Area fill */}
                      <path d={rcAreaPath} fill="var(--color-primary)" opacity={0.08} />
                      {/* Line */}
                      <path d={rcLinePath} fill="none" stroke="var(--color-primary)" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
                      {/* Threshold line */}
                      <line x1={rcPadL} y1={rcY(rcThreshold)} x2={rcPadL + rcChartW} y2={rcY(rcThreshold)} stroke="var(--color-text-muted)" strokeWidth={0.5} strokeDasharray="3,3" opacity={0.5} />
                      {/* Axes */}
                      <text x={rcPadL - 4} y={24} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">High</text>
                      <text x={rcPadL - 4} y={20 + rcChartH} textAnchor="end" fill="var(--color-text-muted)" fontSize={7} fontFamily="var(--font-mono)">Low</text>
                      <text x={rcPadL + rcChartW / 2} y={rcH - 2} textAnchor="middle" fill="var(--color-text-muted)" fontSize={8} fontFamily="var(--font-mono)">Iteration</text>
                    </svg>
                    <div style={{ display: "flex", gap: 12, justifyContent: "center", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "rgba(59,130,246,0.15)", marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Exploration</span>
                      <span><span style={{ display: "inline-block", width: 10, height: 8, background: "rgba(249,115,22,0.15)", marginRight: 3, verticalAlign: "middle", borderRadius: 2 }} />Exploitation</span>
                      <span>60% variance + 40% improvement</span>
                    </div>
                  </div>
                );
              })()}

              {/* Trial Information Value */}
              {trials.length >= 10 && (() => {
                const ivTrials = trials.slice().sort((a: { iteration: number }, b: { iteration: number }) => a.iteration - b.iteration);
                const ivKpis = ivTrials.map((t: { kpis: Record<string, number> }) => t.kpis?.objective).filter((v: unknown): v is number => v != null);
                if (ivKpis.length < 10) return null;

                // For each trial, compute information value:
                // = variance reduction + novelty contribution
                const ivValues: { idx: number; infoValue: number; isExploit: boolean; cumValue: number }[] = [];
                let ivCum = 0;

                const ivParams = (campaign.spec?.parameters || []).filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null);
                const ivNorm = ivTrials.map((t: { parameters: Record<string, number> }) =>
                  ivParams.map((p: { name: string; lower?: number; upper?: number }) => {
                    const lo = p.lower!, hi = p.upper!;
                    return (hi - lo) > 0 ? ((t.parameters[p.name] ?? lo) - lo) / (hi - lo) : 0.5;
                  })
                );

                // Global KPI stats
                const ivMean = ivKpis.reduce((a: number, b: number) => a + b, 0) / ivKpis.length;
                const ivStd = Math.sqrt(ivKpis.reduce((a: number, v: number) => a + (v - ivMean) ** 2, 0) / ivKpis.length) || 0.001;
                let ivBest = Infinity;

                for (let i = 0; i < ivKpis.length; i++) {
                  // Novelty: min distance to all prior trials
                  let minDist = 1;
                  if (i > 0 && ivParams.length > 0) {
                    for (let j = 0; j < i; j++) {
                      const d = Math.sqrt(ivNorm[i].reduce((s: number, v: number, k: number) => s + (v - ivNorm[j][k]) ** 2, 0) / ivParams.length);
                      if (d < minDist) minDist = d;
                    }
                  }

                  // Variance reduction: how much this trial improved the best
                  const prevBest = ivBest;
                  if (ivKpis[i] < ivBest) ivBest = ivKpis[i];
                  const improvement = prevBest === Infinity ? 0.5 : Math.max(0, (prevBest - ivKpis[i]) / ivStd);

                  // Info value = novelty * 0.5 + improvement_signal * 0.5
                  const infoValue = minDist * 0.4 + Math.min(improvement, 1) * 0.6;
                  const isExploit = minDist < 0.15; // close to prior trial = exploitation

                  ivCum += infoValue;
                  ivValues.push({ idx: i, infoValue, isExploit, cumValue: ivCum });
                }

                // Normalize cumulative
                const ivMaxCum = ivCum || 1;
                const ivMaxVal = Math.max(...ivValues.map(v => v.infoValue), 0.01);

                // Classify: high/low info trials
                const ivMedian = [...ivValues].sort((a, b) => a.infoValue - b.infoValue)[Math.floor(ivValues.length / 2)].infoValue;
                const ivHighInfo = ivValues.filter(v => v.infoValue > ivMedian).length;
                const ivRecentHigh = ivValues.slice(-20).filter(v => v.infoValue > ivMedian).length;
                const ivStatus = ivRecentHigh / Math.min(20, ivValues.length) > 0.5 ? "Efficient" : ivRecentHigh / Math.min(20, ivValues.length) > 0.3 ? "Moderate" : "Declining";
                const ivColor = ivStatus === "Efficient" ? "var(--color-green, #22c55e)" : ivStatus === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";

                const ivPadL = 36, ivPadR = 40, ivPadT = 8, ivPadB = 24;
                const ivW = 420, ivH = 140;
                const ivPlotW = ivW - ivPadL - ivPadR, ivPlotH = ivH - ivPadT - ivPadB;

                return (
                  <div className="card" style={{ padding: 16 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
                      <BrainCircuit size={15} style={{ color: ivColor }} />
                      <h2 style={{ margin: 0 }}>Information Value</h2>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: 8, background: ivColor + "18", color: ivColor }}>{ivStatus}</span>
                    </div>
                    <p style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", margin: "0 0 8px" }}>
                      Per-trial learning contribution: novelty (40%) + improvement signal (60%).
                    </p>
                    <svg width={ivW} height={ivH} viewBox={`0 0 ${ivW} ${ivH}`} style={{ width: "100%", height: "auto" }} preserveAspectRatio="xMidYMid meet">
                      {/* Y axis for bars */}
                      <text x={ivPadL - 4} y={ivPadT + 4} textAnchor="end" fontSize={7} fill="var(--color-text-muted)">1.0</text>
                      <text x={ivPadL - 4} y={ivPadT + ivPlotH} textAnchor="end" fontSize={7} fill="var(--color-text-muted)">0</text>
                      {/* Median line */}
                      <line x1={ivPadL} y1={ivPadT + ivPlotH * (1 - ivMedian / ivMaxVal)} x2={ivPadL + ivPlotW} y2={ivPadT + ivPlotH * (1 - ivMedian / ivMaxVal)} stroke="var(--color-text-muted)" strokeDasharray="3,3" strokeWidth={0.5} opacity={0.6} />
                      <text x={ivPadL + ivPlotW + 2} y={ivPadT + ivPlotH * (1 - ivMedian / ivMaxVal) + 3} fontSize={7} fill="var(--color-text-muted)">med</text>
                      {/* Bars */}
                      {ivValues.map((v, i) => {
                        const barW = Math.max(1, ivPlotW / ivValues.length - 0.5);
                        const barH = (v.infoValue / ivMaxVal) * ivPlotH;
                        const x = ivPadL + (i / ivValues.length) * ivPlotW;
                        const color = v.isExploit ? "#f59e0b" : v.infoValue > ivMedian ? "#22c55e" : "#94a3b8";
                        return (
                          <rect key={i} x={x} y={ivPadT + ivPlotH - barH} width={barW} height={barH} fill={color} opacity={0.75} rx={0.5}>
                            <title>{`Trial ${v.idx + 1}\nInfo value: ${v.infoValue.toFixed(3)}\n${v.isExploit ? "Exploitation" : "Exploration"}`}</title>
                          </rect>
                        );
                      })}
                      {/* Cumulative curve */}
                      <polyline
                        points={ivValues.map((v, i) => `${ivPadL + (i / ivValues.length) * ivPlotW},${ivPadT + ivPlotH * (1 - v.cumValue / ivMaxCum)}`).join(" ")}
                        fill="none" stroke="#3b82f6" strokeWidth={1.5} opacity={0.8}
                      />
                      {/* Right axis label */}
                      <text x={ivW - 2} y={ivPadT + 4} textAnchor="end" fontSize={7} fill="#3b82f6">cum</text>
                      {/* X axis */}
                      <text x={ivPadL + ivPlotW / 2} y={ivH - 2} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">Trial</text>
                    </svg>
                    <div style={{ display: "flex", gap: 10, fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: 4 }}>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}><span style={{ width: 8, height: 8, borderRadius: 1, background: "#22c55e" }} /> high info</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}><span style={{ width: 8, height: 8, borderRadius: 1, background: "#f59e0b" }} /> exploit</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}><span style={{ width: 8, height: 8, borderRadius: 1, background: "#94a3b8" }} /> low info</span>
                      <span style={{ display: "flex", alignItems: "center", gap: 3 }}><span style={{ width: 16, height: 2, background: "#3b82f6" }} /> cumulative</span>
                      <span style={{ marginLeft: "auto" }}>{ivHighInfo}/{ivValues.length} informative</span>
                    </div>
                  </div>
                );
              })()}

              {/* Efficiency Trajectory — Batch 21 */}
              {trials.length >= 8 && (() => {
                const etSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const etKpis = etSorted.map(t => Object.values(t.kpis)[0] ?? 0);
                // Cumulative best and efficiency metric
                let etBest = -Infinity;
                const etCumBest: number[] = [];
                const etImprovements: boolean[] = [];
                etKpis.forEach(k => {
                  const improved = k > etBest;
                  if (improved) etBest = k;
                  etCumBest.push(etBest);
                  etImprovements.push(improved);
                });
                // Rolling efficiency: fraction of recent trials that improved the best
                const etWin = 5;
                const etEfficiency: number[] = [];
                for (let i = 0; i < etKpis.length; i++) {
                  const start = Math.max(0, i - etWin + 1);
                  const window = etImprovements.slice(start, i + 1);
                  etEfficiency.push(window.filter(Boolean).length / window.length);
                }
                // Cumulative efficiency: total improvements / total trials
                const etTotalImprove = etImprovements.filter(Boolean).length;
                const etCumEfficiency = etTotalImprove / etKpis.length;
                // Trend: compare recent vs early efficiency
                const etRecentWindow = Math.min(Math.floor(etKpis.length / 3), 10);
                const etRecentEff = etEfficiency.slice(-etRecentWindow).reduce((s, v) => s + v, 0) / etRecentWindow;
                const etEarlyEff = etEfficiency.slice(0, etRecentWindow).reduce((s, v) => s + v, 0) / etRecentWindow;
                const etTrend = etRecentEff - etEarlyEff;
                const etBadge = etCumEfficiency > 0.25 ? "Efficient" : etCumEfficiency > 0.12 ? "Normal" : "Diminishing";
                const etBadgeColor = etCumEfficiency > 0.25 ? "var(--color-green, #22c55e)" : etCumEfficiency > 0.12 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Chart dimensions
                const etW = 260, etH = 100, etPadL = 4, etPadR = 4, etPadT = 8, etPadB = 16;
                const etPlotW = etW - etPadL - etPadR;
                const etPlotH = etH - etPadT - etPadB;
                // Efficiency curve
                const etEffPoints = etEfficiency.map((e, i) => ({
                  x: etPadL + (i / Math.max(1, etEfficiency.length - 1)) * etPlotW,
                  y: etPadT + (1 - e) * etPlotH,
                }));
                const etEffPath = etEffPoints.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // Improvement markers
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Workflow size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Efficiency Trajectory</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: etBadgeColor + "18", color: etBadgeColor }}>{etBadge}</span>
                    </div>
                    <svg width={etW} height={etH} style={{ width: "100%", maxWidth: etW }}>
                      {/* Grid lines */}
                      {[0, 0.25, 0.5, 0.75, 1].map(v => (
                        <line key={`et-g-${v}`} x1={etPadL} y1={etPadT + (1 - v) * etPlotH} x2={etW - etPadR} y2={etPadT + (1 - v) * etPlotH} stroke="var(--color-border)" strokeWidth={0.4} strokeDasharray={v === 0 ? "none" : "2,3"} />
                      ))}
                      {/* Efficiency curve */}
                      <path d={etEffPath} fill="none" stroke="var(--color-primary)" strokeWidth={1.8} strokeLinecap="round" strokeLinejoin="round" />
                      {/* Improvement ticks */}
                      {etImprovements.map((imp, i) => {
                        if (!imp) return null;
                        const x = etPadL + (i / Math.max(1, etKpis.length - 1)) * etPlotW;
                        return <line key={`et-imp-${i}`} x1={x} y1={etH - etPadB + 2} x2={x} y2={etH - etPadB + 7} stroke="var(--color-green, #22c55e)" strokeWidth={1.5} />;
                      })}
                      {/* X axis label */}
                      <text x={etW / 2} y={etH - 1} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">Trial Index</text>
                      {/* Y labels */}
                      <text x={etW - 2} y={etPadT + 3} textAnchor="end" fontSize={7} fill="var(--color-text-muted)">100%</text>
                      <text x={etW - 2} y={etPadT + etPlotH + 3} textAnchor="end" fontSize={7} fill="var(--color-text-muted)">0%</text>
                    </svg>
                    <div style={{ display: "flex", flexWrap: "wrap", gap: "12px", fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "6px" }}>
                      <span>Overall: <strong style={{ color: "var(--color-text)" }}>{(etCumEfficiency * 100).toFixed(0)}%</strong> ({etTotalImprove}/{etKpis.length})</span>
                      <span>Recent: <strong style={{ color: etRecentEff > etEarlyEff ? "var(--color-green, #22c55e)" : "var(--color-red, #ef4444)" }}>{(etRecentEff * 100).toFixed(0)}%</strong></span>
                      <span>Trend: <strong style={{ color: etTrend > 0 ? "var(--color-green, #22c55e)" : "var(--color-red, #ef4444)" }}>{etTrend > 0 ? "+" : ""}{(etTrend * 100).toFixed(0)}pp</strong></span>
                    </div>
                    <div style={{ fontSize: "0.73rem", fontStyle: "italic", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {etTrend > 0.05 ? "Efficiency improving — optimization is accelerating." : etTrend > -0.05 ? "Steady efficiency — normal optimization trajectory." : "Efficiency declining — consider changing strategy or stopping."}
                      <span style={{ display: "flex", alignItems: "center", gap: "3px", marginTop: "3px" }}>
                        <span style={{ width: 10, height: 2, background: "var(--color-green, #22c55e)", display: "inline-block" }} /> = improvement found
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Importance Trajectory — Batch 22 */}
              {trials.length >= 15 && (() => {
                const itSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (itSpecs.length < 2) return null;
                const itSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const itKpis = itSorted.map(t => Object.values(t.kpis)[0] ?? 0);
                const itWinSize = Math.max(8, Math.floor(itSorted.length / 5));
                const itStep = Math.max(1, Math.floor(itWinSize / 2));
                // Sliding-window variance-based importance
                const itWindows: { importances: number[] }[] = [];
                for (let start = 0; start <= itSorted.length - itWinSize; start += itStep) {
                  const winTrials = itSorted.slice(start, start + itWinSize);
                  const winKpis = itKpis.slice(start, start + itWinSize);
                  const kpiVar = (() => {
                    const m = winKpis.reduce((s, v) => s + v, 0) / winKpis.length;
                    return winKpis.reduce((s, v) => s + (v - m) ** 2, 0) / winKpis.length;
                  })();
                  if (kpiVar < 1e-12) {
                    itWindows.push({ importances: itSpecs.map(() => 1 / itSpecs.length) });
                    continue;
                  }
                  // For each parameter, compute correlation-based importance
                  const imps = itSpecs.map((spec: { name: string; lower?: number; upper?: number }) => {
                    const pVals = winTrials.map(t => t.parameters[spec.name] ?? 0);
                    const pMean = pVals.reduce((s, v) => s + v, 0) / pVals.length;
                    const kMean = winKpis.reduce((s, v) => s + v, 0) / winKpis.length;
                    let num = 0, denP = 0, denK = 0;
                    pVals.forEach((p, i) => {
                      num += (p - pMean) * (winKpis[i] - kMean);
                      denP += (p - pMean) ** 2;
                      denK += (winKpis[i] - kMean) ** 2;
                    });
                    const corr = (denP > 0 && denK > 0) ? num / Math.sqrt(denP * denK) : 0;
                    return corr * corr; // R² as importance
                  });
                  const impSum = imps.reduce((s, v) => s + v, 0) || 1;
                  itWindows.push({ importances: imps.map(v => v / impSum) });
                }
                if (itWindows.length < 3) return null;
                // Stability: average rank correlation between consecutive windows
                let itRankCorr = 0;
                for (let i = 1; i < itWindows.length; i++) {
                  const prev = itWindows[i - 1].importances;
                  const curr = itWindows[i].importances;
                  const pRanks = prev.map((v, idx) => ({ v, idx })).sort((a, b) => b.v - a.v).map((item, r) => ({ idx: item.idx, r }));
                  const cRanks = curr.map((v, idx) => ({ v, idx })).sort((a, b) => b.v - a.v).map((item, r) => ({ idx: item.idx, r }));
                  let dSq = 0;
                  pRanks.forEach(pr => {
                    const cr = cRanks.find(c => c.idx === pr.idx);
                    dSq += (pr.r - (cr?.r ?? 0)) ** 2;
                  });
                  const n = prev.length;
                  itRankCorr += 1 - (6 * dSq) / (n * (n * n - 1));
                }
                itRankCorr /= (itWindows.length - 1);
                const itBadge = itRankCorr > 0.7 ? "Stable" : itRankCorr > 0.3 ? "Shifting" : "Volatile";
                const itBadgeColor = itRankCorr > 0.7 ? "var(--color-green, #22c55e)" : itRankCorr > 0.3 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Stacked area chart
                const itW = 260, itH = 100, itPadL = 4, itPadR = 4, itPadT = 6, itPadB = 14;
                const itPlotW = itW - itPadL - itPadR;
                const itPlotH = itH - itPadT - itPadB;
                // Colors for parameters (using HSL spread)
                const itColors = itSpecs.map((_: unknown, i: number) => `hsl(${(i * 360) / itSpecs.length}, 65%, 55%)`);
                // Build stacked area paths for each parameter
                const itAreas = itSpecs.map((_: unknown, pIdx: number) => {
                  const pts: { x: number; yTop: number; yBottom: number }[] = itWindows.map((w, wi) => {
                    const x = itPadL + (wi / Math.max(1, itWindows.length - 1)) * itPlotW;
                    const cumBelow = w.importances.slice(0, pIdx).reduce((s, v) => s + v, 0);
                    const cumAbove = cumBelow + w.importances[pIdx];
                    return { x, yTop: itPadT + (1 - cumAbove) * itPlotH, yBottom: itPadT + (1 - cumBelow) * itPlotH };
                  });
                  const topPath = pts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.yTop.toFixed(1)}`).join(" ");
                  const bottomPath = [...pts].reverse().map((p, i) => `${i === 0 ? "L" : "L"}${p.x.toFixed(1)},${p.yBottom.toFixed(1)}`).join(" ");
                  return `${topPath} ${bottomPath} Z`;
                });
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Milestone size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Importance Trajectory</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: itBadgeColor + "18", color: itBadgeColor }}>{itBadge}</span>
                    </div>
                    <svg width={itW} height={itH} style={{ width: "100%", maxWidth: itW }}>
                      {itAreas.map((d, i) => (
                        <path key={`it-area-${i}`} d={d} fill={itColors[i]} opacity={0.6} stroke={itColors[i]} strokeWidth={0.5}>
                          <title>{itSpecs[i].name}</title>
                        </path>
                      ))}
                      <text x={itW / 2} y={itH - 1} textAnchor="middle" fontSize={8} fill="var(--color-text-muted)">Window Index</text>
                    </svg>
                    <div style={{ display: "flex", flexWrap: "wrap", gap: "6px", marginTop: "4px" }}>
                      {itSpecs.map((s: { name: string }, i: number) => (
                        <span key={s.name} style={{ display: "flex", alignItems: "center", gap: "3px", fontSize: "0.68rem" }}>
                          <span style={{ width: 8, height: 8, borderRadius: 2, background: itColors[i], display: "inline-block" }} />
                          {s.name}
                        </span>
                      ))}
                    </div>
                    <div style={{ fontSize: "0.73rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      Rank stability: <strong style={{ color: "var(--color-text)" }}>ρ = {itRankCorr.toFixed(2)}</strong>
                      <span style={{ marginLeft: "6px", fontStyle: "italic" }}>
                        {itRankCorr > 0.7 ? " — parameter importance is consistent" : itRankCorr > 0.3 ? " — importance is shifting between parameters" : " — volatile rankings indicate complex landscape"}
                      </span>
                    </div>
                  </div>
                );
              })()}

              {/* Sequence Learning Asymmetry */}
              {trials.length >= 15 && (() => {
                const slObjKey = Object.keys(trials[0].kpis)[0];
                const slSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Split trials into batches of 5 (simulating experimental batches)
                const slBatchSize = 5;
                const slBatches: typeof slSorted[] = [];
                for (let i = 0; i + slBatchSize <= slSorted.length; i += slBatchSize) {
                  slBatches.push(slSorted.slice(i, i + slBatchSize));
                }
                if (slBatches.length < 2) return null;
                // For each batch, compute position vs residual correlation
                // Expected value = running mean up to that point
                const slBatchScores: { batchIdx: number; asymmetry: number; earlyAvg: number; lateAvg: number }[] = [];
                for (let bi = 0; bi < slBatches.length; bi++) {
                  const batch = slBatches[bi];
                  // Expected = mean of all trials before this batch
                  const prior = slSorted.slice(0, bi * slBatchSize);
                  const expectedVal = prior.length > 0 ? prior.reduce((s, t) => s + (t.kpis[slObjKey] ?? 0), 0) / prior.length : 0;
                  const residuals = batch.map(t => (t.kpis[slObjKey] ?? 0) - expectedVal);
                  const positions = batch.map((_, i) => i);
                  // Spearman rank correlation of position vs residual
                  const rankArr = (arr: number[]) => {
                    const sorted = [...arr].sort((a, b) => a - b);
                    return arr.map(v => sorted.indexOf(v) + 1);
                  };
                  const posRanks = rankArr(positions);
                  const resRanks = rankArr(residuals);
                  const n = batch.length;
                  const dSqSum = posRanks.reduce((s, r, i) => s + (r - resRanks[i]) ** 2, 0);
                  const rho = 1 - (6 * dSqSum) / (n * (n * n - 1));
                  const earlyAvg = residuals.slice(0, Math.floor(n / 2)).reduce((s, v) => s + v, 0) / Math.floor(n / 2);
                  const lateAvg = residuals.slice(Math.ceil(n / 2)).reduce((s, v) => s + v, 0) / (n - Math.ceil(n / 2));
                  slBatchScores.push({ batchIdx: bi + 1, asymmetry: rho, earlyAvg, lateAvg });
                }
                const slMedian = (() => {
                  const vals = slBatchScores.map(s => s.asymmetry).sort((a, b) => a - b);
                  const mid = Math.floor(vals.length / 2);
                  return vals.length % 2 === 0 ? (vals[mid - 1] + vals[mid]) / 2 : vals[mid];
                })();
                const slBadge = slMedian > 0.3 ? "Learning" : slMedian > -0.1 ? "Neutral" : "Regressing";
                const slColor = slMedian > 0.3 ? "var(--color-green, #22c55e)" : slMedian > -0.1 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Bar chart of asymmetry per batch
                const slW = 280, slH = 140, slPadL = 35, slPadR = 10, slPadT = 15, slPadB = 25;
                const slPlotW = slW - slPadL - slPadR, slPlotH = slH - slPadT - slPadB;
                const slBarW = Math.min(24, slPlotW / slBatchScores.length * 0.7);
                const slGap = (slPlotW - slBarW * slBatchScores.length) / (slBatchScores.length + 1);
                const slMidY = slPadT + slPlotH / 2; // zero line
                return (
                  <div className="card" style={{ padding: "20px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "10px", marginBottom: "12px" }}>
                      <ArrowRightLeft size={18} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.95rem" }}>Sequence Learning Asymmetry</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: slColor + "22", color: slColor }}>{slBadge}</span>
                    </div>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginBottom: "8px" }}>
                      Do later trials in each batch outperform earlier ones? Positive = within-batch learning effect.
                    </div>
                    <svg width={slW} height={slH} viewBox={`0 0 ${slW} ${slH}`} style={{ width: "100%", height: "auto" }}>
                      {/* Zero line */}
                      <line x1={slPadL} y1={slMidY} x2={slW - slPadR} y2={slMidY} stroke="var(--color-text-muted)" strokeWidth="0.8" strokeDasharray="4,3" />
                      <text x={slPadL - 4} y={slMidY + 3} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>0</text>
                      <text x={slPadL - 4} y={slPadT + 5} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>+1</text>
                      <text x={slPadL - 4} y={slH - slPadB + 3} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>-1</text>
                      {/* Bars */}
                      {slBatchScores.map((bs, i) => {
                        const x = slPadL + slGap + i * (slBarW + slGap);
                        const barH = Math.abs(bs.asymmetry) * (slPlotH / 2);
                        const y = bs.asymmetry >= 0 ? slMidY - barH : slMidY;
                        const c = bs.asymmetry > 0.3 ? "var(--color-green, #22c55e)" : bs.asymmetry > -0.1 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={i}>
                            <rect x={x} y={y} width={slBarW} height={Math.max(1, barH)} rx="2" fill={c} opacity={0.7}>
                              <title>Batch {bs.batchIdx}: ρ={bs.asymmetry.toFixed(2)}</title>
                            </rect>
                            <text x={x + slBarW / 2} y={slH - slPadB + 12} textAnchor="middle" style={{ fontSize: "0.48rem", fill: "var(--color-text-muted)" }}>B{bs.batchIdx}</text>
                          </g>
                        );
                      })}
                      {/* Median line */}
                      {(() => {
                        const my = slMidY - slMedian * (slPlotH / 2);
                        return <line x1={slPadL} y1={my} x2={slW - slPadR} y2={my} stroke={slColor} strokeWidth="1.5" strokeDasharray="6,3" opacity={0.7} />;
                      })()}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "6px", fontSize: "0.72rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>Median asymmetry: <span style={{ fontWeight: 600, fontFamily: "var(--font-mono)", color: slColor }}>{slMedian > 0 ? "+" : ""}{slMedian.toFixed(2)}</span></span>
                      <span style={{ color: "var(--color-text-muted)" }}>{slBatches.length} batches of {slBatchSize}</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {slBadge === "Learning" ? "Later trials in batches outperform — sequential learning is effective." :
                       slBadge === "Neutral" ? "No significant order effect — batch trials are independent." :
                       "Later trials underperform — consider randomizing batch order."}
                    </div>
                  </div>
                );
              })()}

              {/* Regret vs Bound — cumulative regret vs theoretical O(√T·logT) bound */}
              {trials.length >= 6 && (() => {
                const rbSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const rbObjKey = Object.keys(rbSorted[0].kpis)[0];
                if (!rbObjKey) return null;
                const rbDir = campaign.objective_directions?.[rbObjKey] === "minimize" ? -1 : 1;
                const rbValues = rbSorted.map(t => (Number(t.kpis[rbObjKey]) || 0) * rbDir); // higher = better
                const rbN = rbValues.length;
                // Compute cumulative regret: sum of (best_so_far - current) at each step
                let rbBestSoFar = -Infinity;
                const rbInstRegret: number[] = [];
                for (let i = 0; i < rbN; i++) {
                  if (rbValues[i] > rbBestSoFar) rbBestSoFar = rbValues[i];
                  rbInstRegret.push(Math.max(0, rbBestSoFar - rbValues[i]));
                }
                const rbCumRegret: number[] = [];
                let rbSum = 0;
                for (let i = 0; i < rbN; i++) {
                  rbSum += rbInstRegret[i];
                  rbCumRegret.push(rbSum);
                }
                // Theoretical bound: C * √T * log(T), calibrated to match at T=N
                const rbBound: number[] = [];
                const rbLogN = Math.log(rbN + 1);
                const rbSqrtN = Math.sqrt(rbN);
                const rbC = rbCumRegret[rbN - 1] > 0 ? rbCumRegret[rbN - 1] / (rbSqrtN * rbLogN) : 1;
                for (let i = 0; i < rbN; i++) {
                  const t = i + 1;
                  rbBound.push(rbC * Math.sqrt(t) * Math.log(t + 1));
                }
                // Compute regret ratio: actual / bound at each point
                const rbRatios = rbCumRegret.map((r, i) => rbBound[i] > 0 ? r / rbBound[i] : 0);
                const rbAvgRatio = rbRatios.length > 0 ? rbRatios.reduce((s, v) => s + v, 0) / rbRatios.length : 0;
                const rbBadge = rbAvgRatio < 0.6 ? "Near-Optimal" : rbAvgRatio < 1.0 ? "Acceptable" : "Inefficient";
                const rbBadgeColor = rbAvgRatio < 0.6 ? "var(--color-green, #22c55e)" : rbAvgRatio < 1.0 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Chart dimensions
                const rbW = 300, rbH = 120, rbPadL = 35, rbPadR = 10, rbPadT = 15, rbPadB = 22;
                const rbPlotW = rbW - rbPadL - rbPadR;
                const rbPlotH = rbH - rbPadT - rbPadB;
                const rbMaxY = Math.max(...rbCumRegret, ...rbBound, 1);
                const rbPts = rbCumRegret.map((r, i) => ({
                  x: rbPadL + (i / (rbN - 1)) * rbPlotW,
                  y: rbPadT + (1 - r / rbMaxY) * rbPlotH,
                }));
                const rbBoundPts = rbBound.map((b, i) => ({
                  x: rbPadL + (i / (rbN - 1)) * rbPlotW,
                  y: rbPadT + (1 - b / rbMaxY) * rbPlotH,
                }));
                const rbLine = rbPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                const rbBoundLine = rbBoundPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // Area between bound and regret (fill region)
                const rbAreaPath = rbBoundPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ") +
                  rbPts.slice().reverse().map(p => `L${p.x.toFixed(1)},${p.y.toFixed(1)}`).join("") + " Z";
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Calculator size={16} style={{ color: "var(--color-text-muted)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.85rem" }}>Regret vs Bound</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.7rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: rbBadgeColor + "18", color: rbBadgeColor }}>{rbBadge}</span>
                    </div>
                    <svg width={rbW} height={rbH} viewBox={`0 0 ${rbW} ${rbH}`} style={{ display: "block", margin: "0 auto" }}>
                      <defs>
                        <linearGradient id="rbGapGrad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor={rbBadgeColor} stopOpacity="0.15" />
                          <stop offset="100%" stopColor={rbBadgeColor} stopOpacity="0.02" />
                        </linearGradient>
                      </defs>
                      {/* Grid lines */}
                      {[0.25, 0.5, 0.75].map(v => (
                        <line key={v} x1={rbPadL} y1={rbPadT + (1 - v) * rbPlotH} x2={rbW - rbPadR} y2={rbPadT + (1 - v) * rbPlotH} stroke="var(--color-border)" strokeWidth="0.5" strokeDasharray="3,3" />
                      ))}
                      {/* Area between */}
                      <path d={rbAreaPath} fill="url(#rbGapGrad)" />
                      {/* Bound curve (dashed) */}
                      <path d={rbBoundLine} fill="none" stroke="var(--color-text-muted)" strokeWidth="1.5" strokeDasharray="5,3" opacity={0.5} />
                      {/* Actual regret curve */}
                      <path d={rbLine} fill="none" stroke={rbBadgeColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Endpoints */}
                      <circle cx={rbPts[rbPts.length - 1].x} cy={rbPts[rbPts.length - 1].y} r="3.5" fill={rbBadgeColor} />
                      <circle cx={rbBoundPts[rbBoundPts.length - 1].x} cy={rbBoundPts[rbBoundPts.length - 1].y} r="2.5" fill="var(--color-text-muted)" opacity={0.5} />
                      {/* Y-axis labels */}
                      <text x={rbPadL - 3} y={rbPadT + 4} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>{rbMaxY.toFixed(1)}</text>
                      <text x={rbPadL - 3} y={rbH - rbPadB + 4} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)", fontFamily: "var(--font-mono)" }}>0</text>
                      {/* X-axis labels */}
                      <text x={rbPadL} y={rbH - 3} textAnchor="start" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>#1</text>
                      <text x={rbW - rbPadR} y={rbH - 3} textAnchor="end" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>#{rbN}</text>
                      <text x={(rbPadL + rbW - rbPadR) / 2} y={rbH - 3} textAnchor="middle" style={{ fontSize: "0.5rem", fill: "var(--color-text-muted)" }}>Trial</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "center", gap: "16px", marginTop: "6px", fontSize: "0.72rem" }}>
                      <span style={{ display: "flex", alignItems: "center", gap: "4px" }}>
                        <span style={{ width: "14px", height: "2px", background: rbBadgeColor, borderRadius: "1px", display: "inline-block" }}></span>
                        <span style={{ color: "var(--color-text-muted)" }}>Actual regret</span>
                      </span>
                      <span style={{ display: "flex", alignItems: "center", gap: "4px" }}>
                        <span style={{ width: "14px", height: "2px", background: "var(--color-text-muted)", borderRadius: "1px", display: "inline-block", borderTop: "1px dashed var(--color-text-muted)" }}></span>
                        <span style={{ color: "var(--color-text-muted)" }}>O(√T·logT) bound</span>
                      </span>
                    </div>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "6px", fontSize: "0.75rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>Total regret: <span style={{ fontWeight: 600, fontFamily: "var(--font-mono)" }}>{rbCumRegret[rbN - 1].toFixed(3)}</span></span>
                      <span style={{ color: rbBadgeColor, fontWeight: 600 }}>Ratio: {rbAvgRatio.toFixed(2)}x bound</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {rbBadge === "Near-Optimal" ? "Optimization outperforms theoretical bound — excellent exploration-exploitation balance." :
                       rbBadge === "Acceptable" ? "Regret tracks close to bound — reasonable optimization efficiency." :
                       "Regret exceeds theoretical bound — consider more aggressive exploitation or model tuning."}
                    </div>
                  </div>
                );
              })()}

              {/* Discovery Cadence */}
              {trials.length >= 6 && (() => {
                const dcObjKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!dcObjKey) return null;
                const dcSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Find new-best events (cumulative best improvement)
                let dcBest = dcSorted[0].kpis[dcObjKey];
                const dcEvents: { iteration: number; value: number; gap: number }[] = [{ iteration: dcSorted[0].iteration, value: dcBest, gap: 0 }];
                for (let i = 1; i < dcSorted.length; i++) {
                  const v = dcSorted[i].kpis[dcObjKey];
                  if (v < dcBest) {
                    dcEvents.push({ iteration: dcSorted[i].iteration, value: v, gap: dcSorted[i].iteration - dcEvents[dcEvents.length - 1].iteration });
                    dcBest = v;
                  }
                }
                if (dcEvents.length < 2) return null;
                // Gaps between discoveries (skip first which has gap=0)
                const dcGaps = dcEvents.slice(1).map(e => e.gap);
                const dcMaxGap = Math.max(...dcGaps);
                const dcAvgGap = dcGaps.reduce((s, g) => s + g, 0) / dcGaps.length;
                // Trend: compare first half avg vs second half avg
                const dcHalf = Math.floor(dcGaps.length / 2);
                const dcFirstHalf = dcHalf > 0 ? dcGaps.slice(0, dcHalf).reduce((s, g) => s + g, 0) / dcHalf : dcAvgGap;
                const dcSecondHalf = dcHalf > 0 ? dcGaps.slice(dcHalf).reduce((s, g) => s + g, 0) / (dcGaps.length - dcHalf) : dcAvgGap;
                const dcRatio = dcFirstHalf > 0 ? dcSecondHalf / dcFirstHalf : 1;
                const dcBadge = dcRatio < 1.2 ? "Frequent" : dcRatio < 2.5 ? "Slowing" : "Stalled";
                const dcBadgeColor = dcRatio < 1.2 ? "var(--color-green, #22c55e)" : dcRatio < 2.5 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // SVG bar chart of gaps
                const dcW = 260, dcH = 90, dcPadL = 28, dcPadR = 4, dcPadT = 8, dcPadB = 16;
                const dcPlotW = dcW - dcPadL - dcPadR;
                const dcPlotH = dcH - dcPadT - dcPadB;
                const dcBarW = Math.min(18, Math.max(4, dcPlotW / dcGaps.length - 2));
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Snail size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Discovery Cadence</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: dcBadgeColor + "18", color: dcBadgeColor }}>{dcBadge}</span>
                    </div>
                    <svg width={dcW} height={dcH} style={{ width: "100%", maxWidth: dcW }}>
                      {/* Y-axis label */}
                      <text x={2} y={dcPadT + dcPlotH / 2} textAnchor="start" fontSize={7} fill="var(--color-text-muted)" transform={`rotate(-90, 2, ${dcPadT + dcPlotH / 2})`} dominantBaseline="middle">Gap (iter)</text>
                      {/* Bars */}
                      {dcGaps.map((g, i) => {
                        const barH = dcMaxGap > 0 ? (g / dcMaxGap) * dcPlotH : 0;
                        const x = dcPadL + (i / Math.max(1, dcGaps.length - 1)) * (dcPlotW - dcBarW);
                        const barColor = g <= dcAvgGap ? "var(--color-green, #22c55e)" : g <= dcAvgGap * 2 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={`dc-bar-${i}`}>
                            <rect x={x} y={dcPadT + dcPlotH - barH} width={dcBarW} height={barH} rx={2} fill={barColor} opacity={0.7}>
                              <title>Discovery #{i + 2}: gap = {g} iterations (value = {dcEvents[i + 1].value.toFixed(4)})</title>
                            </rect>
                            {dcGaps.length <= 12 && (
                              <text x={x + dcBarW / 2} y={dcH - 3} textAnchor="middle" fontSize={6.5} fill="var(--color-text-muted)">#{i + 2}</text>
                            )}
                          </g>
                        );
                      })}
                      {/* Average line */}
                      {dcMaxGap > 0 && (
                        <line x1={dcPadL - 2} x2={dcPadL + dcPlotW} y1={dcPadT + dcPlotH - (dcAvgGap / dcMaxGap) * dcPlotH} y2={dcPadT + dcPlotH - (dcAvgGap / dcMaxGap) * dcPlotH} stroke="var(--color-primary)" strokeWidth={1} strokeDasharray="3,2" opacity={0.6} />
                      )}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "4px", fontSize: "0.73rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>{dcEvents.length} discoveries in {dcSorted.length} trials</span>
                      <span style={{ fontWeight: 600, fontFamily: "var(--font-mono)", color: "var(--color-text)" }}>Avg gap: {dcAvgGap.toFixed(1)} iter</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {dcBadge === "Frequent" ? "Discoveries occur at a steady pace — optimization is actively finding improvements." :
                       dcBadge === "Slowing" ? "Gaps between discoveries are widening — may be approaching optimum or needing strategy change." :
                       "Long gaps between discoveries — consider restarting exploration or adjusting search bounds."}
                    </div>
                  </div>
                );
              })()}

              {/* Experiment Replay Value */}
              {trials.length >= 20 && (() => {
                const rvObjKey = Object.keys(trials[0]?.kpis || {})[0];
                if (!rvObjKey) return null;
                const rvSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                // Split into windows and do leave-one-window-out prediction
                const rvWinSize = Math.max(5, Math.floor(rvSorted.length / 6));
                const rvWindows: typeof rvSorted[] = [];
                for (let i = 0; i + rvWinSize <= rvSorted.length; i += rvWinSize) {
                  rvWindows.push(rvSorted.slice(i, i + rvWinSize));
                }
                if (rvWindows.length < 3) return null;
                // For each window, use all OTHER windows to predict ranking within this window via k-NN
                const rvParamNames = Object.keys(rvSorted[0].parameters);
                const rvResults = rvWindows.map((win, wi) => {
                  const others = rvWindows.filter((_w, i) => i !== wi).flat();
                  // For each trial in window, predict its rank using k-NN from others
                  const predictions = win.map(t => {
                    const dists = others.map(o => {
                      const d = Math.sqrt(rvParamNames.reduce((s, p) => s + ((Number(t.parameters[p]) || 0) - (Number(o.parameters[p]) || 0)) ** 2, 0));
                      return { d, kpi: o.kpis[rvObjKey] };
                    }).sort((a, b) => a.d - b.d);
                    const k = Math.min(5, others.length);
                    const predKpi = dists.slice(0, k).reduce((s, d) => s + d.kpi, 0) / k;
                    return { actual: t.kpis[rvObjKey], predicted: predKpi };
                  });
                  // Compute Spearman rank correlation for this window
                  const rank = (arr: number[]) => {
                    const indexed = arr.map((v, i) => ({ v, i })).sort((a, b) => a.v - b.v);
                    const ranks = new Array(arr.length);
                    indexed.forEach((item, r) => { ranks[item.i] = r; });
                    return ranks;
                  };
                  const actRanks = rank(predictions.map(p => p.actual));
                  const predRanks = rank(predictions.map(p => p.predicted));
                  const n = predictions.length;
                  let dSq = 0;
                  for (let k = 0; k < n; k++) dSq += (actRanks[k] - predRanks[k]) ** 2;
                  const rho = 1 - (6 * dSq) / (n * (n * n - 1));
                  return { windowIdx: wi, rho, n };
                });
                const rvAvgRho = rvResults.reduce((s, r) => s + r.rho, 0) / rvResults.length;
                const rvBadge = rvAvgRho > 0.6 ? "Predictable" : rvAvgRho > 0.2 ? "Noisy" : "Unpredictable";
                const rvBadgeColor = rvAvgRho > 0.6 ? "var(--color-green, #22c55e)" : rvAvgRho > 0.2 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // Bar chart of per-window ρ
                const rvW = 260, rvH = 90, rvPadL = 28, rvPadR = 4, rvPadT = 8, rvPadB = 16;
                const rvPlotW = rvW - rvPadL - rvPadR;
                const rvPlotH = rvH - rvPadT - rvPadB;
                const rvBarW = Math.min(24, Math.max(6, rvPlotW / rvResults.length - 3));
                const rvMidY = rvPadT + rvPlotH / 2; // ρ=0 line
                return (
                  <div className="card" style={{ padding: "16px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Repeat2 size={15} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.88rem" }}>Experiment Replay Value</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", fontWeight: 600, padding: "2px 8px", borderRadius: "8px", background: rvBadgeColor + "18", color: rvBadgeColor }}>{rvBadge}</span>
                    </div>
                    <svg width={rvW} height={rvH} style={{ width: "100%", maxWidth: rvW }}>
                      {/* Zero line */}
                      <line x1={rvPadL} x2={rvPadL + rvPlotW} y1={rvMidY} y2={rvMidY} stroke="var(--color-border)" strokeWidth={0.8} />
                      <text x={rvPadL - 3} y={rvPadT + 4} textAnchor="end" fontSize={6.5} fill="var(--color-text-muted)">+1</text>
                      <text x={rvPadL - 3} y={rvMidY + 2} textAnchor="end" fontSize={6.5} fill="var(--color-text-muted)">0</text>
                      <text x={rvPadL - 3} y={rvPadT + rvPlotH} textAnchor="end" fontSize={6.5} fill="var(--color-text-muted)">-1</text>
                      {/* Bars */}
                      {rvResults.map((r, i) => {
                        const x = rvPadL + (i / Math.max(1, rvResults.length - 1)) * (rvPlotW - rvBarW);
                        const barH = Math.abs(r.rho) * (rvPlotH / 2);
                        const y = r.rho >= 0 ? rvMidY - barH : rvMidY;
                        const barColor = r.rho > 0.6 ? "var(--color-green, #22c55e)" : r.rho > 0.2 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={`rv-bar-${i}`}>
                            <rect x={x} y={y} width={rvBarW} height={Math.max(1, barH)} rx={2} fill={barColor} opacity={0.7}>
                              <title>Window {i + 1}: ρ = {r.rho.toFixed(3)} (n={r.n})</title>
                            </rect>
                            <text x={x + rvBarW / 2} y={rvH - 2} textAnchor="middle" fontSize={6.5} fill="var(--color-text-muted)">W{i + 1}</text>
                          </g>
                        );
                      })}
                      {/* Average line */}
                      {(() => {
                        const avgY = rvMidY - rvAvgRho * (rvPlotH / 2);
                        return <line x1={rvPadL} x2={rvPadL + rvPlotW} y1={avgY} y2={avgY} stroke="var(--color-primary)" strokeWidth={1} strokeDasharray="3,2" opacity={0.6} />;
                      })()}
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", marginTop: "4px", fontSize: "0.73rem" }}>
                      <span style={{ color: "var(--color-text-muted)" }}>Leave-one-window-out prediction</span>
                      <span style={{ fontWeight: 600, fontFamily: "var(--font-mono)", color: "var(--color-text)" }}>Avg ρ = {rvAvgRho.toFixed(3)}</span>
                    </div>
                    <div style={{ fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px", textAlign: "center" }}>
                      {rvBadge === "Predictable" ? "Past experiments replay well — the model is capturing the true response surface." :
                       rvBadge === "Noisy" ? "Partial predictability — results are moderately influenced by noise or unmodeled factors." :
                       "Low replay fidelity — the response surface may be highly complex or noisy."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Regime Change Detector (Batch 27) ── */}
              {(() => {
                if (trials.length < 12) return null;
                const kpiKey = Object.keys(trials[0].kpis || {})[0];
                if (!kpiKey) return null;
                const rcVals = trials.map((t: { kpis: Record<string, number> }) => t.kpis[kpiKey]).filter((v: number) => v != null);
                if (rcVals.length < 12) return null;
                // CUSUM changepoint detection
                const rcMean = rcVals.reduce((s: number, v: number) => s + v, 0) / rcVals.length;
                const rcStd = Math.sqrt(rcVals.reduce((s: number, v: number) => s + (v - rcMean) ** 2, 0) / rcVals.length) || 1;
                const rcThreshold = rcStd * 1.5; // sensitivity threshold
                let rcCusum = 0;
                let rcCusumNeg = 0;
                const rcChangepoints: number[] = [];
                const rcCusumVals: number[] = [];
                for (let i = 0; i < rcVals.length; i++) {
                  const z = (rcVals[i] - rcMean) / rcStd;
                  rcCusum = Math.max(0, rcCusum + z - 0.5);
                  rcCusumNeg = Math.max(0, rcCusumNeg - z - 0.5);
                  rcCusumVals.push(rcCusum - rcCusumNeg);
                  if (rcCusum > rcThreshold || rcCusumNeg > rcThreshold) {
                    rcChangepoints.push(i);
                    rcCusum = 0;
                    rcCusumNeg = 0;
                  }
                }
                const rcNumChanges = rcChangepoints.length;
                const rcBadge = rcNumChanges === 0 ? "Stable" : rcNumChanges <= 2 ? "Shifting" : "Volatile";
                const rcBadgeColor = rcBadge === "Stable" ? "var(--color-green, #22c55e)" : rcBadge === "Shifting" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // render timeline with CUSUM curve and changepoint markers
                const rcW = 260, rcH = 80;
                const rcPad = { l: 5, r: 5, t: 8, b: 14 };
                const rcPlotW = rcW - rcPad.l - rcPad.r;
                const rcPlotH = rcH - rcPad.t - rcPad.b;
                const rcCMin = Math.min(...rcCusumVals);
                const rcCMax = Math.max(...rcCusumVals);
                const rcCRange = rcCMax - rcCMin || 1;
                const rcPoints = rcCusumVals.map((v, i) => ({
                  x: rcPad.l + (i / (rcCusumVals.length - 1)) * rcPlotW,
                  y: rcPad.t + (1 - (v - rcCMin) / rcCRange) * rcPlotH,
                }));
                const rcLine = rcPoints.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                // zero line
                const rcZeroY = rcPad.t + (1 - (0 - rcCMin) / rcCRange) * rcPlotH;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <ScanLine size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Regime Change Detector</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: rcBadgeColor, color: "#fff" }}>{rcBadge}</span>
                    </div>
                    <svg width={rcW} height={rcH} viewBox={`0 0 ${rcW} ${rcH}`} style={{ display: "block", width: "100%" }}>
                      {/* zero line */}
                      <line x1={rcPad.l} y1={rcZeroY} x2={rcW - rcPad.r} y2={rcZeroY} stroke="var(--color-text-muted, #94a3b8)" strokeWidth="0.5" strokeDasharray="3,3" />
                      {/* CUSUM curve */}
                      <path d={rcLine} fill="none" stroke="var(--color-primary, #6366f1)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                      {/* changepoint markers */}
                      {rcChangepoints.map((cp, i) => {
                        const px = rcPad.l + (cp / (rcCusumVals.length - 1)) * rcPlotW;
                        return (
                          <g key={i}>
                            <line x1={px} y1={rcPad.t} x2={px} y2={rcH - rcPad.b} stroke="var(--color-red, #ef4444)" strokeWidth="1.5" strokeDasharray="4,3" opacity="0.7" />
                            <circle cx={px} cy={rcPad.t + 2} r="3.5" fill="var(--color-red, #ef4444)" />
                            <text x={px} y={rcH - 2} textAnchor="middle" fontSize="8" fontFamily="var(--font-mono)" fill="var(--color-red, #ef4444)">#{cp + 1}</text>
                          </g>
                        );
                      })}
                      {/* iteration axis labels */}
                      <text x={rcPad.l} y={rcH - 2} fontSize="8" fill="var(--color-text-muted, #64748b)">1</text>
                      <text x={rcW - rcPad.r} y={rcH - 2} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">{rcVals.length}</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      CUSUM detected {rcNumChanges} regime change{rcNumChanges !== 1 ? "s" : ""} — {rcBadge === "Stable" ? "consistent optimization dynamics throughout." : rcBadge === "Shifting" ? "optimization strategy adapted during the campaign." : "frequent shifts in optimization landscape."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Search Focus Drift (Batch 28) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 12) return null;
                const sfSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (sfSpecs.length === 0) return null;
                const sfObs = campaign.observations;
                // divide observations into windows
                const sfWinSize = Math.max(4, Math.floor(sfObs.length / 8));
                const sfWindows: { parameters: Record<string, number> }[][] = [];
                for (let i = 0; i + sfWinSize <= sfObs.length; i += Math.max(1, Math.floor(sfWinSize / 2))) {
                  sfWindows.push(sfObs.slice(i, i + sfWinSize));
                }
                if (sfWindows.length < 3) return null;
                // compute centroid per window in normalized space
                const sfCentroids = sfWindows.map(win => {
                  const centroid: Record<string, number> = {};
                  sfSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    const avg = win.reduce((sum: number, o: { parameters: Record<string, number> }) => sum + ((o.parameters[s.name] || 0) - (s.lower || 0)) / (range || 1), 0) / win.length;
                    centroid[s.name] = avg;
                  });
                  return centroid;
                });
                // compute distance from each centroid to the first centroid (drift from start)
                const sfDists = sfCentroids.map(c => {
                  let sum = 0;
                  sfSpecs.forEach((s: { name: string }) => {
                    sum += (c[s.name] - sfCentroids[0][s.name]) ** 2;
                  });
                  return Math.sqrt(sum / sfSpecs.length);
                });
                // also compute variance within each window (spread = how focused)
                const sfSpreads = sfWindows.map(win => {
                  let totalVar = 0;
                  sfSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                    const range = (s.upper || 1) - (s.lower || 0);
                    const vals = win.map((o: { parameters: Record<string, number> }) => ((o.parameters[s.name] || 0) - (s.lower || 0)) / (range || 1));
                    const mean = vals.reduce((a: number, b: number) => a + b, 0) / vals.length;
                    totalVar += vals.reduce((a: number, v: number) => a + (v - mean) ** 2, 0) / vals.length;
                  });
                  return Math.sqrt(totalVar / sfSpecs.length);
                });
                // trend: is spread decreasing (focusing) or increasing (wandering)?
                const sfThird = Math.max(1, Math.floor(sfSpreads.length / 3));
                const sfEarlySpread = sfSpreads.slice(0, sfThird).reduce((s, v) => s + v, 0) / sfThird;
                const sfLateSpread = sfSpreads.slice(-sfThird).reduce((s, v) => s + v, 0) / sfThird;
                const sfSpreadRatio = sfEarlySpread > 0 ? sfLateSpread / sfEarlySpread : 1;
                const sfBadge = sfSpreadRatio < 0.7 ? "Focusing" : sfSpreadRatio < 1.3 ? "Stable" : "Wandering";
                const sfBadgeColor = sfBadge === "Focusing" ? "var(--color-green, #22c55e)" : sfBadge === "Stable" ? "var(--color-blue, #3b82f6)" : "var(--color-yellow, #eab308)";
                // chart: dual-axis — drift line + spread area
                const sfW = 260, sfH = 75;
                const sfPad = { l: 5, r: 5, t: 6, b: 14 };
                const sfPlotW = sfW - sfPad.l - sfPad.r;
                const sfPlotH = sfH - sfPad.t - sfPad.b;
                const sfMaxDist = Math.max(...sfDists, 0.01);
                const sfMaxSpread = Math.max(...sfSpreads, 0.01);
                // spread area
                const sfSpreadPts = sfSpreads.map((v, i) => ({
                  x: sfPad.l + (i / (sfSpreads.length - 1)) * sfPlotW,
                  y: sfPad.t + (1 - v / sfMaxSpread) * sfPlotH,
                }));
                const sfSpreadArea = sfSpreadPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ")
                  + ` L${sfSpreadPts[sfSpreadPts.length - 1].x.toFixed(1)},${sfPad.t + sfPlotH} L${sfSpreadPts[0].x.toFixed(1)},${sfPad.t + sfPlotH} Z`;
                // drift line
                const sfDriftPts = sfDists.map((v, i) => ({
                  x: sfPad.l + (i / (sfDists.length - 1)) * sfPlotW,
                  y: sfPad.t + (1 - v / sfMaxDist) * sfPlotH,
                }));
                const sfDriftLine = sfDriftPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ");
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Compass size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Search Focus Drift</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: sfBadgeColor, color: "#fff" }}>{sfBadge}</span>
                    </div>
                    <svg width={sfW} height={sfH} viewBox={`0 0 ${sfW} ${sfH}`} style={{ display: "block", width: "100%" }}>
                      {/* spread area */}
                      <path d={sfSpreadArea} fill="var(--color-yellow, #eab308)" opacity="0.12" />
                      <path d={sfSpreadPts.map((p, i) => `${i === 0 ? "M" : "L"}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(" ")} fill="none" stroke="var(--color-yellow, #eab308)" strokeWidth="1" opacity="0.5" />
                      {/* drift line */}
                      <path d={sfDriftLine} fill="none" stroke="var(--color-primary, #6366f1)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                      {/* legend */}
                      <line x1={sfW - 100} y1={sfPad.t + 2} x2={sfW - 88} y2={sfPad.t + 2} stroke="var(--color-primary, #6366f1)" strokeWidth="1.5" />
                      <text x={sfW - 85} y={sfPad.t + 5} fontSize="8" fill="var(--color-text-muted, #64748b)">drift</text>
                      <rect x={sfW - 55} y={sfPad.t - 2} width="10" height="8" fill="var(--color-yellow, #eab308)" opacity="0.3" />
                      <text x={sfW - 42} y={sfPad.t + 5} fontSize="8" fill="var(--color-text-muted, #64748b)">spread</text>
                      {/* axis labels */}
                      <text x={sfPad.l} y={sfH - 1} fontSize="8" fill="var(--color-text-muted, #64748b)">early</text>
                      <text x={sfW - sfPad.r} y={sfH - 1} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">recent</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {sfBadge === "Focusing" ? "Search is narrowing — optimizer is converging on a region." : sfBadge === "Stable" ? "Search region is consistent — steady exploration and exploitation." : "Search region is expanding — optimizer may be stuck or exploring new areas."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Prediction Surprise (Batch 29) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const psSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (psSpecs.length === 0) return null;
                const kpiKey = Object.keys(campaign.observations[0].kpi_values || {})[0];
                if (!kpiKey) return null;
                const psObs = campaign.observations.filter((o: { kpi_values: Record<string, number> }) => o.kpi_values[kpiKey] != null);
                if (psObs.length < 10) return null;
                // for each observation, compute k-NN prediction (k=3) using all OTHER observations, then residual
                const psK = 3;
                const psResiduals: number[] = [];
                for (let i = 0; i < psObs.length; i++) {
                  const dists: { d: number; kpi: number }[] = [];
                  for (let j = 0; j < psObs.length; j++) {
                    if (j === i) continue;
                    let sum = 0;
                    psSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                      const range = (s.upper || 1) - (s.lower || 0);
                      sum += ((psObs[i].parameters[s.name] - psObs[j].parameters[s.name]) / (range || 1)) ** 2;
                    });
                    dists.push({ d: Math.sqrt(sum), kpi: psObs[j].kpi_values[kpiKey] });
                  }
                  dists.sort((a, b) => a.d - b.d);
                  const neighbors = dists.slice(0, psK);
                  const predicted = neighbors.reduce((s, n) => s + n.kpi, 0) / neighbors.length;
                  psResiduals.push(psObs[i].kpi_values[kpiKey] - predicted);
                }
                // normalize residuals by std
                const psMean = psResiduals.reduce((s, v) => s + v, 0) / psResiduals.length;
                const psStd = Math.sqrt(psResiduals.reduce((s, v) => s + (v - psMean) ** 2, 0) / psResiduals.length) || 1;
                const psNormalized = psResiduals.map(r => (r - psMean) / psStd);
                const psSurpriseCount = psNormalized.filter(z => Math.abs(z) > 2).length;
                const psSurpriseRate = psSurpriseCount / psNormalized.length;
                const psBadge = psSurpriseRate < 0.1 ? "Predictable" : psSurpriseRate < 0.25 ? "Some Surprises" : "Unpredictable";
                const psBadgeColor = psBadge === "Predictable" ? "var(--color-green, #22c55e)" : psBadge === "Some Surprises" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // dot timeline
                const psW = 260, psH = 55;
                const psPad = { l: 5, r: 5, t: 8, b: 14 };
                const psPlotW = psW - psPad.l - psPad.r;
                const psPlotH = psH - psPad.t - psPad.b;
                const psMaxZ = Math.max(...psNormalized.map(Math.abs), 2);
                const psZeroY = psPad.t + psPlotH / 2;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <AlertOctagon size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Prediction Surprise</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: psBadgeColor, color: "#fff" }}>{psBadge}</span>
                    </div>
                    <svg width={psW} height={psH} viewBox={`0 0 ${psW} ${psH}`} style={{ display: "block", width: "100%" }}>
                      {/* zero line */}
                      <line x1={psPad.l} y1={psZeroY} x2={psW - psPad.r} y2={psZeroY} stroke="var(--color-border, #e2e8f0)" strokeWidth="0.5" />
                      {/* ±2σ bands */}
                      <rect x={psPad.l} y={psZeroY - (2 / psMaxZ) * (psPlotH / 2)} width={psPlotW} height={(4 / psMaxZ) * (psPlotH / 2)} fill="var(--color-green, #22c55e)" opacity="0.06" rx="2" />
                      {/* dots */}
                      {psNormalized.map((z, i) => {
                        const x = psPad.l + (i / (psNormalized.length - 1)) * psPlotW;
                        const y = psZeroY - (z / psMaxZ) * (psPlotH / 2);
                        const absZ = Math.abs(z);
                        const color = absZ > 2 ? "var(--color-red, #ef4444)" : absZ > 1.5 ? "var(--color-yellow, #eab308)" : "var(--color-green, #22c55e)";
                        const r = absZ > 2 ? 3.5 : 2.5;
                        return <circle key={i} cx={x} cy={y} r={r} fill={color} opacity={absZ > 2 ? 0.9 : 0.6} />;
                      })}
                      {/* labels */}
                      <text x={psPad.l} y={psH - 1} fontSize="8" fill="var(--color-text-muted, #64748b)">1</text>
                      <text x={psW - psPad.r} y={psH - 1} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">{psObs.length}</text>
                      <text x={psW - psPad.r + 1} y={psZeroY + 3} fontSize="7" fill="var(--color-text-muted, #64748b)">0σ</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {psSurpriseCount} of {psObs.length} trials exceeded 2σ surprise — {psBadge === "Predictable" ? "model fits the data well." : psBadge === "Some Surprises" ? "a few unexpected results worth investigating." : "many observations defy local predictions."}
                    </div>
                  </div>
                );
              })()}

              {/* ── Effective Sample Size (Batch 30) ── */}
              {(() => {
                if (!campaign?.observations?.length || campaign.observations.length < 10) return null;
                const esSpecs = (campaign.spec?.parameters || []).filter(
                  (s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null
                );
                if (esSpecs.length === 0) return null;
                const esObs = campaign.observations;
                // compute effective N over windows: for each window, count "non-redundant" observations
                // two observations are redundant if their normalized distance < threshold
                const esThreshold = 0.1; // 10% of range = too close
                const esWinSize = Math.max(5, Math.floor(esObs.length / 8));
                const esRatios: { n: number; effective: number; ratio: number }[] = [];
                for (let start = 0; start + esWinSize <= esObs.length; start += Math.max(1, Math.floor(esWinSize / 2))) {
                  const win = esObs.slice(start, start + esWinSize);
                  // count effective: for each obs, check if it's too close to any earlier obs in window
                  let esEffective = 0;
                  for (let i = 0; i < win.length; i++) {
                    let isRedundant = false;
                    for (let j = 0; j < i; j++) {
                      let dist = 0;
                      esSpecs.forEach((s: { name: string; lower?: number; upper?: number }) => {
                        const range = (s.upper || 1) - (s.lower || 0);
                        dist += ((win[i].parameters[s.name] - win[j].parameters[s.name]) / (range || 1)) ** 2;
                      });
                      if (Math.sqrt(dist / esSpecs.length) < esThreshold) { isRedundant = true; break; }
                    }
                    if (!isRedundant) esEffective++;
                  }
                  esRatios.push({ n: win.length, effective: esEffective, ratio: esEffective / win.length });
                }
                if (esRatios.length < 3) return null;
                const esAvgRatio = esRatios.reduce((s, r) => s + r.ratio, 0) / esRatios.length;
                const esBadge = esAvgRatio > 0.8 ? "High Efficiency" : esAvgRatio > 0.55 ? "Moderate" : "Redundant";
                const esBadgeColor = esBadge === "High Efficiency" ? "var(--color-green, #22c55e)" : esBadge === "Moderate" ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                // bar chart
                const esW = 260, esBarW = Math.floor(esW / esRatios.length) - 2;
                const esH = 65;
                const esPad = { l: 5, r: 5, t: 6, b: 14 };
                const esPlotH = esH - esPad.t - esPad.b;
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "10px" }}>
                      <Users size={16} style={{ color: "var(--color-primary)" }} />
                      <span style={{ fontWeight: 600, fontSize: "0.92rem" }}>Effective Sample Size</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "9999px", background: esBadgeColor, color: "#fff" }}>{esBadge}</span>
                    </div>
                    <svg width={esW} height={esH} viewBox={`0 0 ${esW} ${esH}`} style={{ display: "block", width: "100%" }}>
                      {esRatios.map((r, i) => {
                        const x = esPad.l + i * (esBarW + 2);
                        const barH = r.ratio * esPlotH;
                        const color = r.ratio > 0.8 ? "var(--color-green, #22c55e)" : r.ratio > 0.55 ? "var(--color-yellow, #eab308)" : "var(--color-red, #ef4444)";
                        return (
                          <g key={i}>
                            <rect x={x} y={esPad.t + esPlotH - barH} width={Math.max(esBarW, 2)} height={barH} rx="2" fill={color} opacity="0.7" />
                          </g>
                        );
                      })}
                      {/* avg line */}
                      <line x1={esPad.l} y1={esPad.t + esPlotH * (1 - esAvgRatio)} x2={esW - esPad.r} y2={esPad.t + esPlotH * (1 - esAvgRatio)} stroke="var(--color-text, #1e293b)" strokeWidth="0.8" strokeDasharray="4,3" />
                      <text x={esW - esPad.r} y={esPad.t + esPlotH * (1 - esAvgRatio) - 2} textAnchor="end" fontSize="8" fontFamily="var(--font-mono)" fill="var(--color-text-muted, #64748b)">avg {(esAvgRatio * 100).toFixed(0)}%</text>
                      <text x={esPad.l} y={esH - 1} fontSize="8" fill="var(--color-text-muted, #64748b)">early</text>
                      <text x={esW - esPad.r} y={esH - 1} textAnchor="end" fontSize="8" fill="var(--color-text-muted, #64748b)">recent</text>
                    </svg>
                    <div style={{ fontSize: "0.78rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {esBadge === "High Efficiency" ? "Most trials explore unique regions — efficient sampling." : esBadge === "Moderate" ? "Some redundancy — consider increasing exploration." : "Many trials overlap — optimizer may be over-exploiting."}
                    </div>
                  </div>
                );
              })()}

              {/* Learning Curve Projection */}
              {trials.length >= 10 && (() => {
                const lpKey = Object.keys(trials[0]?.kpis ?? {})[0];
                if (!lpKey) return null;
                const lpSorted = [...trials].sort((a: { iteration: number }, b: { iteration: number }) => a.iteration - b.iteration);
                // Compute best-so-far curve
                let lpBest = -Infinity;
                const lpCurve: { iter: number; best: number }[] = [];
                for (const t of lpSorted) {
                  const v = t.kpis[lpKey];
                  if (v != null && v > lpBest) lpBest = v;
                  if (v != null) lpCurve.push({ iter: t.iteration, best: lpBest });
                }
                if (lpCurve.length < 10) return null;
                // Fit log-linear model: best = a * ln(iter) + b using least squares
                const lpN = lpCurve.length;
                let lpSumX = 0, lpSumY = 0, lpSumXX = 0, lpSumXY = 0;
                for (const pt of lpCurve) {
                  const x = Math.log(Math.max(1, pt.iter));
                  lpSumX += x;
                  lpSumY += pt.best;
                  lpSumXX += x * x;
                  lpSumXY += x * pt.best;
                }
                const lpDenom = lpN * lpSumXX - lpSumX * lpSumX;
                const lpA = lpDenom !== 0 ? (lpN * lpSumXY - lpSumX * lpSumY) / lpDenom : 0;
                const lpB = (lpSumY - lpA * lpSumX) / lpN;
                // Project forward 50% more iterations
                const lpMaxIter = lpCurve[lpCurve.length - 1].iter;
                const lpProjectN = 5;
                const lpProjected: { iter: number; best: number }[] = [];
                for (let i = 1; i <= lpProjectN; i++) {
                  const futIter = lpMaxIter + i * Math.ceil(lpMaxIter * 0.1);
                  const pred = lpA * Math.log(Math.max(1, futIter)) + lpB;
                  lpProjected.push({ iter: futIter, best: pred });
                }
                // Rate of improvement: compare recent slope to early slope
                const lpHalf = Math.floor(lpCurve.length / 2);
                const lpEarlyRate = lpHalf > 0 ? (lpCurve[lpHalf].best - lpCurve[0].best) / lpHalf : 0;
                const lpLateRate = lpHalf > 0 ? (lpCurve[lpCurve.length - 1].best - lpCurve[lpHalf].best) / (lpCurve.length - lpHalf) : 0;
                const lpRatio = lpEarlyRate !== 0 ? lpLateRate / lpEarlyRate : 0;
                const lpBadge = lpRatio > 0.5 ? "Fast Learning" : lpRatio > 0.1 ? "Steady" : "Plateaued";
                const lpColor = lpBadge === "Fast Learning" ? "var(--color-primary)" : lpBadge === "Steady" ? "#eab308" : "#ef4444";
                // Draw
                const lpW = 260, lpH = 80, lpPad = 4;
                const allPts = [...lpCurve, ...lpProjected];
                const lpMinIter = lpCurve[0].iter;
                const lpMaxI = lpProjected.length > 0 ? lpProjected[lpProjected.length - 1].iter : lpMaxIter;
                const lpMinV = Math.min(...allPts.map(p => p.best));
                const lpMaxV = Math.max(...allPts.map(p => p.best));
                const lpRangeI = lpMaxI - lpMinIter || 1;
                const lpRangeV = lpMaxV - lpMinV || 1;
                const lpToX = (iter: number) => lpPad + ((iter - lpMinIter) / lpRangeI) * (lpW - 2 * lpPad);
                const lpToY = (v: number) => lpPad + (1 - (v - lpMinV) / lpRangeV) * (lpH - 2 * lpPad);
                const lpActualLine = lpCurve.map((p, i) => `${i === 0 ? "M" : "L"}${lpToX(p.iter).toFixed(1)},${lpToY(p.best).toFixed(1)}`).join(" ");
                const lpProjLine = [lpCurve[lpCurve.length - 1], ...lpProjected].map((p, i) => `${i === 0 ? "M" : "L"}${lpToX(p.iter).toFixed(1)},${lpToY(p.best).toFixed(1)}`).join(" ");
                // Projection zone fill
                const lpFillPts = [lpCurve[lpCurve.length - 1], ...lpProjected];
                const lpFill = lpFillPts.map((p, i) => `${i === 0 ? "M" : "L"}${lpToX(p.iter).toFixed(1)},${lpToY(p.best).toFixed(1)}`).join(" ") + ` L${lpToX(lpProjected[lpProjected.length - 1].iter).toFixed(1)},${lpH - lpPad} L${lpToX(lpCurve[lpCurve.length - 1].iter).toFixed(1)},${lpH - lpPad} Z`;
                const lpBoundaryX = lpToX(lpMaxIter);
                return (
                  <div className="card" style={{ padding: "14px 18px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                      <Timer size={16} style={{ color: "var(--color-primary)" }} />
                      <strong style={{ fontSize: "0.88rem" }}>Learning Curve Projection</strong>
                      <span style={{ marginLeft: "auto", fontSize: "0.75rem", fontWeight: 600, padding: "2px 8px", borderRadius: "6px", background: lpBadge === "Fast Learning" ? "var(--color-success-bg)" : lpBadge === "Steady" ? "rgba(234,179,8,0.12)" : "rgba(239,68,68,0.1)", color: lpColor }}>{lpBadge}</span>
                    </div>
                    <svg width="100%" height={lpH} viewBox={`0 0 ${lpW} ${lpH}`} style={{ display: "block" }}>
                      {/* Projection zone */}
                      <path d={lpFill} fill={lpColor} opacity="0.08" />
                      {/* Boundary line */}
                      <line x1={lpBoundaryX} y1={lpPad} x2={lpBoundaryX} y2={lpH - lpPad} stroke="var(--color-text-muted)" strokeWidth="0.8" strokeDasharray="3,3" />
                      {/* Actual curve */}
                      <path d={lpActualLine} fill="none" stroke="var(--color-primary)" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                      {/* Projected curve */}
                      <path d={lpProjLine} fill="none" stroke={lpColor} strokeWidth="1.5" strokeDasharray="4,3" strokeLinecap="round" />
                      {/* Current point */}
                      <circle cx={lpToX(lpMaxIter)} cy={lpToY(lpCurve[lpCurve.length - 1].best)} r="3" fill="var(--color-primary)" />
                      {/* Labels */}
                      <text x={lpBoundaryX - 3} y={12} textAnchor="end" fontSize="8" fill="var(--color-text-muted)">observed</text>
                      <text x={lpBoundaryX + 3} y={12} textAnchor="start" fontSize="8" fill={lpColor}>projected</text>
                    </svg>
                    <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.72rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      <span>iter {lpMinIter}</span>
                      <span style={{ fontFamily: "var(--font-mono)", fontWeight: 600, color: lpColor }}>slope ratio: {lpRatio.toFixed(2)}</span>
                      <span>→ iter {lpMaxI}</span>
                    </div>
                    <div style={{ fontSize: "0.75rem", color: "var(--color-text-muted)", marginTop: "4px" }}>
                      {lpBadge === "Fast Learning" ? "Still improving quickly — continue running experiments." : lpBadge === "Steady" ? "Learning is slowing — consider strategy adjustments." : "Improvement has plateaued — diminishing returns on additional trials."}
                    </div>
                  </div>
                );
              })()}

              {/* Hypothesis Rejection Timeline */}
              {trials.length >= 10 && (() => {
                const hrSpecs = campaign.spec?.parameters?.filter((s: { name: string; type: string; lower?: number; upper?: number }) => s.type === "continuous" && s.lower != null && s.upper != null) || [];
                if (hrSpecs.length === 0) return null;
                const hrSorted = [...trials].sort((a, b) => a.iteration - b.iteration);
                const hrN = hrSorted.length;

                // --- Hypothesis 1: Monotonicity per parameter (running Spearman rank correlation) ---
                const hrMonoHyps = hrSpecs.slice(0, 4).map((s: { name: string; type: string; lower?: number; upper?: number }) => {
                  const kpiKey = Object.keys(hrSorted[0]?.kpis || {})[0];
                  if (!kpiKey) return null;
                  // Compute Spearman correlation in expanding windows
                  const hrSnapshots: { iter: number; rho: number; pReject: boolean }[] = [];
                  const step = Math.max(1, Math.floor(hrN / 16));
                  for (let w = 8; w <= hrN; w += step) {
                    const slice = hrSorted.slice(0, w);
                    const xs = slice.map(t => Number(t.parameters[s.name]) || 0);
                    const ys = slice.map(t => Number(t.kpis[kpiKey]) || 0);
                    // Rank arrays
                    const rank = (arr: number[]) => {
                      const sorted = [...arr].map((v, i) => ({ v, i })).sort((a, b) => a.v - b.v);
                      const ranks = new Array(arr.length);
                      sorted.forEach((el, r) => { ranks[el.i] = r + 1; });
                      return ranks;
                    };
                    const rx = rank(xs);
                    const ry = rank(ys);
                    const n = rx.length;
                    const d2 = rx.reduce((sum, rxi, i) => sum + (rxi - ry[i]) ** 2, 0);
                    const rho = 1 - (6 * d2) / (n * (n * n - 1));
                    // |rho| < 0.3 with enough data => reject monotonicity
                    const pReject = n >= 10 && Math.abs(rho) < 0.3;
                    hrSnapshots.push({ iter: slice[slice.length - 1].iteration, rho, pReject });
                  }
                  return {
                    label: `Mono(${s.name.length > 6 ? s.name.slice(0, 5) + "…" : s.name})`,
                    snapshots: hrSnapshots,
                    type: "monotonicity" as const,
                  };
                }).filter(Boolean) as Array<{ label: string; snapshots: Array<{ iter: number; rho: number; pReject: boolean }>; type: string }>;

                // --- Hypothesis 2: Optimum in center vs edge ---
                const hrOptHyp = (() => {
                  const kpiKey = Object.keys(hrSorted[0]?.kpis || {})[0];
                  if (!kpiKey || hrSpecs.length < 1) return null;
                  const hrSnapCenter: { iter: number; rho: number; pReject: boolean }[] = [];
                  const step = Math.max(1, Math.floor(hrN / 16));
                  for (let w = 8; w <= hrN; w += step) {
                    const slice = hrSorted.slice(0, w);
                    // Check if best trials are in center 40% of parameter space
                    const kpiVals = slice.map(t => Number(t.kpis[kpiKey]) || 0);
                    const kpiMin = Math.min(...kpiVals);
                    const kpiMax = Math.max(...kpiVals);
                    const kpiThresh = kpiMin + (kpiMax - kpiMin) * 0.7;
                    const topTrials = slice.filter(t => (Number(t.kpis[kpiKey]) || 0) >= kpiThresh);
                    const centerCount = topTrials.filter(t => {
                      return hrSpecs.every((sp: { name: string; lower?: number; upper?: number }) => {
                        const lo = sp.lower ?? 0, hi = sp.upper ?? 1;
                        const norm = hi > lo ? (Number(t.parameters[sp.name]) - lo) / (hi - lo) : 0.5;
                        return norm >= 0.3 && norm <= 0.7;
                      });
                    }).length;
                    const centerFrac = topTrials.length > 0 ? centerCount / topTrials.length : 0.5;
                    // If most top trials are NOT centered => reject center hypothesis
                    const pReject = topTrials.length >= 3 && centerFrac < 0.3;
                    hrSnapCenter.push({ iter: slice[slice.length - 1].iteration, rho: centerFrac, pReject });
                  }
                  return {
                    label: "Opt@Center",
                    snapshots: hrSnapCenter,
                    type: "center" as const,
                  };
                })();

                // --- Hypothesis 3: No interaction effects (independence test) ---
                const hrInterHyp = (() => {
                  const kpiKey = Object.keys(hrSorted[0]?.kpis || {})[0];
                  if (!kpiKey || hrSpecs.length < 2) return null;
                  const s0 = hrSpecs[0] as { name: string; lower?: number; upper?: number };
                  const s1 = hrSpecs[1] as { name: string; lower?: number; upper?: number };
                  const hrSnapInter: { iter: number; rho: number; pReject: boolean }[] = [];
                  const step = Math.max(1, Math.floor(hrN / 16));
                  for (let w = 10; w <= hrN; w += step) {
                    const slice = hrSorted.slice(0, w);
                    // Compute residual-product correlation as interaction proxy
                    const xs = slice.map(t => Number(t.parameters[s0.name]) || 0);
                    const ys = slice.map(t => Number(t.parameters[s1.name]) || 0);
                    const zs = slice.map(t => Number(t.kpis[kpiKey]) || 0);
                    const mean = (a: number[]) => a.reduce((s, v) => s + v, 0) / a.length;
                    const mx = mean(xs), my = mean(ys), mz = mean(zs);
                    // Product term correlation with kpi
                    const prods = xs.map((x, i) => (x - mx) * (ys[i] - my));
                    const mp = mean(prods);
                    const covPZ = prods.reduce((s, p, i) => s + (p - mp) * (zs[i] - mz), 0) / slice.length;
                    const stdP = Math.sqrt(prods.reduce((s, p) => s + (p - mp) ** 2, 0) / slice.length) || 1;
                    const stdZ = Math.sqrt(zs.reduce((s, z) => s + (z - mz) ** 2, 0) / slice.length) || 1;
                    const interCorr = covPZ / (stdP * stdZ);
                    // Reject independence (meaning interaction detected) if |corr| > 0.4
                    const pReject = slice.length >= 10 && Math.abs(interCorr) > 0.4;
                    hrSnapInter.push({ iter: slice[slice.length - 1].iteration, rho: interCorr, pReject });
                  }
                  return {
                    label: `Indep(${s0.name.slice(0, 3)}×${s1.name.slice(0, 3)})`,
                    snapshots: hrSnapInter,
                    type: "interaction" as const,
                  };
                })();

                const hrAllHyps = [...hrMonoHyps, ...(hrOptHyp ? [hrOptHyp] : []), ...(hrInterHyp ? [hrInterHyp] : [])];
                if (hrAllHyps.length === 0) return null;

                const hrRejected = hrAllHyps.filter(h => h.snapshots.length > 0 && h.snapshots[h.snapshots.length - 1].pReject).length;
                const hrW = 440, hrH = 24 * hrAllHyps.length + 32, hrPadL = 100, hrPadR = 16, hrPadT = 6, hrPadB = 22;
                const hrPlotW = hrW - hrPadL - hrPadR;
                const hrRowH = (hrH - hrPadT - hrPadB) / hrAllHyps.length;

                // Find global iteration range across all hypotheses
                const hrAllIters = hrAllHyps.flatMap(h => h.snapshots.map(s => s.iter));
                const hrMinIter = Math.min(...hrAllIters);
                const hrMaxIter = Math.max(...hrAllIters);
                const hrIterRange = hrMaxIter - hrMinIter || 1;

                return (
                  <div className="card" style={{ marginBottom: 18 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                      <FlaskRound size={18} style={{ color: "var(--color-text-muted)" }} />
                      <div>
                        <h2 style={{ margin: 0 }}>Hypothesis Rejection Timeline</h2>
                        <p className="stat-label" style={{ margin: 0, textTransform: "none" }}>
                          Structural hypotheses tested via rolling statistics. Red = rejected.
                        </p>
                      </div>
                      <span className="findings-badge" style={{ marginLeft: "auto", color: hrRejected > 0 ? "rgba(239,68,68,0.8)" : "#22c55e", borderColor: hrRejected > 0 ? "rgba(239,68,68,0.3)" : "rgba(34,197,94,0.3)" }}>
                        {hrRejected} rejected / {hrAllHyps.length} tested
                      </span>
                    </div>
                    <div style={{ overflowX: "auto" }}>
                      <svg width={hrW} height={hrH} viewBox={`0 0 ${hrW} ${hrH}`} style={{ display: "block", margin: "0 auto" }}>
                        {/* Swim lane backgrounds */}
                        {hrAllHyps.map((h, hi) => (
                          <g key={hi}>
                            {hi % 2 === 0 && (
                              <rect x={hrPadL} y={hrPadT + hi * hrRowH} width={hrPlotW} height={hrRowH} fill="var(--color-border)" opacity={0.15} />
                            )}
                            {/* Label */}
                            <text x={hrPadL - 6} y={hrPadT + hi * hrRowH + hrRowH / 2 + 3} textAnchor="end" fontSize="8" fontFamily="var(--font-mono)" fontWeight={500} fill={h.snapshots.length > 0 && h.snapshots[h.snapshots.length - 1].pReject ? "rgba(239,68,68,0.8)" : "var(--color-text-secondary)"}>
                              {h.label}
                            </text>
                            {/* Status segments: green=active, red=rejected */}
                            {h.snapshots.map((snap, si) => {
                              const x1 = hrPadL + ((snap.iter - hrMinIter) / hrIterRange) * hrPlotW;
                              const nextIter = si < h.snapshots.length - 1 ? h.snapshots[si + 1].iter : hrMaxIter;
                              const x2 = hrPadL + ((nextIter - hrMinIter) / hrIterRange) * hrPlotW;
                              const y = hrPadT + hi * hrRowH + hrRowH * 0.3;
                              const barH = hrRowH * 0.4;
                              return (
                                <rect key={si} x={x1} y={y} width={Math.max(2, x2 - x1)} height={barH} rx={2} fill={snap.pReject ? "rgba(239,68,68,0.45)" : "rgba(34,197,94,0.35)"} />
                              );
                            })}
                            {/* Rejection marker */}
                            {h.snapshots.map((snap, si) => {
                              if (!snap.pReject) return null;
                              // Show rejection marker at first rejection point
                              const prevNotRejected = si === 0 || !h.snapshots[si - 1].pReject;
                              if (!prevNotRejected) return null;
                              const x = hrPadL + ((snap.iter - hrMinIter) / hrIterRange) * hrPlotW;
                              const y = hrPadT + hi * hrRowH + hrRowH / 2;
                              return (
                                <g key={`rej${si}`}>
                                  <line x1={x} y1={y - hrRowH * 0.3} x2={x} y2={y + hrRowH * 0.3} stroke="rgba(239,68,68,0.7)" strokeWidth="1.5" />
                                  <text x={x} y={y - hrRowH * 0.35} textAnchor="middle" fontSize="7" fill="rgba(239,68,68,0.8)" fontWeight="600">✗</text>
                                </g>
                              );
                            })}
                          </g>
                        ))}
                        {/* X axis */}
                        <line x1={hrPadL} y1={hrH - hrPadB} x2={hrPadL + hrPlotW} y2={hrH - hrPadB} stroke="var(--color-border)" strokeWidth="0.5" />
                        <text x={hrPadL} y={hrH - 4} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)">iter {hrMinIter}</text>
                        <text x={hrPadL + hrPlotW} y={hrH - 4} fontSize="7" fill="var(--color-text-muted)" fontFamily="var(--font-mono)" textAnchor="end">iter {hrMaxIter}</text>
                        <text x={hrPadL + hrPlotW / 2} y={hrH - 4} fontSize="7" fill="var(--color-text-muted)" textAnchor="middle">Iteration →</text>
                      </svg>
                    </div>
                    <div style={{ display: "flex", gap: "16px", marginTop: "4px", flexWrap: "wrap", alignItems: "center" }}>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "rgba(34,197,94,0.35)", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Active</span>
                      <span className="efficiency-legend-item"><span style={{ display: "inline-block", width: 14, height: 8, background: "rgba(239,68,68,0.45)", marginRight: 4, verticalAlign: "middle", borderRadius: 2 }} />Rejected</span>
                      <span className="efficiency-legend-item"><span style={{ fontWeight: 600, color: "rgba(239,68,68,0.8)", marginRight: 4 }}>✗</span>Rejection point</span>
                      <span style={{ marginLeft: "auto", fontSize: "0.72rem", color: "var(--color-text-muted)" }}>
                        Spearman ρ, center fraction, product correlation
                      </span>
                    </div>
                  </div>
                );
              })()}

              <div className="card">
                <div className="history-header">
                  <h2>Trial History ({trials.length} experiments)</h2>
                  <div className="history-toolbar">
                    <div className="history-search">
                      <Filter size={14} />
                      <input
                        type="text"
                        className="history-search-input"
                        placeholder="Filter trials..."
                        value={historyFilter}
                        onChange={(e) => { setHistoryFilter(e.target.value); setHistoryPage(0); }}
                      />
                      {historyFilter && (
                        <button className="history-search-clear" onClick={() => setHistoryFilter("")}>&times;</button>
                      )}
                    </div>
                    {bestResult && (
                      <button
                        className="btn btn-sm btn-accent"
                        onClick={() => {
                          // Find best trial's position in sorted list
                          const filterLower2 = historyFilter.toLowerCase();
                          let filtered2 = trials;
                          if (filterLower2) {
                            filtered2 = trials.filter((t) => {
                              const iterStr = String(t.iteration);
                              const paramStr = Object.entries(t.parameters).map(([k, v]) => `${k}=${typeof v === "number" ? v.toFixed(4) : v}`).join(" ");
                              const kpiStr = Object.entries(t.kpis).map(([k, v]) => `${k}=${typeof v === "number" ? v.toFixed(4) : v}`).join(" ");
                              return `${iterStr} ${paramStr} ${kpiStr}`.toLowerCase().includes(filterLower2);
                            });
                          }
                          let sorted2 = [...filtered2];
                          if (historySortCol) {
                            sorted2.sort((a, b) => {
                              let va: number, vb: number;
                              if (historySortCol === "__iter__") { va = a.iteration; vb = b.iteration; }
                              else if (historySortCol.startsWith("p:")) { const key = historySortCol.slice(2); va = Number(a.parameters[key]) || 0; vb = Number(b.parameters[key]) || 0; }
                              else { const key = historySortCol.slice(2); va = Number(a.kpis[key]) || 0; vb = Number(b.kpis[key]) || 0; }
                              return historySortDir === "asc" ? va - vb : vb - va;
                            });
                          } else {
                            sorted2.reverse();
                          }
                          const bestIdx = sorted2.findIndex((t) => t.iteration === bestResult.iteration);
                          if (bestIdx >= 0) {
                            const targetPage = Math.floor(bestIdx / HISTORY_PAGE_SIZE);
                            setHistoryPage(targetPage);
                            // Expand the best trial and scroll to it
                            setExpandedTrialId(bestResult.id);
                            setTimeout(() => {
                              document.querySelector(".history-row-best")?.scrollIntoView({ behavior: "smooth", block: "center" });
                            }, 100);
                          }
                        }}
                        title="Jump to best trial"
                      >
                        <Trophy size={13} /> Jump to Best
                      </button>
                    )}
                    {bookmarks.size > 0 && (
                      <button
                        className={`btn btn-sm ${showBookmarkedOnly ? "btn-bookmark-active" : "btn-secondary"}`}
                        onClick={() => { setShowBookmarkedOnly(p => !p); setHistoryPage(0); }}
                        title={showBookmarkedOnly ? "Show all trials" : "Show bookmarked only"}
                      >
                        <Star size={13} fill={showBookmarkedOnly ? "currentColor" : "none"} /> {bookmarks.size}
                      </button>
                    )}
                    <button
                      className="btn btn-sm btn-secondary"
                      onClick={handleExportHistoryCSV}
                      title="Download all trials as CSV"
                    >
                      <Download size={13} /> CSV
                    </button>
                    <button
                      className="btn btn-sm btn-secondary"
                      onClick={handleExportHistoryJSON}
                      title="Download all trials as JSON"
                    >
                      <FileJson size={13} /> JSON
                    </button>
                    {compareSet.size >= 2 && (
                      <button
                        className="btn btn-sm btn-primary"
                        onClick={() => setShowCompareModal(true)}
                        title="Compare selected trials"
                      >
                        <GitCompare size={13} /> Compare ({compareSet.size})
                      </button>
                    )}
                    <span className="history-sort-hint">Click headers to sort</span>
                  </div>
                </div>
                {trials.length > 0 ? (() => {
                  // Apply filter
                  const filterLower = historyFilter.toLowerCase();
                  let filtered = trials;
                  if (showBookmarkedOnly) {
                    filtered = filtered.filter((t) => bookmarks.has(t.id));
                  }
                  if (filterLower) {
                    filtered = filtered.filter((t) => {
                      const iterStr = String(t.iteration);
                      const paramStr = Object.entries(t.parameters).map(([k, v]) => `${k}=${typeof v === "number" ? v.toFixed(4) : v}`).join(" ");
                      const kpiStr = Object.entries(t.kpis).map(([k, v]) => `${k}=${typeof v === "number" ? v.toFixed(4) : v}`).join(" ");
                      return `${iterStr} ${paramStr} ${kpiStr}`.toLowerCase().includes(filterLower);
                    });
                  }
                  // Sort
                  let sorted = [...filtered];
                  if (historySortCol) {
                    sorted.sort((a, b) => {
                      let va: number, vb: number;
                      if (historySortCol === "__iter__") {
                        va = a.iteration; vb = b.iteration;
                      } else if (historySortCol.startsWith("p:")) {
                        const key = historySortCol.slice(2);
                        va = Number(a.parameters[key]) || 0;
                        vb = Number(b.parameters[key]) || 0;
                      } else {
                        const key = historySortCol.slice(2);
                        va = Number(a.kpis[key]) || 0;
                        vb = Number(b.kpis[key]) || 0;
                      }
                      return historySortDir === "asc" ? va - vb : vb - va;
                    });
                  } else {
                    sorted.reverse();
                  }
                  // Paginate
                  const totalPages = Math.ceil(sorted.length / HISTORY_PAGE_SIZE);
                  const pageTrials = sorted.slice(historyPage * HISTORY_PAGE_SIZE, (historyPage + 1) * HISTORY_PAGE_SIZE);
                  const paramKeys = Object.keys(trials[0].parameters);
                  const kpiKeys = Object.keys(trials[0].kpis);

                  // Build parameter spec lookup for range bars
                  const specMap: Record<string, { lower: number; upper: number }> = {};
                  if (campaign.spec?.parameters) {
                    for (const s of campaign.spec.parameters) {
                      if (s.lower != null && s.upper != null) specMap[s.name] = { lower: s.lower, upper: s.upper };
                    }
                  }

                  // Build chronological KPI arrays for sparklines
                  const chronoTrials = [...trials].sort((a, b) => a.iteration - b.iteration);
                  const SPARK_WINDOW = 10;
                  const getSparkData = (iteration: number, kpiKey: string) => {
                    const idx = chronoTrials.findIndex((t) => t.iteration === iteration);
                    if (idx < 0) return null;
                    const start = Math.max(0, idx - SPARK_WINDOW);
                    const end = Math.min(chronoTrials.length, idx + SPARK_WINDOW + 1);
                    const window = chronoTrials.slice(start, end);
                    const vals = window.map((t) => Number(t.kpis[kpiKey]) || 0);
                    const hlIdx = idx - start;
                    return { values: vals, highlightIdx: hlIdx };
                  };

                  return (
                    <>
                      {filterLower && (
                        <div className="history-filter-info">
                          Showing {filtered.length} of {trials.length} trials
                        </div>
                      )}
                      <div className="history-table-wrapper">
                        <table className="history-table">
                          <thead>
                            <tr>
                              <th style={{ width: "32px", textAlign: "center", padding: "8px 2px" }} title="Select for comparison">
                                <GitCompare size={12} />
                              </th>
                              <th style={{ width: "36px", textAlign: "center", padding: "8px 4px" }}><Star size={13} /></th>
                              <th className="history-th-sortable" onClick={() => handleHistorySort("__iter__")}>
                                # {historySortCol === "__iter__" && (historySortDir === "asc" ? <ArrowUp size={12} /> : <ArrowDown size={12} />)}
                                {historySortCol !== "__iter__" && <ArrowUpDown size={11} className="history-sort-idle" />}
                              </th>
                              {paramKeys.map((p) => (
                                <th key={p} className="history-th-sortable" onClick={() => handleHistorySort(`p:${p}`)}>
                                  {p}
                                  {historySortCol === `p:${p}` && (historySortDir === "asc" ? <ArrowUp size={12} /> : <ArrowDown size={12} />)}
                                  {historySortCol !== `p:${p}` && <ArrowUpDown size={11} className="history-sort-idle" />}
                                </th>
                              ))}
                              {kpiKeys.map((k) => (
                                <th key={k} className="history-kpi-col history-th-sortable" onClick={() => handleHistorySort(`k:${k}`)}>
                                  {k}
                                  {historySortCol === `k:${k}` && (historySortDir === "asc" ? <ArrowUp size={12} /> : <ArrowDown size={12} />)}
                                  {historySortCol !== `k:${k}` && <ArrowUpDown size={11} className="history-sort-idle" />}
                                </th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {pageTrials.map((trial) => {
                              const isBest = bestResult && trial.iteration === bestResult.iteration;
                              const isExpanded = expandedTrialId === trial.id;
                              return (
                                <Fragment key={trial.id}>
                                  <tr
                                    className={`history-row-clickable ${isBest ? "history-row-best" : ""} ${isExpanded ? "history-row-expanded" : ""} ${bookmarks.has(trial.id) ? "history-row-bookmarked" : ""}`}
                                    onClick={() => setExpandedTrialId(isExpanded ? null : trial.id)}
                                  >
                                    <td className="history-compare-cell" onClick={(e) => { e.stopPropagation(); toggleCompare(trial.id); }}>
                                      <CheckSquare
                                        size={13}
                                        className={`compare-check ${compareSet.has(trial.id) ? "compare-active" : ""}`}
                                        fill={compareSet.has(trial.id) ? "currentColor" : "none"}
                                      />
                                    </td>
                                    <td className="history-bookmark-cell" onClick={(e) => { e.stopPropagation(); toggleBookmark(trial.id); }}>
                                      <Star
                                        size={14}
                                        className={`bookmark-star ${bookmarks.has(trial.id) ? "bookmarked" : ""}`}
                                        fill={bookmarks.has(trial.id) ? "currentColor" : "none"}
                                      />
                                    </td>
                                    <td className="history-iter">
                                      {trial.iteration}
                                      {(trialTags[trial.id]?.length > 0) && (
                                        <span className="trial-tag-dot" title={trialTags[trial.id].join(", ")} />
                                      )}
                                    </td>
                                    {paramKeys.map((p) => {
                                      const spec = specMap[p];
                                      const val = trial.parameters[p];
                                      return (
                                        <td key={p} className="mono history-param-cell">
                                          <span>{typeof val === "number" ? val.toFixed(3) : String(val)}</span>
                                          {spec && typeof val === "number" && (
                                            <MiniRangeBar value={val} lower={spec.lower} upper={spec.upper} />
                                          )}
                                        </td>
                                      );
                                    })}
                                    {kpiKeys.map((k) => {
                                      const spark = getSparkData(trial.iteration, k);
                                      return (
                                        <td key={k} className={`mono history-kpi-val ${isBest ? "history-best-val" : ""}`}>
                                          <span className="history-kpi-cell">
                                            <span>{typeof trial.kpis[k] === "number" ? (trial.kpis[k] as number).toFixed(4) : String(trial.kpis[k])}</span>
                                            {spark && <MiniSparkline values={spark.values} highlightIdx={spark.highlightIdx} />}
                                          </span>
                                          {isBest && <span className="history-best-badge">Best</span>}
                                        </td>
                                      );
                                    })}
                                  </tr>
                                  {isExpanded && (
                                    <tr className="history-detail-row">
                                      <td colSpan={3 + paramKeys.length + kpiKeys.length}>
                                        <div className="history-detail">
                                          <div className="history-detail-section">
                                            <span className="history-detail-label">Iteration</span>
                                            <span className="history-detail-value mono">{trial.iteration}</span>
                                          </div>
                                          {paramKeys.map((p) => (
                                            <div key={p} className="history-detail-section">
                                              <span className="history-detail-label">{p}</span>
                                              <span className="history-detail-value mono">
                                                {typeof trial.parameters[p] === "number" ? (trial.parameters[p] as number).toPrecision(6) : String(trial.parameters[p])}
                                              </span>
                                            </div>
                                          ))}
                                          {kpiKeys.map((k) => (
                                            <div key={k} className="history-detail-section">
                                              <span className="history-detail-label">{k}</span>
                                              <span className="history-detail-value mono" style={{ fontWeight: 600 }}>
                                                {typeof trial.kpis[k] === "number" ? (trial.kpis[k] as number).toPrecision(6) : String(trial.kpis[k])}
                                              </span>
                                            </div>
                                          ))}
                                          {bestResult && (
                                            <div className="history-detail-section">
                                              <span className="history-detail-label">vs Best</span>
                                              <span className="history-detail-value mono">
                                                {(() => {
                                                  const trialVal = Object.values(trial.kpis)[0] ?? 0;
                                                  const bestVal = Object.values(bestResult.kpis)[0] ?? 0;
                                                  const diff = trialVal - bestVal;
                                                  return diff === 0 ? "= Best" : `${diff > 0 ? "+" : ""}${diff.toFixed(4)}`;
                                                })()}
                                              </span>
                                            </div>
                                          )}
                                          <div className="history-detail-note">
                                            <span className="history-detail-label">Note</span>
                                            <input
                                              type="text"
                                              className="history-note-input"
                                              placeholder="Add a note about this trial..."
                                              value={trialNotes[trial.id] || ""}
                                              onChange={(e) => setTrialNote(trial.id, e.target.value)}
                                              onClick={(e) => e.stopPropagation()}
                                            />
                                          </div>
                                          <div className="history-detail-tags" onClick={(e) => e.stopPropagation()}>
                                            <span className="history-detail-label"><Tag size={12} /> Tags</span>
                                            <div className="trial-tag-row">
                                              {TRIAL_TAG_OPTIONS.map(tag => {
                                                const active = (trialTags[trial.id] || []).includes(tag);
                                                return (
                                                  <button
                                                    key={tag}
                                                    className={`trial-tag-btn ${active ? "trial-tag-active" : ""} trial-tag-${tag}`}
                                                    onClick={() => toggleTrialTag(trial.id, tag)}
                                                  >
                                                    {tag}
                                                  </button>
                                                );
                                              })}
                                            </div>
                                          </div>
                                        </div>
                                      </td>
                                    </tr>
                                  )}
                                </Fragment>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                      {/* Pagination */}
                      {totalPages > 1 && (
                        <div className="history-pagination">
                          <button
                            className="btn btn-sm btn-secondary"
                            onClick={() => setHistoryPage((p) => Math.max(0, p - 1))}
                            disabled={historyPage === 0}
                          >
                            <ChevronLeft size={14} /> Prev
                          </button>
                          <span className="history-page-info">
                            Page {historyPage + 1} of {totalPages}
                            <span className="history-page-range">
                              ({historyPage * HISTORY_PAGE_SIZE + 1}–{Math.min((historyPage + 1) * HISTORY_PAGE_SIZE, sorted.length)} of {sorted.length})
                            </span>
                          </span>
                          <button
                            className="btn btn-sm btn-secondary"
                            onClick={() => setHistoryPage((p) => Math.min(totalPages - 1, p + 1))}
                            disabled={historyPage >= totalPages - 1}
                          >
                            Next <ChevronRight size={14} />
                          </button>
                        </div>
                      )}
                    </>
                  );
                })() : (
                  <p className="empty-state">No experiments recorded yet.</p>
                )}
              </div>

              {/* Statistical Quick-Compare */}
              {trials.length >= 8 && (() => {
                const objKey = Object.keys(trials[0].kpis)[0];
                const allVals = trials.map(t => Number(t.kpis[objKey]) || 0).sort((a, b) => a - b);
                const q25idx = Math.floor(allVals.length * 0.25);
                const q75idx = Math.ceil(allVals.length * 0.75);
                const topVals = allVals.slice(0, q25idx); // best 25% (lowest for minimize)
                const bottomVals = allVals.slice(q75idx); // worst 25%
                const stats = (vals: number[]) => {
                  if (vals.length === 0) return { mean: 0, std: 0, min: 0, max: 0, n: 0 };
                  const n = vals.length;
                  const mean = vals.reduce((a, b) => a + b, 0) / n;
                  const variance = vals.reduce((a, v) => a + (v - mean) ** 2, 0) / n;
                  return { mean, std: Math.sqrt(variance), min: Math.min(...vals), max: Math.max(...vals), n };
                };
                const topS = stats(topVals);
                const botS = stats(bottomVals);
                // Cohen's d effect size
                const pooledStd = Math.sqrt(((topS.std ** 2) * topS.n + (botS.std ** 2) * botS.n) / (topS.n + botS.n));
                const cohenD = pooledStd > 0 ? Math.abs(topS.mean - botS.mean) / pooledStd : 0;
                const effectLabel = cohenD > 0.8 ? "Large" : cohenD > 0.5 ? "Medium" : cohenD > 0.2 ? "Small" : "Negligible";
                const effectColor = cohenD > 0.8 ? "#22c55e" : cohenD > 0.5 ? "#eab308" : "#94a3b8";
                // Improvement %
                const improvement = botS.mean !== 0 ? ((botS.mean - topS.mean) / Math.abs(botS.mean) * 100) : 0;

                return (
                  <div className="card stat-compare-card">
                    <div className="stat-compare-header" onClick={() => setShowStatCompare(p => !p)} style={{ cursor: "pointer" }}>
                      <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                        <BarChart2 size={16} style={{ color: "var(--color-primary)" }} />
                        <h2 style={{ margin: 0 }}>Statistical Quick-Compare</h2>
                        <span className="stat-compare-badge" style={{ background: effectColor }}>{effectLabel} effect</span>
                      </div>
                      <ChevronRight size={16} style={{ transform: showStatCompare ? "rotate(90deg)" : "none", transition: "transform 0.2s", color: "var(--color-text-muted)" }} />
                    </div>
                    {showStatCompare && (
                      <div className="stat-compare-body">
                        <p className="range-desc" style={{ marginBottom: "12px" }}>Comparing best 25% of trials vs worst 25% by {objKey}.</p>
                        <div className="stat-compare-grid">
                          <div className="stat-compare-group stat-compare-top">
                            <div className="stat-compare-group-title">Best 25% ({topS.n} trials)</div>
                            <div className="stat-compare-row">
                              <span>Mean</span><span className="mono">{topS.mean.toFixed(4)}</span>
                            </div>
                            <div className="stat-compare-row">
                              <span>Std Dev</span><span className="mono">{topS.std.toFixed(4)}</span>
                            </div>
                            <div className="stat-compare-row">
                              <span>Range</span><span className="mono">[{topS.min.toFixed(4)}, {topS.max.toFixed(4)}]</span>
                            </div>
                          </div>
                          <div className="stat-compare-group stat-compare-bottom">
                            <div className="stat-compare-group-title">Worst 25% ({botS.n} trials)</div>
                            <div className="stat-compare-row">
                              <span>Mean</span><span className="mono">{botS.mean.toFixed(4)}</span>
                            </div>
                            <div className="stat-compare-row">
                              <span>Std Dev</span><span className="mono">{botS.std.toFixed(4)}</span>
                            </div>
                            <div className="stat-compare-row">
                              <span>Range</span><span className="mono">[{botS.min.toFixed(4)}, {botS.max.toFixed(4)}]</span>
                            </div>
                          </div>
                        </div>
                        <div className="stat-compare-summary">
                          <div className="stat-compare-row">
                            <span>Effect Size (Cohen's d)</span>
                            <span className="mono" style={{ color: effectColor, fontWeight: 600 }}>{cohenD.toFixed(3)} ({effectLabel})</span>
                          </div>
                          <div className="stat-compare-row">
                            <span>Improvement</span>
                            <span className="mono" style={{ fontWeight: 600 }}>{improvement > 0 ? "+" : ""}{improvement.toFixed(1)}%</span>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                );
              })()}

              {/* Trial Comparison Modal */}
              {showCompareModal && compareSet.size >= 2 && (() => {
                const compareTrials = trials.filter(t => compareSet.has(t.id));
                if (compareTrials.length < 2) return null;
                const paramKeys2 = Object.keys(compareTrials[0].parameters);
                const kpiKeys2 = Object.keys(compareTrials[0].kpis);
                const bestCompareKpi = Math.min(...compareTrials.map(t => Number(Object.values(t.kpis)[0]) || 0));
                return (
                  <div className="shortcut-overlay" onClick={() => setShowCompareModal(false)}>
                    <div className="compare-modal" onClick={(e) => e.stopPropagation()}>
                      <div className="shortcut-modal-header">
                        <h3><GitCompare size={16} /> Trial Comparison</h3>
                        <button className="shortcut-close" onClick={() => setShowCompareModal(false)}><span>&times;</span></button>
                      </div>
                      <div className="compare-table-wrap">
                        <table className="compare-table">
                          <thead>
                            <tr>
                              <th className="compare-label-col">Metric</th>
                              {compareTrials.map(t => (
                                <th key={t.id} className={`compare-trial-col ${Number(Object.values(t.kpis)[0]) === bestCompareKpi ? "compare-best-col" : ""}`}>
                                  Trial #{t.iteration}
                                  {Number(Object.values(t.kpis)[0]) === bestCompareKpi && <span className="compare-best-tag">Best</span>}
                                </th>
                              ))}
                              {compareTrials.length === 2 && <th className="compare-delta-col">Delta</th>}
                            </tr>
                          </thead>
                          <tbody>
                            {kpiKeys2.map(k => {
                              const vals = compareTrials.map(t => Number(t.kpis[k]) || 0);
                              const best = Math.min(...vals);
                              return (
                                <tr key={`k-${k}`} className="compare-kpi-row">
                                  <td className="compare-label">{k}</td>
                                  {vals.map((v, i) => (
                                    <td key={i} className={`mono compare-val ${v === best ? "compare-val-best" : ""}`}>
                                      {v.toFixed(4)}
                                    </td>
                                  ))}
                                  {vals.length === 2 && (
                                    <td className={`mono compare-delta ${vals[1] - vals[0] < 0 ? "compare-delta-better" : vals[1] - vals[0] > 0 ? "compare-delta-worse" : ""}`}>
                                      {(vals[1] - vals[0]).toFixed(4)}
                                    </td>
                                  )}
                                </tr>
                              );
                            })}
                            {paramKeys2.map(p => {
                              const vals = compareTrials.map(t => Number(t.parameters[p]) || 0);
                              return (
                                <tr key={`p-${p}`}>
                                  <td className="compare-label">{p}</td>
                                  {vals.map((v, i) => (
                                    <td key={i} className="mono compare-val">{v.toFixed(4)}</td>
                                  ))}
                                  {vals.length === 2 && (
                                    <td className="mono compare-delta">{(vals[1] - vals[0]).toFixed(4)}</td>
                                  )}
                                </tr>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                      <div className="compare-footer">
                        <button className="btn btn-sm btn-secondary" onClick={() => { setCompareSet(new Set()); setShowCompareModal(false); }}>
                          Clear Selection
                        </button>
                      </div>
                    </div>
                  </div>
                );
              })()}
            </div>
          )}

          {activeTab === "export" && (
            <div className="tab-panel">
              {/* Campaign Summary */}
              <div className="export-summary">
                <div className="export-summary-item">
                  <span className="export-summary-label">Parameters</span>
                  <span className="export-summary-value">{trials.length > 0 ? Object.keys(trials[0].parameters).length : 0}</span>
                </div>
                <div className="export-summary-item">
                  <span className="export-summary-label">Objectives</span>
                  <span className="export-summary-value">{campaign.objective_names?.length ?? 1}</span>
                </div>
                <div className="export-summary-item">
                  <span className="export-summary-label">Experiments</span>
                  <span className="export-summary-value">{trials.length}</span>
                </div>
                <div className="export-summary-item">
                  <span className="export-summary-label">Best KPI</span>
                  <span className="export-summary-value mono">{campaign.best_kpi?.toFixed(4) ?? "—"}</span>
                </div>
              </div>

              {/* Data Export */}
              <div className="card">
                <h2><Table size={18} /> Data Export</h2>
                <p className="export-desc">
                  Download all experiment data including parameters, objectives, and iteration metadata.
                </p>
                <div className="export-grid">
                  <button className="export-card" onClick={() => handleExport("csv")}>
                    <div className="export-card-icon export-card-icon-csv"><FileSpreadsheet size={24} /></div>
                    <div className="export-card-info">
                      <span className="export-card-title">CSV</span>
                      <span className="export-card-desc">Spreadsheet-compatible format. Best for Excel, Google Sheets, or R/pandas.</span>
                    </div>
                  </button>
                  <button className="export-card" onClick={() => handleExport("json")}>
                    <div className="export-card-icon export-card-icon-json"><FileJson size={24} /></div>
                    <div className="export-card-info">
                      <span className="export-card-title">JSON</span>
                      <span className="export-card-desc">Structured data with full metadata. Best for programmatic consumption.</span>
                    </div>
                  </button>
                  <button className="export-card" onClick={() => handleExport("xlsx")}>
                    <div className="export-card-icon export-card-icon-xlsx"><FileSpreadsheet size={24} /></div>
                    <div className="export-card-info">
                      <span className="export-card-title">Excel</span>
                      <span className="export-card-desc">Native Excel workbook with formatted headers and data validation.</span>
                    </div>
                  </button>
                </div>
              </div>

              {/* Figure Export */}
              <div className="card">
                <h2><Image size={18} /> Figure Export</h2>
                <p className="export-desc">
                  Export publication-ready figures of your optimization results.
                </p>
                <div className="export-figure-options">
                  <label className="export-figure-label">
                    Resolution
                    <select className="input">
                      <option>72 DPI (Screen)</option>
                      <option>150 DPI</option>
                      <option>300 DPI (Print)</option>
                      <option>600 DPI (Publication)</option>
                    </select>
                  </label>
                  <label className="export-figure-label">
                    Format
                    <select className="input">
                      <option>PNG</option>
                      <option>SVG</option>
                      <option>PDF</option>
                    </select>
                  </label>
                  <label className="export-figure-label">
                    Style
                    <select className="input">
                      <option>Default</option>
                      <option>ACS (Journals)</option>
                      <option>Nature</option>
                    </select>
                  </label>
                </div>
                <div className="export-figure-charts">
                  <label className="export-figure-check">
                    <input type="checkbox" defaultChecked /> <BarChart3 size={14} /> Convergence Plot
                  </label>
                  <label className="export-figure-check">
                    <input type="checkbox" defaultChecked /> <BarChart3 size={14} /> Parameter Importance
                  </label>
                  <label className="export-figure-check">
                    <input type="checkbox" defaultChecked /> <BarChart3 size={14} /> Parameter Space
                  </label>
                  <label className="export-figure-check">
                    <input type="checkbox" /> <BarChart3 size={14} /> Phase Timeline
                  </label>
                </div>
                <button className="btn btn-primary export-figure-btn">
                  <Image size={14} /> Export Selected Figures
                </button>
              </div>

              {/* Report */}
              <div className="card">
                <h2><ClipboardList size={18} /> Campaign Report</h2>
                <p className="export-desc">
                  Generate a comprehensive PDF report with convergence analysis,
                  parameter importance, best results, diagnostics, and experiment history.
                </p>
                <div className="export-report-preview">
                  <div className="export-report-section"><FileText size={14} /> Executive Summary</div>
                  <div className="export-report-section"><BarChart3 size={14} /> Convergence Analysis</div>
                  <div className="export-report-section"><BarChart3 size={14} /> Parameter Importance</div>
                  <div className="export-report-section"><Table size={14} /> Full Experiment Log ({trials.length} rows)</div>
                  <div className="export-report-section"><CheckCircle size={14} /> Best Result + Recommendations</div>
                </div>
                <button className="btn btn-primary export-figure-btn">
                  <FileDown size={14} /> Generate PDF Report
                </button>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Chat Sidebar */}
      <div className={`workspace-chat ${chatOpen ? "open" : "closed"}`}>
        <button
          className="chat-toggle-btn"
          onClick={() => setChatOpen(!chatOpen)}
          aria-label={chatOpen ? "Close chat" : "Open chat"}
        >
          {chatOpen ? <ChevronRight size={20} /> : <ChevronLeft size={20} />}
        </button>
        {chatOpen && (
          <ChatPanel
            campaignId={id}
            isOpen={chatOpen}
            onToggle={() => setChatOpen(!chatOpen)}
          />
        )}
      </div>

      {/* Keyboard Shortcut Help Modal */}
      {showShortcuts && (
        <div className="shortcut-overlay" onClick={() => setShowShortcuts(false)}>
          <div className="shortcut-modal" onClick={(e) => e.stopPropagation()}>
            <div className="shortcut-modal-header">
              <h3>Keyboard Shortcuts</h3>
              <button className="shortcut-close" onClick={() => setShowShortcuts(false)}>
                <span>&times;</span>
              </button>
            </div>
            <div className="shortcut-group">
              <div className="shortcut-group-title">Navigation</div>
              <div className="shortcut-item"><kbd>1</kbd> Overview</div>
              <div className="shortcut-item"><kbd>2</kbd> Explore</div>
              <div className="shortcut-item"><kbd>3</kbd> Suggestions</div>
              <div className="shortcut-item"><kbd>4</kbd> Insights</div>
              <div className="shortcut-item"><kbd>5</kbd> History</div>
              <div className="shortcut-item"><kbd>6</kbd> Export</div>
            </div>
            <div className="shortcut-group">
              <div className="shortcut-group-title">Actions</div>
              <div className="shortcut-item"><kbd>b</kbd> Jump to best trial</div>
              <div className="shortcut-item"><kbd>g</kbd> Generate suggestions</div>
              <div className="shortcut-item"><kbd>f</kbd> Focus filter input</div>
              <div className="shortcut-item"><kbd>?</kbd> Toggle this help</div>
              <div className="shortcut-item"><kbd>Esc</kbd> Close modal / collapse</div>
            </div>
            <div className="shortcut-hint">Press <kbd>?</kbd> to dismiss</div>
          </div>
        </div>
      )}

      <style>{`
        .workspace-container {
          display: flex;
          height: calc(100vh - 56px);
          position: relative;
        }

        .workspace-breadcrumb {
          display: flex;
          align-items: center;
          gap: 6px;
          padding: 8px 24px;
          background: var(--color-surface);
          border-bottom: 1px solid var(--color-border-subtle);
          font-size: 0.78rem;
        }

        .breadcrumb-link {
          display: flex;
          align-items: center;
          gap: 4px;
          color: var(--color-text-muted);
          text-decoration: none;
          transition: color var(--transition-fast);
        }

        .breadcrumb-link:hover {
          color: var(--color-primary);
        }

        .breadcrumb-sep {
          color: var(--color-text-muted);
          opacity: 0.5;
        }

        .breadcrumb-current {
          color: var(--color-text);
          font-weight: 500;
        }

        .workspace-main {
          flex: 1;
          display: flex;
          flex-direction: column;
          overflow: hidden;
          transition: width 0.3s ease;
        }

        .workspace-main.chat-open {
          width: 70%;
        }

        .workspace-header {
          padding: 24px 24px 16px;
          border-bottom: 1px solid var(--color-border);
          background: var(--color-surface);
        }

        .workspace-header {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
        }

        .workspace-actions {
          display: flex;
          gap: 8px;
          flex-shrink: 0;
        }

        .workspace-action-btn {
          display: flex;
          align-items: center;
          gap: 5px;
          white-space: nowrap;
        }

        .workspace-header h1 {
          font-size: 1.5rem;
          font-weight: 700;
          margin-bottom: 8px;
        }

        .workspace-meta {
          display: flex;
          gap: 12px;
          align-items: center;
          font-size: 0.85rem;
        }

        .shortcut-overlay {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.4);
          z-index: 9000;
          display: flex;
          align-items: center;
          justify-content: center;
          animation: fadeIn 0.15s ease;
        }

        .shortcut-modal {
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: 16px;
          padding: 24px 28px;
          min-width: 320px;
          max-width: 400px;
          box-shadow: var(--shadow-lg);
        }

        .shortcut-modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
        }

        .shortcut-modal-header h3 {
          font-size: 1rem;
          font-weight: 700;
          margin: 0;
        }

        .shortcut-close {
          background: none;
          border: none;
          font-size: 1.3rem;
          cursor: pointer;
          color: var(--color-text-muted);
          line-height: 1;
          padding: 4px;
        }

        .shortcut-group {
          margin-bottom: 16px;
        }

        .shortcut-group-title {
          font-size: 0.72rem;
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.06em;
          color: var(--color-text-muted);
          margin-bottom: 8px;
        }

        .shortcut-item {
          display: flex;
          align-items: center;
          gap: 10px;
          padding: 5px 0;
          font-size: 0.85rem;
          color: var(--color-text);
        }

        .shortcut-item kbd {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-width: 28px;
          height: 24px;
          padding: 0 6px;
          background: var(--color-bg);
          border: 1px solid var(--color-border);
          border-radius: 5px;
          font-size: 0.72rem;
          font-weight: 600;
          font-family: var(--font-mono);
          color: var(--color-text-muted);
        }

        .shortcut-hint {
          font-size: 0.75rem;
          color: var(--color-text-muted);
          text-align: center;
          margin-top: 12px;
          padding-top: 12px;
          border-top: 1px solid var(--color-border-subtle);
        }

        .shortcut-hint kbd {
          display: inline;
          padding: 1px 5px;
          background: var(--color-bg);
          border: 1px solid var(--color-border);
          border-radius: 3px;
          font-size: 0.7rem;
          font-family: var(--font-mono);
        }

        .workspace-refresh-indicator {
          display: inline-flex;
          align-items: center;
          gap: 4px;
          font-size: 0.72rem;
          font-weight: 600;
          color: var(--color-green);
          background: rgba(22, 179, 100, 0.08);
          padding: 2px 8px;
          border-radius: 10px;
          letter-spacing: 0.03em;
        }

        .refresh-spin {
          animation: refreshPulse 3s ease-in-out infinite;
        }

        @keyframes refreshPulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.3; }
        }

        .workspace-tabs {
          display: flex;
          gap: 4px;
          padding: 0 24px;
          background: var(--color-surface);
          border-bottom: 2px solid var(--color-border);
          overflow-x: auto;
        }

        .workspace-tab {
          display: flex;
          align-items: center;
          gap: 6px;
          padding: 12px 16px;
          background: none;
          border: none;
          border-bottom: 2px solid transparent;
          margin-bottom: -2px;
          font-size: 0.9rem;
          font-weight: 500;
          color: var(--color-text-muted);
          cursor: pointer;
          transition: all 0.15s;
          white-space: nowrap;
        }

        .workspace-tab:hover {
          color: var(--color-text);
          background: var(--color-bg);
        }

        .workspace-tab.active {
          color: var(--color-primary);
          border-bottom-color: var(--color-primary);
        }

        .tab-badge {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-width: 18px;
          height: 18px;
          padding: 0 5px;
          border-radius: 9px;
          font-size: 0.65rem;
          font-weight: 700;
          font-family: var(--font-mono);
          background: var(--color-primary-subtle);
          color: var(--color-primary);
          line-height: 1;
        }

        .workspace-tab.active .tab-badge {
          background: var(--color-primary);
          color: white;
        }

        .tab-kbd {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 18px;
          height: 18px;
          border-radius: 3px;
          background: var(--color-bg);
          border: 1px solid var(--color-border);
          font-size: 0.65rem;
          font-weight: 600;
          color: var(--color-text-muted);
          margin-left: 4px;
          opacity: 0.5;
          transition: opacity var(--transition-fast);
        }

        .workspace-tab:hover .tab-kbd,
        .workspace-tab.active .tab-kbd {
          opacity: 0.8;
        }

        .quality-warnings {
          display: flex;
          flex-direction: column;
          gap: 6px;
          padding: 10px 24px;
          background: var(--color-surface);
          border-bottom: 1px solid var(--color-border-subtle);
        }

        .quality-warning {
          display: flex;
          align-items: center;
          gap: 10px;
          padding: 8px 12px;
          border-radius: var(--radius);
          font-size: 0.82rem;
          font-weight: 500;
          animation: slideDown 0.2s ease;
        }

        .quality-warning-error {
          background: #fef2f2;
          border: 1px solid #fca5a5;
          color: #991b1b;
        }

        .quality-warning-warning {
          background: #fffbeb;
          border: 1px solid #fcd34d;
          color: #92400e;
        }

        .quality-warning-info {
          background: #eff6ff;
          border: 1px solid #93c5fd;
          color: #1e40af;
        }

        [data-theme="dark"] .quality-warning-error {
          background: #450a0a;
          border-color: #991b1b;
          color: #fca5a5;
        }

        [data-theme="dark"] .quality-warning-warning {
          background: #451a03;
          border-color: #92400e;
          color: #fcd34d;
        }

        [data-theme="dark"] .quality-warning-info {
          background: #172554;
          border-color: #1e40af;
          color: #93c5fd;
        }

        .quality-warning-icon {
          flex-shrink: 0;
          display: flex;
          align-items: center;
        }

        .quality-warning-msg {
          flex: 1;
          line-height: 1.4;
        }

        .quality-warning-dismiss {
          flex-shrink: 0;
          background: none;
          border: none;
          color: inherit;
          opacity: 0.4;
          cursor: pointer;
          font-size: 1.1rem;
          padding: 0 4px;
          line-height: 1;
          transition: opacity var(--transition-fast);
        }

        .quality-warning-dismiss:hover {
          opacity: 1;
        }

        @keyframes slideDown {
          from { opacity: 0; transform: translateY(-6px); }
          to { opacity: 1; transform: translateY(0); }
        }

        .workspace-content {
          flex: 1;
          overflow-y: auto;
          padding: 24px;
          background: var(--color-bg);
        }

        .tab-panel {
          animation: fadeSlideUp 0.25s ease;
        }

        @keyframes fadeSlideUp {
          from { opacity: 0; transform: translateY(8px); }
          to { opacity: 1; transform: translateY(0); }
        }

        /* Staggered card reveals */
        .suggestions-grid > * {
          animation: fadeSlideUp 0.3s ease both;
        }
        .suggestions-grid > *:nth-child(2) { animation-delay: 50ms; }
        .suggestions-grid > *:nth-child(3) { animation-delay: 100ms; }
        .suggestions-grid > *:nth-child(4) { animation-delay: 150ms; }
        .suggestions-grid > *:nth-child(5) { animation-delay: 200ms; }
        .suggestions-grid > *:nth-child(n+6) { animation-delay: 250ms; }

        .stats-row > * {
          animation: fadeSlideUp 0.25s ease both;
        }
        .stats-row > *:nth-child(2) { animation-delay: 40ms; }
        .stats-row > *:nth-child(3) { animation-delay: 80ms; }
        .stats-row > *:nth-child(4) { animation-delay: 120ms; }

        @media (prefers-reduced-motion: reduce) {
          .tab-panel, .suggestions-grid > *, .stats-row > * {
            animation: none;
          }
        }

        /* Bookmark styles */
        .history-bookmark-cell {
          text-align: center;
          padding: 8px 4px !important;
          cursor: pointer;
          width: 36px;
        }
        .bookmark-star {
          color: var(--color-text-muted);
          opacity: 0.25;
          transition: all 0.15s;
        }
        .bookmark-star:hover {
          opacity: 0.7;
          color: #f59e0b;
        }
        .bookmark-star.bookmarked {
          color: #f59e0b;
          opacity: 1;
        }
        .history-row-bookmarked {
          border-left: 3px solid #f59e0b !important;
        }
        .btn-bookmark-active {
          background: linear-gradient(135deg, #f59e0b, #d97706) !important;
          color: white !important;
          border-color: #d97706 !important;
          font-weight: 600;
        }
        .history-note-input {
          flex: 1;
          padding: 4px 8px;
          border: 1px solid var(--color-border);
          border-radius: 6px;
          font-size: 0.82rem;
          font-family: inherit;
          background: var(--color-surface);
          color: var(--color-text);
          width: 100%;
          max-width: 400px;
          transition: border-color 0.15s;
        }
        .history-note-input:focus {
          outline: none;
          border-color: var(--color-primary);
          box-shadow: 0 0 0 2px rgba(79, 110, 247, 0.1);
        }
        .history-detail-note {
          display: flex;
          align-items: center;
          gap: 8px;
          grid-column: 1 / -1;
          padding-top: 8px;
          border-top: 1px solid var(--color-border-subtle);
          margin-top: 4px;
        }

        .workspace-chat {
          width: 30%;
          border-left: 1px solid var(--color-border);
          background: var(--color-surface);
          position: relative;
          transition: width 0.3s ease;
          display: flex;
          flex-direction: column;
        }

        .workspace-chat.closed {
          width: 0;
          overflow: hidden;
        }

        .chat-toggle-btn {
          position: absolute;
          left: -12px;
          top: 50%;
          transform: translateY(-50%);
          width: 24px;
          height: 48px;
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: var(--radius) 0 0 var(--radius);
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.15s;
          z-index: 10;
        }

        .chat-toggle-btn:hover {
          background: var(--color-bg);
        }

        .suggestions-controls {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 24px;
          flex-wrap: wrap;
          gap: 12px;
        }
        .suggestions-controls-left {
          display: flex;
          align-items: center;
          gap: 16px;
        }
        .suggestions-generate-btn {
          display: flex;
          align-items: center;
          gap: 8px;
          font-weight: 600;
        }
        .suggestions-spinner {
          width: 16px;
          height: 16px;
          border: 2px solid rgba(255,255,255,0.3);
          border-top-color: #fff;
          border-radius: 50%;
          animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .suggestions-batch-label {
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 0.82rem;
          color: var(--color-text-muted);
          font-weight: 500;
        }
        .suggestions-batch-select {
          padding: 4px 8px;
          border: 1px solid var(--color-border);
          border-radius: 6px;
          background: var(--color-surface);
          font-size: 0.82rem;
          font-family: inherit;
          color: var(--color-text);
        }
        .suggestions-meta {
          display: flex;
          gap: 8px;
        }
        .suggestions-meta-pill {
          display: inline-flex;
          align-items: center;
          gap: 4px;
          padding: 4px 10px;
          background: var(--color-bg);
          border: 1px solid var(--color-border);
          border-radius: 20px;
          font-size: 0.75rem;
          color: var(--color-text-muted);
          font-weight: 500;
        }
        .suggestions-empty {
          text-align: center;
          padding: 60px 24px;
          max-width: 480px;
          margin: 0 auto;
        }
        .suggestions-empty-icon {
          width: 72px;
          height: 72px;
          border-radius: 50%;
          background: var(--color-primary-subtle, rgba(79, 110, 247, 0.08));
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto 20px;
          color: var(--color-primary);
        }
        .suggestions-empty h3 {
          font-size: 1.1rem;
          font-weight: 600;
          margin: 0 0 8px;
          color: var(--color-text);
        }
        .suggestions-empty p {
          font-size: 0.88rem;
          color: var(--color-text-muted);
          line-height: 1.6;
          margin: 0 0 16px;
        }
        .suggestions-empty-info {
          display: flex;
          align-items: flex-start;
          gap: 8px;
          padding: 12px 16px;
          background: var(--color-bg);
          border-radius: 8px;
          font-size: 0.82rem;
          color: var(--color-text-muted);
          line-height: 1.5;
          text-align: left;
        }
        .suggestions-empty-info svg {
          flex-shrink: 0;
          margin-top: 2px;
        }
        .suggestion-skeleton {
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: 12px;
          padding: 20px;
        }
        .skeleton-line {
          height: 12px;
          background: var(--color-bg);
          border-radius: 6px;
          margin-bottom: 12px;
          animation: pulse 1.5s ease-in-out infinite;
        }
        .skeleton-line-short { width: 40%; }
        .skeleton-line-medium { width: 70%; }
        .skeleton-line-long { width: 90%; }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.4; }
        }

        .suggestions-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
          gap: 16px;
          margin-bottom: 24px;
        }

        @media (max-width: 1024px) {
          .workspace-main.chat-open {
            width: 100%;
          }

          .workspace-chat {
            position: fixed;
            right: 0;
            top: 56px;
            bottom: 0;
            width: 400px;
            max-width: 90vw;
            z-index: 100;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
          }

          .workspace-chat.closed {
            transform: translateX(100%);
          }
        }

        @media (max-width: 768px) {
          .workspace-header {
            padding: 16px;
          }

          .workspace-content {
            padding: 16px;
          }

          .workspace-tabs {
            padding: 0 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
          }

          .workspace-tabs::-webkit-scrollbar {
            display: none;
          }

          .workspace-tab {
            padding: 10px 12px;
            font-size: 0.82rem;
            white-space: nowrap;
            flex-shrink: 0;
          }

          .tab-kbd {
            display: none;
          }

          .suggestions-grid {
            grid-template-columns: 1fr;
          }

          .workspace-layout {
            flex-direction: column;
          }

          .workspace-chat {
            width: 100%;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50vh;
            z-index: 50;
            border-top: 1px solid var(--color-border);
            border-left: none;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
          }

          .workspace-main {
            padding-bottom: 60px;
          }

          .workspace-breadcrumb {
            font-size: 0.78rem;
            padding: 8px 16px;
          }

          .workspace-meta {
            flex-wrap: wrap;
            gap: 6px;
          }

          .workspace-title {
            font-size: 1.1rem;
          }

          .stats-row {
            grid-template-columns: repeat(2, 1fr);
          }

          .history-toolbar {
            flex-direction: column;
            gap: 8px;
          }
        }

        @media (max-width: 480px) {
          .stats-row {
            grid-template-columns: 1fr;
          }

          .workspace-tab span {
            display: none;
          }

          .workspace-tab .tab-badge {
            display: inline-flex;
          }
        }

        /* ── Diversity badges ── */
        .suggestion-card-wrapper {
          position: relative;
        }
        .diversity-badge {
          position: absolute;
          top: -6px;
          right: 12px;
          z-index: 2;
          display: inline-flex;
          align-items: center;
          gap: 4px;
          padding: 2px 10px;
          font-size: 0.68rem;
          font-weight: 700;
          letter-spacing: 0.03em;
          border-radius: 10px;
          text-transform: uppercase;
        }
        .diversity-high {
          background: #dbeafe;
          color: #1d4ed8;
          border: 1px solid #93c5fd;
        }
        .diversity-mid {
          background: #fef3c7;
          color: #92400e;
          border: 1px solid #fcd34d;
        }
        .diversity-low {
          background: #f0fdf4;
          color: #166534;
          border: 1px solid #86efac;
        }
        [data-theme="dark"] .diversity-high {
          background: #1e3a5f;
          color: #93c5fd;
          border-color: #1d4ed8;
        }
        [data-theme="dark"] .diversity-mid {
          background: #451a03;
          color: #fcd34d;
          border-color: #92400e;
        }
        [data-theme="dark"] .diversity-low {
          background: #052e16;
          color: #86efac;
          border-color: #166534;
        }

        /* ── Rejected suggestion stack ── */
        .rejected-stack {
          margin-top: 16px;
          border: 1px solid var(--color-border);
          border-radius: var(--radius-lg, 12px);
          background: var(--color-surface);
          overflow: hidden;
        }
        .rejected-stack-toggle {
          display: flex;
          align-items: center;
          gap: 8px;
          width: 100%;
          padding: 12px 16px;
          background: none;
          border: none;
          font-size: 0.85rem;
          font-weight: 500;
          color: var(--color-text-muted);
          cursor: pointer;
          font-family: inherit;
          transition: color 0.15s, background 0.15s;
        }
        .rejected-stack-toggle:hover {
          color: var(--color-text);
          background: var(--color-bg);
        }
        .rejected-stack-list {
          border-top: 1px solid var(--color-border);
          animation: fadeSlideUp 0.2s ease;
        }
        .rejected-item {
          padding: 12px 16px;
          border-bottom: 1px solid var(--color-border-subtle);
        }
        .rejected-item:last-child {
          border-bottom: none;
        }
        .rejected-item-header {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 6px;
        }
        .rejected-item-index {
          font-weight: 700;
          font-size: 0.88rem;
          color: var(--color-text-muted);
        }
        .rejected-item-time {
          font-size: 0.72rem;
          color: var(--color-text-muted);
          opacity: 0.6;
        }
        .rejected-reconsider-btn {
          margin-left: auto;
          font-size: 0.72rem !important;
          padding: 3px 10px !important;
        }
        .rejected-item-params {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          font-size: 0.78rem;
        }
        .rejected-param {
          display: flex;
          gap: 4px;
          padding: 2px 8px;
          background: var(--color-bg);
          border-radius: 6px;
        }
        .rejected-param-name {
          color: var(--color-text-muted);
          font-weight: 500;
        }
        .rejected-param-more {
          color: var(--color-text-muted);
          font-size: 0.72rem;
          padding: 2px 6px;
          opacity: 0.6;
        }

        /* ── Checkpoint styles ── */
        .checkpoint-controls {
          display: flex;
          align-items: center;
          gap: 12px;
          margin-bottom: 16px;
        }
        .checkpoint-count {
          font-size: 0.78rem;
          color: var(--color-text-muted);
        }
        .checkpoint-modal {
          min-width: 380px;
        }
        .checkpoint-modal-desc {
          font-size: 0.85rem;
          color: var(--color-text-muted);
          margin: 0 0 16px;
          line-height: 1.5;
        }
        .checkpoint-modal-snapshot {
          background: var(--color-bg);
          border-radius: 8px;
          padding: 12px 14px;
          margin-bottom: 16px;
        }
        .checkpoint-snapshot-row {
          display: flex;
          justify-content: space-between;
          font-size: 0.82rem;
          padding: 4px 0;
        }
        .checkpoint-snapshot-row + .checkpoint-snapshot-row {
          border-top: 1px solid var(--color-border-subtle);
        }
        .checkpoint-title-input {
          width: 100%;
          max-width: 100%;
          margin-bottom: 16px;
          padding: 8px 12px;
        }
        .checkpoint-modal-actions {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }
        .checkpoint-list {
          display: flex;
          flex-direction: column;
          gap: 4px;
          margin-bottom: 16px;
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: var(--radius-lg, 12px);
          padding: 8px;
        }
        .checkpoint-item {
          display: flex;
          align-items: center;
          gap: 10px;
          padding: 8px 10px;
          border-radius: 8px;
          transition: background 0.15s;
        }
        .checkpoint-item:hover {
          background: var(--color-bg);
        }
        .checkpoint-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background: var(--color-primary);
          flex-shrink: 0;
        }
        .checkpoint-info {
          flex: 1;
          min-width: 0;
        }
        .checkpoint-title {
          display: block;
          font-size: 0.85rem;
          font-weight: 600;
          color: var(--color-text);
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }
        .checkpoint-meta {
          display: block;
          font-size: 0.72rem;
          color: var(--color-text-muted);
          margin-top: 2px;
        }
        .checkpoint-remove {
          background: none;
          border: none;
          color: var(--color-text-muted);
          opacity: 0;
          cursor: pointer;
          font-size: 1rem;
          padding: 2px 6px;
          transition: opacity 0.15s, color 0.15s;
        }
        .checkpoint-item:hover .checkpoint-remove {
          opacity: 0.5;
        }
        .checkpoint-remove:hover {
          opacity: 1 !important;
          color: #ef4444;
        }

        /* ── Parameter Variance Sentinel ── */
        .sentinel-card {
          transition: border-color 0.3s;
        }
        .sentinel-alert {
          border-color: #fca5a5 !important;
        }
        .sentinel-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 10px;
          margin-bottom: 12px;
        }
        .sentinel-header-left {
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .sentinel-header-left h2 {
          font-size: 1rem;
        }
        .sentinel-alert-badge {
          display: inline-flex;
          padding: 2px 8px;
          font-size: 0.68rem;
          font-weight: 700;
          border-radius: 8px;
          background: #fef2f2;
          color: #dc2626;
          border: 1px solid #fca5a5;
          text-transform: uppercase;
          letter-spacing: 0.03em;
        }
        [data-theme="dark"] .sentinel-alert-badge {
          background: #450a0a;
          color: #fca5a5;
          border-color: #991b1b;
        }
        .sentinel-desc {
          font-size: 0.82rem;
          color: var(--color-text-muted);
          margin: 0 0 14px;
        }
        .sentinel-body {
          animation: fadeSlideUp 0.2s ease;
        }
        .sentinel-row {
          display: flex;
          align-items: center;
          gap: 10px;
          padding: 6px 0;
          border-bottom: 1px solid var(--color-border-subtle);
        }
        .sentinel-row:last-child {
          border-bottom: none;
        }
        .sentinel-row-alert {
          background: rgba(239, 68, 68, 0.04);
          margin: 0 -12px;
          padding: 6px 12px;
          border-radius: 6px;
        }
        .sentinel-param-name {
          width: 100px;
          font-size: 0.78rem;
          font-weight: 500;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          flex-shrink: 0;
        }
        .sentinel-variance-bar {
          flex: 1;
          height: 5px;
          background: var(--color-border);
          border-radius: 3px;
          overflow: hidden;
        }
        .sentinel-variance-fill {
          height: 100%;
          border-radius: 3px;
          transition: width 0.4s ease;
          min-width: 2px;
        }
        .sentinel-std {
          width: 45px;
          font-size: 0.72rem;
          font-weight: 600;
          text-align: right;
          flex-shrink: 0;
        }
        .sentinel-warn-tag {
          font-size: 0.62rem;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 0.04em;
          color: #ef4444;
          flex-shrink: 0;
        }

        /* ── Goal Tracker ── */
        .goal-tracker-card { }
        .goal-tracker-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-bottom: 14px;
        }
        .goal-tracker-header-left {
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .goal-tracker-header-left h2 { font-size: 1rem; }
        .goal-empty {
          font-size: 0.85rem;
          color: var(--color-text-muted);
          font-style: italic;
          margin: 0;
        }
        .goal-list { display: flex; flex-direction: column; gap: 10px; }
        .goal-item {
          padding: 12px 14px;
          border: 1px solid var(--color-border);
          border-radius: 10px;
          background: var(--color-surface);
          transition: border-color 0.2s;
        }
        .goal-item-reached { border-color: #22c55e; background: rgba(34, 197, 94, 0.04); }
        .goal-item-on-track { border-color: #3b82f6; }
        .goal-item-at-risk { border-color: #eab308; }
        .goal-item-behind { border-color: #ef4444; }
        .goal-item-top {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 8px;
        }
        .goal-item-name {
          font-weight: 600;
          font-size: 0.9rem;
          flex: 1;
        }
        .goal-status-badge {
          font-size: 0.68rem;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 0.03em;
          padding: 2px 8px;
          border-radius: 8px;
        }
        .goal-status-reached { background: #f0fdf4; color: #166534; }
        .goal-status-on-track { background: #eff6ff; color: #1d4ed8; }
        .goal-status-at-risk { background: #fffbeb; color: #92400e; }
        .goal-status-behind { background: #fef2f2; color: #991b1b; }
        [data-theme="dark"] .goal-status-reached { background: #052e16; color: #86efac; }
        [data-theme="dark"] .goal-status-on-track { background: #172554; color: #93c5fd; }
        [data-theme="dark"] .goal-status-at-risk { background: #451a03; color: #fcd34d; }
        [data-theme="dark"] .goal-status-behind { background: #450a0a; color: #fca5a5; }
        .goal-remove {
          background: none;
          border: none;
          color: var(--color-text-muted);
          opacity: 0;
          cursor: pointer;
          font-size: 1rem;
          padding: 0 4px;
          transition: opacity 0.15s;
        }
        .goal-item:hover .goal-remove { opacity: 0.5; }
        .goal-remove:hover { opacity: 1 !important; color: #ef4444; }
        .goal-progress-row {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 4px;
        }
        .goal-current, .goal-target-val {
          font-size: 0.75rem;
          font-weight: 600;
          color: var(--color-text-muted);
          width: 60px;
          flex-shrink: 0;
        }
        .goal-target-val { text-align: right; }
        .goal-progress-bar {
          flex: 1;
          height: 6px;
          background: var(--color-border);
          border-radius: 3px;
          overflow: hidden;
        }
        .goal-progress-fill {
          height: 100%;
          background: var(--color-primary);
          border-radius: 3px;
          transition: width 0.4s ease;
          min-width: 2px;
        }
        .goal-item-reached .goal-progress-fill { background: #22c55e; }
        .goal-item-at-risk .goal-progress-fill { background: #eab308; }
        .goal-item-behind .goal-progress-fill { background: #ef4444; }
        .goal-meta-row {
          display: flex;
          justify-content: space-between;
          font-size: 0.72rem;
          color: var(--color-text-muted);
        }
        .goal-eta { font-weight: 500; }
        .goal-modal-fields { display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px; }
        .goal-modal-label {
          display: flex;
          flex-direction: column;
          gap: 4px;
          font-size: 0.82rem;
          font-weight: 500;
          color: var(--color-text-muted);
        }
        .goal-modal-row { display: flex; gap: 12px; }

        /* ── What-If Analysis ── */
        .whatif-card { }
        .whatif-header {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 8px;
        }
        .whatif-header h2 { font-size: 1rem; }
        .whatif-controls {
          display: flex;
          flex-direction: column;
          gap: 12px;
          margin-bottom: 16px;
        }
        .whatif-label {
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 0.82rem;
          font-weight: 500;
          color: var(--color-text-muted);
        }
        .whatif-slider-group { display: flex; flex-direction: column; gap: 4px; }
        .whatif-slider-labels {
          display: flex;
          justify-content: space-between;
          font-size: 0.72rem;
          color: var(--color-text-muted);
        }
        .whatif-current-val {
          font-weight: 700;
          color: var(--color-primary);
          font-size: 0.82rem;
        }
        .whatif-slider {
          width: 100%;
          accent-color: var(--color-primary);
          cursor: pointer;
        }
        .whatif-results {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 10px;
          margin-bottom: 16px;
        }
        .whatif-result-box {
          padding: 10px 12px;
          background: var(--color-bg);
          border-radius: 8px;
          text-align: center;
        }
        .whatif-result-label {
          font-size: 0.72rem;
          font-weight: 500;
          color: var(--color-text-muted);
          margin-bottom: 2px;
        }
        .whatif-result-value {
          font-size: 1.1rem;
          font-weight: 700;
        }
        .whatif-result-ci {
          font-size: 0.68rem;
          color: var(--color-text-muted);
        }
        .whatif-better { color: #22c55e; }
        .whatif-worse { color: #ef4444; }
        .whatif-scatter {
          display: block;
          width: 100%;
          max-width: 300px;
          background: var(--color-bg);
          border-radius: 8px;
          padding: 2px;
        }

        /* ── Trial Comparison ── */
        .history-compare-cell {
          text-align: center;
          padding: 8px 2px !important;
          cursor: pointer;
          width: 32px;
        }
        .compare-check {
          color: var(--color-text-muted);
          opacity: 0.2;
          transition: all 0.15s;
        }
        .compare-check:hover { opacity: 0.6; }
        .compare-active {
          color: var(--color-primary) !important;
          opacity: 1 !important;
        }
        .compare-modal {
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: 16px;
          padding: 24px 28px;
          min-width: 500px;
          max-width: 700px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: var(--shadow-lg);
        }
        .compare-table-wrap { overflow-x: auto; margin-bottom: 16px; }
        .compare-table {
          width: 100%;
          border-collapse: collapse;
          font-size: 0.82rem;
        }
        .compare-table th {
          padding: 8px 12px;
          font-weight: 600;
          text-align: center;
          border-bottom: 2px solid var(--color-border);
          font-size: 0.78rem;
        }
        .compare-table td {
          padding: 6px 12px;
          border-bottom: 1px solid var(--color-border-subtle);
        }
        .compare-label-col {
          text-align: left !important;
          width: 100px;
        }
        .compare-label {
          font-weight: 500;
          color: var(--color-text-muted);
          font-family: var(--font-mono);
          font-size: 0.78rem;
        }
        .compare-val { text-align: center; }
        .compare-val-best {
          font-weight: 700;
          color: var(--color-green);
        }
        .compare-best-col {
          background: rgba(34, 197, 94, 0.06);
        }
        .compare-best-tag {
          display: inline-block;
          margin-left: 6px;
          font-size: 0.6rem;
          font-weight: 700;
          text-transform: uppercase;
          color: #22c55e;
          background: rgba(34, 197, 94, 0.12);
          padding: 1px 5px;
          border-radius: 4px;
        }
        .compare-delta-col {
          width: 80px;
          text-align: center;
        }
        .compare-delta {
          text-align: center;
          font-size: 0.78rem;
          color: var(--color-text-muted);
        }
        .compare-delta-better { color: #22c55e !important; font-weight: 600; }
        .compare-delta-worse { color: #ef4444 !important; font-weight: 600; }
        .compare-kpi-row {
          background: rgba(79, 110, 247, 0.03);
        }
        .compare-footer {
          display: flex;
          justify-content: flex-end;
        }

        /* ── Batch Planner ── */
        .suggestion-select-check {
          position: absolute;
          top: 8px;
          left: 8px;
          z-index: 3;
          cursor: pointer;
          padding: 4px;
          border-radius: 4px;
          transition: background 0.15s;
        }
        .suggestion-select-check:hover {
          background: var(--color-bg);
        }
        .sug-check-idle {
          color: var(--color-text-muted);
          opacity: 0.25;
          transition: opacity 0.15s;
        }
        .suggestion-card-wrapper:hover .sug-check-idle {
          opacity: 0.6;
        }
        .sug-check-active {
          color: var(--color-primary);
          opacity: 1;
        }
        .suggestion-selected {
          outline: 2px solid var(--color-primary);
          outline-offset: -1px;
          border-radius: var(--radius-lg, 12px);
        }
        .batch-planner-bar {
          position: sticky;
          bottom: 0;
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 18px;
          background: var(--color-surface);
          border: 1px solid var(--color-primary);
          border-radius: 12px;
          box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.08);
          margin-top: 16px;
          animation: fadeSlideUp 0.2s ease;
        }
        .batch-planner-left {
          display: flex;
          align-items: center;
          gap: 10px;
          color: var(--color-primary);
          font-weight: 600;
          font-size: 0.88rem;
        }
        .batch-planner-count { color: var(--color-text); }
        .batch-diversity-pill {
          display: inline-flex;
          align-items: center;
          gap: 4px;
          padding: 2px 10px;
          background: var(--color-primary-subtle, rgba(79, 110, 247, 0.08));
          border-radius: 10px;
          font-size: 0.72rem;
          font-weight: 600;
          color: var(--color-primary);
        }
        .batch-planner-right {
          display: flex;
          gap: 8px;
        }

        /* ── Decision Journal ── */
        .decision-journal-card { padding: 16px 20px; }
        .decision-journal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 12px;
        }
        .journal-count {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-width: 20px;
          height: 20px;
          padding: 0 6px;
          background: var(--color-primary-subtle, rgba(79, 110, 247, 0.1));
          color: var(--color-primary);
          border-radius: 10px;
          font-size: 0.72rem;
          font-weight: 600;
        }
        .journal-input-row {
          display: flex;
          gap: 8px;
          margin-bottom: 12px;
        }
        .journal-input {
          flex: 1;
          padding: 8px 12px;
          border: 1px solid var(--color-border);
          border-radius: 8px;
          background: var(--color-bg);
          color: var(--color-text);
          font-family: var(--font-mono);
          font-size: 0.82rem;
        }
        .journal-input:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(79, 110, 247, 0.1); }
        .journal-empty {
          font-size: 0.82rem;
          color: var(--color-text-muted);
          font-style: italic;
          padding: 8px 0;
          margin: 0;
        }
        .journal-entries {
          display: flex;
          flex-direction: column;
          gap: 8px;
          max-height: 280px;
          overflow-y: auto;
        }
        .journal-entry {
          padding: 10px 12px;
          background: var(--color-bg);
          border: 1px solid var(--color-border-subtle, var(--color-border));
          border-radius: 8px;
          border-left: 3px solid var(--color-primary);
        }
        .journal-entry-meta {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 4px;
          font-size: 0.72rem;
          color: var(--color-text-muted);
        }
        .journal-iter {
          font-weight: 600;
          color: var(--color-primary);
          background: var(--color-primary-subtle, rgba(79, 110, 247, 0.08));
          padding: 1px 6px;
          border-radius: 4px;
        }
        .journal-delete {
          margin-left: auto;
          background: none;
          border: none;
          color: var(--color-text-muted);
          cursor: pointer;
          padding: 2px;
          border-radius: 4px;
          opacity: 0;
          transition: opacity 0.15s;
        }
        .journal-entry:hover .journal-delete { opacity: 1; }
        .journal-delete:hover { color: var(--color-red, #ef4444); background: rgba(239, 68, 68, 0.08); }
        .journal-entry-text {
          font-size: 0.85rem;
          color: var(--color-text);
          line-height: 1.5;
        }

        /* ── Replay Controls ── */
        .convergence-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
        .convergence-header h2 { margin: 0; }
        .replay-controls {
          display: flex;
          align-items: center;
          gap: 6px;
        }
        .replay-counter {
          font-family: var(--font-mono);
          font-size: 0.75rem;
          color: var(--color-text-muted);
          padding: 2px 8px;
          background: var(--color-bg);
          border-radius: 6px;
          border: 1px solid var(--color-border);
        }
        .replay-info {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 6px 12px;
          margin-top: 8px;
          background: var(--color-primary-subtle, rgba(79, 110, 247, 0.06));
          border-radius: 8px;
          font-size: 0.8rem;
          font-family: var(--font-mono);
          color: var(--color-text);
        }
        .replay-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background: var(--color-primary);
          animation: pulse 1s ease-in-out infinite;
        }
        .replay-best { font-weight: 600; color: var(--color-primary); }

        /* ── Trial Tags ── */
        .history-detail-tags {
          margin-top: 8px;
          display: flex;
          align-items: flex-start;
          gap: 8px;
        }
        .history-detail-tags .history-detail-label {
          display: flex;
          align-items: center;
          gap: 4px;
          padding-top: 3px;
        }
        .trial-tag-row {
          display: flex;
          flex-wrap: wrap;
          gap: 4px;
        }
        .trial-tag-btn {
          padding: 2px 10px;
          border-radius: 12px;
          border: 1px solid var(--color-border);
          background: var(--color-bg);
          color: var(--color-text-muted);
          font-size: 0.72rem;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
        }
        .trial-tag-btn:hover { border-color: var(--color-primary); color: var(--color-primary); }
        .trial-tag-active { border-color: transparent !important; color: white !important; }
        .trial-tag-active.trial-tag-promising { background: #22c55e; }
        .trial-tag-active.trial-tag-anomaly { background: #f59e0b; }
        .trial-tag-active.trial-tag-investigate { background: #3b82f6; }
        .trial-tag-active.trial-tag-baseline { background: #8b5cf6; }
        .trial-tag-active.trial-tag-outlier { background: #ef4444; }
        .trial-tag-active.trial-tag-equipment-issue { background: #64748b; }
        .trial-tag-dot {
          display: inline-block;
          width: 6px;
          height: 6px;
          border-radius: 50%;
          background: var(--color-primary);
          margin-left: 4px;
          vertical-align: middle;
        }

        /* ── Overview Actions Row ── */
        .overview-actions-row {
          display: flex;
          justify-content: flex-end;
          margin-bottom: 8px;
        }

        /* ── Histogram ── */
        .histogram-card {
          margin-bottom: 0;
        }

        /* ── Sample Efficiency ── */
        .efficiency-badge {
          font-size: 0.72rem;
          font-weight: 600;
          padding: 2px 8px;
          border-radius: 10px;
          background: var(--color-primary);
          color: white;
        }
        .efficiency-legend {
          display: flex;
          justify-content: center;
          gap: 16px;
          margin-top: 6px;
          font-size: 0.75rem;
          color: var(--color-text-muted);
        }
        .efficiency-legend-item {
          display: flex;
          align-items: center;
        }

        /* ── Parallel Coordinates Plot ── */
        .pcoord-line {
          transition: opacity 0.15s;
        }
        .pcoord-line:hover {
          stroke-width: 2.5 !important;
          opacity: 1 !important;
        }
        svg:has(.pcoord-line:hover) .pcoord-line:not(:hover) {
          opacity: 0.15 !important;
        }
        .pcoord-legend {
          display: flex;
          justify-content: center;
          gap: 16px;
          margin-top: 8px;
          font-size: 0.75rem;
          color: var(--color-text-muted);
        }
        .pcoord-legend-item {
          display: flex;
          align-items: center;
          gap: 5px;
        }
        .pcoord-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          display: inline-block;
        }

        /* ── Statistical Quick-Compare ── */
        .stat-compare-card {}
        .stat-compare-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
        }
        .stat-compare-badge {
          font-size: 0.7rem;
          font-weight: 600;
          padding: 2px 8px;
          border-radius: 10px;
          color: white;
          text-transform: uppercase;
          letter-spacing: 0.03em;
        }
        .stat-compare-body {
          margin-top: 12px;
        }
        .stat-compare-grid {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 12px;
          margin-bottom: 12px;
        }
        .stat-compare-group {
          padding: 10px 14px;
          border-radius: 8px;
          border: 1px solid var(--color-border);
        }
        .stat-compare-top {
          background: rgba(34, 197, 94, 0.04);
          border-color: rgba(34, 197, 94, 0.2);
        }
        .stat-compare-bottom {
          background: rgba(239, 68, 68, 0.04);
          border-color: rgba(239, 68, 68, 0.2);
        }
        .stat-compare-group-title {
          font-weight: 600;
          font-size: 0.82rem;
          margin-bottom: 6px;
        }
        .stat-compare-top .stat-compare-group-title { color: #22c55e; }
        .stat-compare-bottom .stat-compare-group-title { color: #ef4444; }
        .stat-compare-row {
          display: flex;
          justify-content: space-between;
          font-size: 0.82rem;
          padding: 3px 0;
        }
        .stat-compare-summary {
          padding: 10px 14px;
          background: var(--color-bg);
          border-radius: 8px;
          border: 1px solid var(--color-border);
        }

        /* ── Experiment Cost / Time Tracker ── */
        .cost-tracker-card {}
        .cost-tracker-grid {
          display: grid;
          grid-template-columns: repeat(4, 1fr);
          gap: 10px;
          margin-bottom: 14px;
        }
        .cost-tracker-item {
          text-align: center;
          padding: 8px;
          background: var(--color-bg);
          border-radius: 8px;
          border: 1px solid var(--color-border);
        }
        .cost-tracker-label {
          display: block;
          font-size: 0.72rem;
          text-transform: uppercase;
          letter-spacing: 0.04em;
          color: var(--color-text-muted);
          margin-bottom: 4px;
        }
        .cost-tracker-value {
          display: block;
          font-size: 1.1rem;
          font-weight: 700;
          font-family: var(--font-mono);
        }
        .cost-tracker-bar-section { margin-top: 4px; }
        .cost-tracker-bar-header {
          display: flex;
          justify-content: space-between;
          font-size: 0.78rem;
          margin-bottom: 4px;
          color: var(--color-text-muted);
        }
        .cost-tracker-bar {
          height: 8px;
          background: var(--color-border);
          border-radius: 4px;
          overflow: hidden;
        }
        .cost-tracker-bar-fill {
          height: 100%;
          border-radius: 4px;
          transition: width 0.4s ease;
        }
        .cost-tracker-warn {
          display: flex;
          align-items: center;
          gap: 6px;
          margin-top: 8px;
          font-size: 0.78rem;
          color: var(--color-yellow, #eab308);
          font-weight: 500;
        }

        /* ── Key Findings Summary ── */
        .findings-card {}
        .findings-badge {
          font-size: 0.72rem;
          font-weight: 700;
          padding: 2px 7px;
          border-radius: 10px;
          background: var(--color-primary);
          color: white;
        }
        .findings-list {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        .findings-item {
          display: flex;
          align-items: flex-start;
          gap: 10px;
          padding: 10px 14px;
          border-radius: 8px;
          font-size: 0.84rem;
          line-height: 1.5;
          border-left: 3px solid transparent;
        }
        .findings-success {
          background: rgba(34, 197, 94, 0.06);
          border-left-color: #22c55e;
        }
        .findings-info {
          background: rgba(59, 130, 246, 0.06);
          border-left-color: #3b82f6;
        }
        .findings-warning {
          background: rgba(234, 179, 8, 0.06);
          border-left-color: #eab308;
        }
        .findings-icon {
          flex-shrink: 0;
          margin-top: 2px;
          color: var(--color-text-muted);
        }
        .findings-success .findings-icon { color: #22c55e; }
        .findings-info .findings-icon { color: #3b82f6; }
        .findings-warning .findings-icon { color: #eab308; }
        .findings-text {
          color: var(--color-text);
        }

        /* ── Radar Chart ── */
        .radar-legend {
          display: flex;
          justify-content: center;
          gap: 16px;
          margin-top: 8px;
          font-size: 0.75rem;
          color: var(--color-text-muted);
        }
        .radar-legend-item {
          display: flex;
          align-items: center;
          gap: 5px;
        }
        .radar-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          display: inline-block;
        }
      `}</style>
    </div>
    </ErrorBoundary>
  );
}
