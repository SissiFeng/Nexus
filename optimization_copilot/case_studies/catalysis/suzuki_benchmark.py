"""Suzuki-Miyaura coupling offline replay benchmark.

Provides ``SuzukiBenchmark``, a ``ReplayBenchmark`` subclass that uses
``CatalysisDataLoader`` to generate synthetic training data and builds GP
surrogates for offline evaluation.

Search Space
------------
6 parameters (4 categorical + 2 continuous):

* ``catalyst`` -- 4 palladium catalysts
* ``ligand`` -- 6 phosphine ligands
* ``base`` -- 5 inorganic/organic bases
* ``solvent`` -- 4 common reaction solvents
* ``temperature`` -- continuous [40, 120] deg-C
* ``time`` -- continuous [1, 24] h

Objective
---------
``yield`` (maximize, unit "%").

Feasibility
-----------
Known catalyst-ligand incompatibilities from domain knowledge are
treated as infeasible (evaluate returns ``None``).

Known Optimum
-------------
~95 % yield (Pd2(dba)3 + SPhos, Cs2CO3, THF, 80 deg-C, 12+ h).
"""

from __future__ import annotations

from typing import Any

from optimization_copilot.case_studies.base import ReplayBenchmark
from optimization_copilot.case_studies.catalysis.data_loader import (
    CatalysisDataLoader,
    SOLVENTS,
)
from optimization_copilot.domain_knowledge.catalysis import (
    CATALYSTS,
    LIGANDS,
    BASES,
    check_catalyst_ligand_compatibility,
)


# ---------------------------------------------------------------------------
# Cost model constants
# ---------------------------------------------------------------------------

_BASE_COST: float = 1.0

# Expensive catalyst surcharges (normalised)
_CATALYST_COST: dict[str, float] = {
    "Pd(OAc)2": 0.0,
    "Pd(PPh3)4": 0.3,
    "PdCl2": 0.1,
    "Pd2(dba)3": 0.5,
}

# Expensive ligand surcharges
_LIGAND_COST: dict[str, float] = {
    "PPh3": 0.0,
    "XPhos": 0.4,
    "SPhos": 0.35,
    "BINAP": 0.6,
    "dppf": 0.25,
    "PCy3": 0.15,
}

# Longer reaction time adds cost (normalised per hour)
_TIME_COST_PER_HOUR: float = 0.02


# ---------------------------------------------------------------------------
# SuzukiBenchmark
# ---------------------------------------------------------------------------


class SuzukiBenchmark(ReplayBenchmark):
    """Offline replay benchmark for Suzuki-Miyaura coupling optimisation.

    Uses a GP surrogate fitted on synthetic data generated by
    ``CatalysisDataLoader``.  Evaluations return predicted yield with
    variance.  Infeasible catalyst-ligand combinations return ``None``.

    Parameters
    ----------
    n_train : int
        Number of training points for the surrogate (passed to the
        data loader).
    seed : int
        Random seed for reproducibility.
    """

    def __init__(self, n_train: int = 150, seed: int = 42) -> None:
        super().__init__(
            domain_name="catalysis",
            n_train=n_train,
            seed=seed,
        )

    # -- ReplayBenchmark interface -----------------------------------------

    def _generate_data(self) -> dict[str, Any]:
        """Use ``CatalysisDataLoader`` to generate training data.

        Returns
        -------
        dict
            ``{"X": list[list[float]],
              "Y": {"yield": list[float]},
              "noise_levels": {"yield": float}}``
        """
        loader = CatalysisDataLoader(n_points=self._n_train, seed=self._seed)
        return loader.get_data()

    def get_search_space(self) -> dict[str, dict[str, Any]]:
        """Return the 6-parameter search space.

        Key ordering must match the encoding used by
        ``CatalysisDataLoader._encode_point`` so that
        ``ReplayBenchmark._encode()`` produces vectors compatible with the
        surrogate training data.

        Returns
        -------
        dict[str, dict]
            ``{name: {"type": ..., "categories"|"range": ...}}``
        """
        space: dict[str, dict[str, Any]] = {}
        space["catalyst"] = {
            "type": "categorical",
            "categories": list(CATALYSTS),
        }
        space["ligand"] = {
            "type": "categorical",
            "categories": list(LIGANDS),
        }
        space["base"] = {
            "type": "categorical",
            "categories": list(BASES),
        }
        space["solvent"] = {
            "type": "categorical",
            "categories": list(SOLVENTS),
        }
        space["temperature"] = {
            "type": "continuous",
            "range": [40.0, 120.0],
        }
        space["time"] = {
            "type": "continuous",
            "range": [1.0, 24.0],
        }
        return space

    def get_objectives(self) -> dict[str, dict[str, Any]]:
        """Return objective definition: yield (maximize, %).

        Returns
        -------
        dict[str, dict]
            ``{"yield": {"direction": "maximize", "unit": "%"}}``
        """
        return {
            "yield": {
                "direction": "maximize",
                "unit": "%",
            },
        }

    def is_feasible(self, x: dict[str, Any]) -> bool:
        """Check catalyst-ligand compatibility using domain knowledge.

        Parameters
        ----------
        x : dict
            Point with at least ``catalyst`` and ``ligand`` keys.

        Returns
        -------
        bool
            ``True`` if the pair is compatible (no known incompatibility).
        """
        result = check_catalyst_ligand_compatibility(
            x.get("catalyst", ""),
            x.get("ligand", ""),
        )
        return result is None  # None means compatible

    def get_known_optimum(self) -> dict[str, float]:
        """Return the known optimum yield.

        Returns
        -------
        dict[str, float]
            ``{"yield": 95.0}``
        """
        return {"yield": 95.0}

    def get_evaluation_cost(self, x: dict[str, Any]) -> float:
        """Cost model: base cost + catalyst/ligand surcharges + time cost.

        Parameters
        ----------
        x : dict
            Point with ``catalyst``, ``ligand``, and ``time`` keys.

        Returns
        -------
        float
            Normalised evaluation cost (>= 1.0).
        """
        cost = _BASE_COST
        cost += _CATALYST_COST.get(x.get("catalyst", ""), 0.0)
        cost += _LIGAND_COST.get(x.get("ligand", ""), 0.0)
        cost += _TIME_COST_PER_HOUR * x.get("time", 1.0)
        return cost

    def get_known_constraints(self) -> list[dict[str, str]]:
        """Return known catalyst-ligand incompatibilities.

        Returns
        -------
        list[dict[str, str]]
            List of incompatibility entries from domain knowledge.
        """
        if self.domain_config is not None:
            return self.domain_config.get_known_incompatibilities()
        # Fallback: import directly
        from optimization_copilot.domain_knowledge.catalysis import (
            KNOWN_INCOMPATIBILITIES,
        )
        return list(KNOWN_INCOMPATIBILITIES)
