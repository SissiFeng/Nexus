"""Perovskite thin film composition benchmark for multi-objective offline replay.

Wraps :class:`PerovskiteDataLoader` in a :class:`ReplayBenchmark` that fits
separate GP surrogates for PCE and stability, enforces simplex and phase
stability constraints, and provides a cost model for evaluation budgeting.

All code uses the Python stdlib only -- no external dependencies.
"""

from __future__ import annotations

from typing import Any

from optimization_copilot.case_studies.base import ReplayBenchmark
from optimization_copilot.case_studies.perovskite.data_loader import (
    PerovskiteDataLoader,
)


# ---------------------------------------------------------------------------
# Search space definition (must match data_loader order)
# ---------------------------------------------------------------------------

_SEARCH_SPACE: dict[str, dict[str, Any]] = {
    "FA": {"type": "continuous", "range": [0.0, 1.0]},
    "MA": {"type": "continuous", "range": [0.0, 1.0]},
    "Cs": {"type": "continuous", "range": [0.0, 1.0]},
    "I": {"type": "continuous", "range": [0.0, 1.0]},
    "Br": {"type": "continuous", "range": [0.0, 1.0]},
    "annealing_temp": {"type": "continuous", "range": [80.0, 200.0]},
    "spin_speed": {"type": "continuous", "range": [1000.0, 6000.0]},
    "precursor_conc": {"type": "continuous", "range": [0.5, 2.0]},
}

_OBJECTIVES: dict[str, dict[str, str]] = {
    "PCE": {"direction": "maximize", "unit": "%"},
    "stability": {"direction": "maximize", "unit": "hours"},
}

# Base cost components (normalised relative units)
_BASE_COST: float = 1.0
_HIGH_TEMP_COST_FACTOR: float = 0.3     # extra cost above 160 deg C
_HIGH_SPEED_COST_FACTOR: float = 0.2    # extra cost above 5000 rpm
_HIGH_CONC_COST_FACTOR: float = 0.15    # extra cost for conc > 1.5 M


# ---------------------------------------------------------------------------
# PerovskiteBenchmark
# ---------------------------------------------------------------------------


class PerovskiteBenchmark(ReplayBenchmark):
    """Multi-objective offline replay benchmark for perovskite composition.

    Fits a separate :class:`SimpleSurrogate` for each objective (PCE and
    stability) from synthetic data generated by :class:`PerovskiteDataLoader`.

    Parameters
    ----------
    n_train : int
        Number of training points for the GP surrogates.
    seed : int
        Random seed for reproducibility.
    """

    def __init__(self, n_train: int = 120, seed: int = 42) -> None:
        # Store loader parameters before calling super().__init__() which
        # triggers _initialize() -> _generate_data().
        self._loader_n_train = n_train
        self._loader_seed = seed
        super().__init__(
            domain_name="perovskite",
            n_train=n_train,
            seed=seed,
        )

    # -- ReplayBenchmark interface -----------------------------------------

    def _generate_data(self) -> dict[str, Any]:
        """Generate training data via :class:`PerovskiteDataLoader`.

        Returns
        -------
        dict
            ``{"X": list[list[float]],
              "Y": {"PCE": list[float], "stability": list[float]},
              "noise_levels": {"PCE": float, "stability": float}}``
        """
        loader = PerovskiteDataLoader(
            n_points=self._loader_n_train,
            seed=self._loader_seed,
        )
        return loader.get_data()

    def get_search_space(self) -> dict[str, dict[str, Any]]:
        """Return the 8-parameter search space.

        Returns
        -------
        dict[str, dict]
            3 cation fractions, 2 halide fractions, 3 process parameters.
            All continuous.
        """
        return dict(_SEARCH_SPACE)

    def get_objectives(self) -> dict[str, dict[str, str]]:
        """Return objective definitions.

        Returns
        -------
        dict[str, dict]
            ``{"PCE": {"direction": "maximize", "unit": "%"},
              "stability": {"direction": "maximize", "unit": "hours"}}``
        """
        return dict(_OBJECTIVES)

    def is_feasible(self, x: dict[str, Any]) -> bool:
        """Check whether composition *x* satisfies all constraints.

        Checks:
        1. Cation simplex: FA + MA + Cs = 1.0 (tolerance 0.05).
        2. Halide simplex: I + Br = 1.0 (tolerance 0.05).
        3. Phase stability rules from domain knowledge.

        Parameters
        ----------
        x : dict
            Point in the search space, keyed by parameter name.

        Returns
        -------
        bool
            ``True`` if all constraints are satisfied.
        """
        from optimization_copilot.domain_knowledge.perovskite import (
            check_phase_stability,
            check_simplex_constraint,
        )

        # Check cation simplex
        cation_comp = {k: x.get(k, 0.0) for k in ("FA", "MA", "Cs")}
        if not check_simplex_constraint(cation_comp, tolerance=0.05):
            return False

        # Check halide simplex
        halide_comp = {k: x.get(k, 0.0) for k in ("I", "Br")}
        if not check_simplex_constraint(halide_comp, tolerance=0.05):
            return False

        # Phase stability
        composition = {**cation_comp, **halide_comp}
        if check_phase_stability(composition) is not None:
            return False

        return True

    def get_known_optimum(self) -> dict[str, float]:
        """Return known best objective values for regret calculation.

        Returns
        -------
        dict[str, float]
            ``{"PCE": 23.0, "stability": 800.0}``
        """
        return {"PCE": 23.0, "stability": 800.0}

    def get_evaluation_cost(self, x: dict[str, Any]) -> float:
        """Compute evaluation cost based on process parameters.

        Higher annealing temperatures, spin speeds, and precursor
        concentrations increase experimental cost.

        Parameters
        ----------
        x : dict
            Point in the search space.

        Returns
        -------
        float
            Positive cost value (normalised, base = 1.0).
        """
        cost = _BASE_COST

        anneal = float(x.get("annealing_temp", 130.0))
        if anneal > 160.0:
            cost += _HIGH_TEMP_COST_FACTOR * (anneal - 160.0) / 40.0

        spin = float(x.get("spin_speed", 4000.0))
        if spin > 5000.0:
            cost += _HIGH_SPEED_COST_FACTOR * (spin - 5000.0) / 1000.0

        conc = float(x.get("precursor_conc", 1.2))
        if conc > 1.5:
            cost += _HIGH_CONC_COST_FACTOR * (conc - 1.5) / 0.5

        return cost
